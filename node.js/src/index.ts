// Package units provides a standard way of working with unit for
// Alaka and Alakans alike. It's automatically generated via a
// .yaml file with a format that makes it really easy to add new
// units. Because we use code generation, we can provide functions
// that are super fast by using explicit values without the work
// of hand copying hundreds of methods across a bunch of permutations
// of the same thing.

// File autogenerated on 2022-02-24 17:10:38.118173552 -0600 CST m=+0.004344175.
// Do not edit directly

// Helper Types
export type scalar        = number
export type unitTitle     = string
export type unitTypeTitle = string
export type alakaTitle    = string
export type conversion    = (n: scalar) => scalar
export type matcher       = (s: string) => boolean

// Unit represents a scalar type of unit which can be converted to and from a base 
export class Unit {
	// title is used for code interfaces
	public readonly title: unitTitle
	// name is used for displays
	public readonly name: string
	// symbol is the symbol of the unit and can be displayed beside scalars
	public readonly symbol: string
	// matchList is a list of matching strings which should represent this unit in userland
	public readonly matchList: string[]
	// type returns the UnitType of this unit. You can access the BaseUnit from there
	public readonly type: UnitType
	// base returns the base Unit of this UnitType directly
	public readonly base: Unit

	// fromBase converts the given number of the unit type base to this unit
	public fromBase: conversion

	// toBase converts the given number of this unit type to the base unit
	public toBase: conversion
	
	// matches compares a string to a switch of all possible matches
	public matches: matcher

	constructor(
		title: unitTitle,
		name: string,
		symbol: string,
		matchList: string[],
		type: UnitType,
		base: Unit | null,
		fromBase: conversion,
		toBase: conversion,
		matches: matcher
	) {
		this.title = title
		this.name = name
		this.symbol = symbol
		this.matchList = matchList
		this.type = type
		if (base != null) {
			this.base = base
		} else {
			this.base = this
		}
		this.fromBase = fromBase.bind(this)
		this.toBase = toBase.bind(this)
		this.matches = matches.bind(this)
	}
}

// UnitType represents a collection of related units
export class UnitType {
	// title is used for code interfaces
	public readonly title: unitTypeTitle
	// name is used for displays
	public readonly name: string
	// base returns the primary unit of this unit type that is stored in Alaka.
	// Most of the time this is an SI unit, but not always (temperature is C,
	// not K, for example)
	// @ts-ignore
	public base: Unit
	// units returns all the supported units of this unit type
	// @ts-ignore
	public units: Unit[]
	// unitList returns all the supported units of this unit type as strings
	public readonly unitList: string[]
	// matchList is a list of matching strings which should represent this unit type in userland
	public readonly matchList: string[]

    // matches compares a string to a switch of all possible matches
	public matches: matcher

	constructor (
		title: unitTypeTitle,
		name: string,
		unitList: string[],
		matchList: string[],
		matches: matcher
	) {
		this.title = title
		this.name = name
		this.unitList = unitList
		this.matchList = matchList
		this.matches = matches.bind(this)
	}
}

const WhitespaceRegex = /\s/ig

// sanitizeString removes whitespace and lower cases the string
export function sanitizeString (input: string): string {
    const replaceValue = ''
    return input.toLowerCase().replace(WhitespaceRegex, replaceValue)
}

// toAlakaTitle returns the Alaka string representing this particular unit and unit type combo
export function toAlakaTitle (ut: UnitType, u: Unit): alakaTitle {
    return `${ut.title}_${u.title}`
}

// AllTypes is a list of all available types below
export const AllTypes: unitTypeTitle[] = [
	"Pressure",
    "Temperature",
    "Flow",
    "Volume",
    "ElectricPotential",
    "ElectricPotentialLoaded",
    "ElectricPotentialUnloaded",
    "Humidity",
    "Percentage",
    "Alarm",
    "Work",
    "Force",
    "Length",
    "StrokeRate",
    "Overspeed",
    "Underspeed",
    "Totaliser",
    "WMLFlowRate",
    "Number",
]

// AllUnits is a map of unit type -> units
export const AllUnits: { [index: unitTypeTitle]: unitTitle[] } = {
    "Pressure":                  ["Pascals","Kilopascals","Megapascals","PoundsPerSquareInch","InchesOfWater"],
    "Temperature":               ["DegreesCelsius","DegreesFahrenheit","Kelvins"],
    "Flow":                      ["CubicMetersPerSecond","CubicFeetPerSecond","ThousandCubicFeetPerDay"],
    "Volume":                    ["CubicMeters","CubicFeet","ThousandsOfCubicFeet"],
    "ElectricPotential":         ["Volts"],
    "ElectricPotentialLoaded":   ["Volts"],
    "ElectricPotentialUnloaded": ["Volts"],
    "Humidity":                  ["Percent"],
    "Percentage":                ["Percent"],
    "Alarm":                     ["Percent"],
    "Work":                      ["Joules","InchPoundsForce","CubicFeetOfNaturalGas","BarrelsOfOilEquivalent"],
    "Force":                     ["Newtons","PoundsForce","KilogramsForce"],
    "Length":                    ["Meters","Feet","Inches"],
    "StrokeRate":                ["StrokesPerSecond"],
    "Overspeed":                 ["Number"],
    "Underspeed":                ["Number"],
    "Totaliser":                 ["Number"],
    "WMLFlowRate":               ["Number"],
    "Number":                    ["Number"],
}

// AllUnitTypes is a list of all available Unit and Type combos below
// AKA the list of all possible output combinations of alakaTitle
export const AllUnitTypes: alakaTitle[] = [
	"Pressure_Pascals",
    "Pressure_Kilopascals",
    "Pressure_Megapascals",
    "Pressure_PoundsPerSquareInch",
    "Pressure_InchesOfWater",
    "Temperature_DegreesCelsius",
    "Temperature_DegreesFahrenheit",
    "Temperature_Kelvins",
    "Flow_CubicMetersPerSecond",
    "Flow_CubicFeetPerSecond",
    "Flow_ThousandCubicFeetPerDay",
    "Volume_CubicMeters",
    "Volume_CubicFeet",
    "Volume_ThousandsOfCubicFeet",
    "ElectricPotential_Volts",
    "ElectricPotentialLoaded_Volts",
    "ElectricPotentialUnloaded_Volts",
    "Humidity_Percent",
    "Percentage_Percent",
    "Alarm_Percent",
    "Work_Joules",
    "Work_InchPoundsForce",
    "Work_CubicFeetOfNaturalGas",
    "Work_BarrelsOfOilEquivalent",
    "Force_Newtons",
    "Force_PoundsForce",
    "Force_KilogramsForce",
    "Length_Meters",
    "Length_Feet",
    "Length_Inches",
    "StrokeRate_StrokesPerSecond",
    "Overspeed_Number",
    "Underspeed_Number",
    "Totaliser_Number",
    "WMLFlowRate_Number",
    "Number_Number",
]

// getType returns the unit type which matches input or NumberUnitType
export function getType (input: string): UnitType {
    switch (sanitizeString(input)) {
    case "pressure":
    	return PressureUnitType
    case "temperature":
    	return TemperatureUnitType
    case "temp":
    	return TemperatureUnitType
    case "flow":
    	return FlowUnitType
    case "flowrate":
    	return FlowUnitType
    case "flow_rate":
    	return FlowUnitType
    case "gasflow":
    	return FlowUnitType
    case "gasflowrate":
    	return FlowUnitType
    case "gas_flow":
    	return FlowUnitType
    case "gas_flow_rate":
    	return FlowUnitType
    case "volume":
    	return VolumeUnitType
    case "electricpotential":
    	return ElectricPotentialUnitType
    case "voltage":
    	return ElectricPotentialUnitType
    case "electricpotentialloaded":
    	return ElectricPotentialLoadedUnitType
    case "voltageloaded":
    	return ElectricPotentialLoadedUnitType
    case "electricpotentialunloaded":
    	return ElectricPotentialUnloadedUnitType
    case "voltageunloaded":
    	return ElectricPotentialUnloadedUnitType
    case "humidity":
    	return HumidityUnitType
    case "percentage":
    	return PercentageUnitType
    case "alarm":
    	return AlarmUnitType
    case "work":
    	return WorkUnitType
    case "force":
    	return ForceUnitType
    case "l":
    	return LengthUnitType
    case "length":
    	return LengthUnitType
    case "strokerate":
    	return StrokeRateUnitType
    case "stroke-rate":
    	return StrokeRateUnitType
    case "overspeed":
    	return OverspeedUnitType
    case "underspeed":
    	return UnderspeedUnitType
    case "totaliser":
    	return TotaliserUnitType
    case "wmlflowrate":
    	return WMLFlowRateUnitType
    case "*":
    	return NumberUnitType
    default:
    	return NumberUnitType
    }
}

// getUnit returns the unit which matches input or NumberNumberUnit
export function getUnit (input: string, typeOf: UnitType): Unit {
    const search = typeOf.title + "->" + sanitizeString(input)
    	switch (search) {
    case "Pressure->pa":
    	return PascalsPressureUnit
    case "Pressure->pascal":
    	return PascalsPressureUnit
    case "Pressure->pascals":
    	return PascalsPressureUnit
    case "Pressure->kpa":
    	return KilopascalsPressureUnit
    case "Pressure->kilopascal":
    	return KilopascalsPressureUnit
    case "Pressure->kilopascals":
    	return KilopascalsPressureUnit
    case "Pressure->mpa":
    	return MegapascalsPressureUnit
    case "Pressure->megapascal":
    	return MegapascalsPressureUnit
    case "Pressure->megapascals":
    	return MegapascalsPressureUnit
    case "Pressure->psi":
    	return PoundsPerSquareInchPressureUnit
    case "Pressure->poundspersquareinch":
    	return PoundsPerSquareInchPressureUnit
    case "Pressure->poundpersquareinch":
    	return PoundsPerSquareInchPressureUnit
    case "Pressure->inh₂o":
    	return InchesOfWaterPressureUnit
    case "Pressure->inh₂0":
    	return InchesOfWaterPressureUnit
    case "Pressure->inh2o":
    	return InchesOfWaterPressureUnit
    case "Pressure->inh20":
    	return InchesOfWaterPressureUnit
    case "Pressure->incheswater":
    	return InchesOfWaterPressureUnit
    case "Pressure->inchesofwater":
    	return InchesOfWaterPressureUnit
    case "Pressure->inchwater":
    	return InchesOfWaterPressureUnit
    case "Pressure->inchofwater":
    	return InchesOfWaterPressureUnit
    case "Temperature->c":
    	return DegreesCelsiusTemperatureUnit
    case "Temperature->°c":
    	return DegreesCelsiusTemperatureUnit
    case "Temperature->celsius":
    	return DegreesCelsiusTemperatureUnit
    case "Temperature->degreesc":
    	return DegreesCelsiusTemperatureUnit
    case "Temperature->degreec":
    	return DegreesCelsiusTemperatureUnit
    case "Temperature->degreescelsius":
    	return DegreesCelsiusTemperatureUnit
    case "Temperature->degreecelsius":
    	return DegreesCelsiusTemperatureUnit
    case "Temperature->f":
    	return DegreesFahrenheitTemperatureUnit
    case "Temperature->°f":
    	return DegreesFahrenheitTemperatureUnit
    case "Temperature->fahrenheit":
    	return DegreesFahrenheitTemperatureUnit
    case "Temperature->degreesf":
    	return DegreesFahrenheitTemperatureUnit
    case "Temperature->degreef":
    	return DegreesFahrenheitTemperatureUnit
    case "Temperature->degreesfahrenheit":
    	return DegreesFahrenheitTemperatureUnit
    case "Temperature->degreefahrenheit":
    	return DegreesFahrenheitTemperatureUnit
    case "Temperature->k":
    	return KelvinsTemperatureUnit
    case "Temperature->°k":
    	return KelvinsTemperatureUnit
    case "Temperature->kelvin":
    	return KelvinsTemperatureUnit
    case "Temperature->kelvins":
    	return KelvinsTemperatureUnit
    case "Temperature->degreesk":
    	return KelvinsTemperatureUnit
    case "Temperature->degreek":
    	return KelvinsTemperatureUnit
    case "Temperature->degreeskelvin":
    	return KelvinsTemperatureUnit
    case "Temperature->degreekelvin":
    	return KelvinsTemperatureUnit
    case "Flow->m³/s":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->m³s":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->m3/s":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->m3s":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->m^3/s":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->m^3s":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->cubicmeterspersecond":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->cubicmeterpersecond":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->cubicmeters/second":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->cubicmeter/second":
    	return CubicMetersPerSecondFlowUnit
    case "Flow->ft³/s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->ft³s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->ft3/s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->ft3s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->ft^3/s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->ft^3s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->f³/s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->f³s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->f3/s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->f3s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->f^3/s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->f^3s":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->cubicfeetpersecond":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->cubicfootpersecond":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->cubicfeet/second":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->cubicfoot/second":
    	return CubicFeetPerSecondFlowUnit
    case "Flow->mcfd":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mcf/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mcftd":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mcft/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mft³/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mft³d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mft3/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mft3d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mft^3/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mft^3d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mf³/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mf³d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mf3/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mf3d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mf^3/d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->mf^3d":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->thousandcubicfeetperday":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Flow->thousandcubicfeet/day":
    	return ThousandCubicFeetPerDayFlowUnit
    case "Volume->m³":
    	return CubicMetersVolumeUnit
    case "Volume->m3":
    	return CubicMetersVolumeUnit
    case "Volume->cubicmeter":
    	return CubicMetersVolumeUnit
    case "Volume->cubicmeters":
    	return CubicMetersVolumeUnit
    case "Volume->cuft":
    	return CubicFeetVolumeUnit
    case "Volume->ft³":
    	return CubicFeetVolumeUnit
    case "Volume->f³":
    	return CubicFeetVolumeUnit
    case "Volume->cubicfoot":
    	return CubicFeetVolumeUnit
    case "Volume->cubicfeet":
    	return CubicFeetVolumeUnit
    case "Volume->mcf":
    	return ThousandsOfCubicFeetVolumeUnit
    case "Volume->mft³":
    	return ThousandsOfCubicFeetVolumeUnit
    case "Volume->mf³":
    	return ThousandsOfCubicFeetVolumeUnit
    case "Volume->thousandcubicfeet":
    	return ThousandsOfCubicFeetVolumeUnit
    case "Volume->thousandsofcubicfeet":
    	return ThousandsOfCubicFeetVolumeUnit
    case "Volume->thousandscubicfeet":
    	return ThousandsOfCubicFeetVolumeUnit
    case "ElectricPotential->volt":
    	return VoltsElectricPotentialUnit
    case "ElectricPotential->volts":
    	return VoltsElectricPotentialUnit
    case "ElectricPotential->v":
    	return VoltsElectricPotentialUnit
    case "ElectricPotentialLoaded->volt":
    	return VoltsElectricPotentialLoadedUnit
    case "ElectricPotentialLoaded->volts":
    	return VoltsElectricPotentialLoadedUnit
    case "ElectricPotentialLoaded->v":
    	return VoltsElectricPotentialLoadedUnit
    case "ElectricPotentialUnloaded->volt":
    	return VoltsElectricPotentialUnloadedUnit
    case "ElectricPotentialUnloaded->volts":
    	return VoltsElectricPotentialUnloadedUnit
    case "ElectricPotentialUnloaded->v":
    	return VoltsElectricPotentialUnloadedUnit
    case "Humidity->%":
    	return PercentHumidityUnit
    case "Humidity->percent":
    	return PercentHumidityUnit
    case "Humidity->percentage":
    	return PercentHumidityUnit
    case "Percentage->%":
    	return PercentPercentageUnit
    case "Percentage->percent":
    	return PercentPercentageUnit
    case "Percentage->percentage":
    	return PercentPercentageUnit
    case "Alarm->%":
    	return PercentAlarmUnit
    case "Alarm->percent":
    	return PercentAlarmUnit
    case "Alarm->percentage":
    	return PercentAlarmUnit
    case "Work->j":
    	return JoulesWorkUnit
    case "Work->joule":
    	return JoulesWorkUnit
    case "Work->joules":
    	return JoulesWorkUnit
    case "Work->inlbf":
    	return InchPoundsForceWorkUnit
    case "Work->inch-poundsforce":
    	return InchPoundsForceWorkUnit
    case "Work->inch-poundforce":
    	return InchPoundsForceWorkUnit
    case "Work->in-lbf":
    	return InchPoundsForceWorkUnit
    case "Work->btuᵢₜ":
    	return CubicFeetOfNaturalGasWorkUnit
    case "Work->btuit":
    	return CubicFeetOfNaturalGasWorkUnit
    case "Work->btu":
    	return CubicFeetOfNaturalGasWorkUnit
    case "Work->cubicfeetofnaturalgas":
    	return CubicFeetOfNaturalGasWorkUnit
    case "Work->bboe":
    	return BarrelsOfOilEquivalentWorkUnit
    case "Work->barrelsofoilequivalent":
    	return BarrelsOfOilEquivalentWorkUnit
    case "Force->n":
    	return NewtonsForceUnit
    case "Force->newton":
    	return NewtonsForceUnit
    case "Force->newtons":
    	return NewtonsForceUnit
    case "Force->lbf":
    	return PoundsForceForceUnit
    case "Force->pounds-force":
    	return PoundsForceForceUnit
    case "Force->poundsforce":
    	return PoundsForceForceUnit
    case "Force->pound-force":
    	return PoundsForceForceUnit
    case "Force->poundforce":
    	return PoundsForceForceUnit
    case "Force->kgf":
    	return KilogramsForceForceUnit
    case "Force->kilograms-force":
    	return KilogramsForceForceUnit
    case "Force->kilogram-force":
    	return KilogramsForceForceUnit
    case "Length->m":
    	return MetersLengthUnit
    case "Length->meter":
    	return MetersLengthUnit
    case "Length->meters":
    	return MetersLengthUnit
    case "Length->ft":
    	return FeetLengthUnit
    case "Length->foot":
    	return FeetLengthUnit
    case "Length->feet":
    	return FeetLengthUnit
    case "Length->in":
    	return InchesLengthUnit
    case "Length->inch":
    	return InchesLengthUnit
    case "Length->inches":
    	return InchesLengthUnit
    case "StrokeRate->strokes/s":
    	return StrokesPerSecondStrokeRateUnit
    case "StrokeRate->strokespersecond":
    	return StrokesPerSecondStrokeRateUnit
    case "StrokeRate->s/s":
    	return StrokesPerSecondStrokeRateUnit
    case "Overspeed->number":
    	return NumberOverspeedUnit
    case "Overspeed->*":
    	return NumberOverspeedUnit
    case "Underspeed->number":
    	return NumberUnderspeedUnit
    case "Underspeed->*":
    	return NumberUnderspeedUnit
    case "Totaliser->number":
    	return NumberTotaliserUnit
    case "Totaliser->*":
    	return NumberTotaliserUnit
    case "WMLFlowRate->number":
    	return NumberWMLFlowRateUnit
    case "WMLFlowRate->*":
    	return NumberWMLFlowRateUnit
    case "Number->number":
    	return NumberNumberUnit
    case "Number->*":
    	return NumberNumberUnit
    default:
    	return NumberNumberUnit
    }
}

// getTypeUnit returns the unit type and unit which matches input or (NumberUnitType, NumberNumberUnit).
// Opposite of AlakaTitle
export function getTypeUnit (input: alakaTitle): [UnitType, Unit] {
    switch (input) {
    case "Pressure_Pascals":
    	return [PressureUnitType, PascalsPressureUnit]
    case "Pressure_Kilopascals":
    	return [PressureUnitType, KilopascalsPressureUnit]
    case "Pressure_Megapascals":
    	return [PressureUnitType, MegapascalsPressureUnit]
    case "Pressure_PoundsPerSquareInch":
    	return [PressureUnitType, PoundsPerSquareInchPressureUnit]
    case "Pressure_InchesOfWater":
    	return [PressureUnitType, InchesOfWaterPressureUnit]
    case "Temperature_DegreesCelsius":
    	return [TemperatureUnitType, DegreesCelsiusTemperatureUnit]
    case "Temperature_DegreesFahrenheit":
    	return [TemperatureUnitType, DegreesFahrenheitTemperatureUnit]
    case "Temperature_Kelvins":
    	return [TemperatureUnitType, KelvinsTemperatureUnit]
    case "Flow_CubicMetersPerSecond":
    	return [FlowUnitType, CubicMetersPerSecondFlowUnit]
    case "Flow_CubicFeetPerSecond":
    	return [FlowUnitType, CubicFeetPerSecondFlowUnit]
    case "Flow_ThousandCubicFeetPerDay":
    	return [FlowUnitType, ThousandCubicFeetPerDayFlowUnit]
    case "Volume_CubicMeters":
    	return [VolumeUnitType, CubicMetersVolumeUnit]
    case "Volume_CubicFeet":
    	return [VolumeUnitType, CubicFeetVolumeUnit]
    case "Volume_ThousandsOfCubicFeet":
    	return [VolumeUnitType, ThousandsOfCubicFeetVolumeUnit]
    case "ElectricPotential_Volts":
    	return [ElectricPotentialUnitType, VoltsElectricPotentialUnit]
    case "ElectricPotentialLoaded_Volts":
    	return [ElectricPotentialLoadedUnitType, VoltsElectricPotentialLoadedUnit]
    case "ElectricPotentialUnloaded_Volts":
    	return [ElectricPotentialUnloadedUnitType, VoltsElectricPotentialUnloadedUnit]
    case "Humidity_Percent":
    	return [HumidityUnitType, PercentHumidityUnit]
    case "Percentage_Percent":
    	return [PercentageUnitType, PercentPercentageUnit]
    case "Alarm_Percent":
    	return [AlarmUnitType, PercentAlarmUnit]
    case "Work_Joules":
    	return [WorkUnitType, JoulesWorkUnit]
    case "Work_InchPoundsForce":
    	return [WorkUnitType, InchPoundsForceWorkUnit]
    case "Work_CubicFeetOfNaturalGas":
    	return [WorkUnitType, CubicFeetOfNaturalGasWorkUnit]
    case "Work_BarrelsOfOilEquivalent":
    	return [WorkUnitType, BarrelsOfOilEquivalentWorkUnit]
    case "Force_Newtons":
    	return [ForceUnitType, NewtonsForceUnit]
    case "Force_PoundsForce":
    	return [ForceUnitType, PoundsForceForceUnit]
    case "Force_KilogramsForce":
    	return [ForceUnitType, KilogramsForceForceUnit]
    case "Length_Meters":
    	return [LengthUnitType, MetersLengthUnit]
    case "Length_Feet":
    	return [LengthUnitType, FeetLengthUnit]
    case "Length_Inches":
    	return [LengthUnitType, InchesLengthUnit]
    case "StrokeRate_StrokesPerSecond":
    	return [StrokeRateUnitType, StrokesPerSecondStrokeRateUnit]
    case "Overspeed_Number":
    	return [OverspeedUnitType, NumberOverspeedUnit]
    case "Underspeed_Number":
    	return [UnderspeedUnitType, NumberUnderspeedUnit]
    case "Totaliser_Number":
    	return [TotaliserUnitType, NumberTotaliserUnit]
    case "WMLFlowRate_Number":
    	return [WMLFlowRateUnitType, NumberWMLFlowRateUnit]
    case "Number_Number":
    	return [NumberUnitType, NumberNumberUnit]
    default:
    	return [NumberUnitType, NumberNumberUnit]
    }
}

// Pressure (UnitType)
// Contains 5 units:
//  - PascalsPressure             Pa => Pa                 = Pa
//  - KilopascalsPressure         Pa => Pa * 0.001         = kPa
//  - MegapascalsPressure         Pa => Pa * 0.000,001     = MPa
//  - PoundsPerSquareInchPressure Pa => Pa * 0.000,145,038 = psi
//  - InchesOfWaterPressure       Pa => Pa * 0.004,014,74  = inH₂O
// Base: PascalsPressure

export const PressureUnitType = new UnitType(
	// title
	'Pressure',
	// name
	'Pressure',
	// unitList
	["Pascals","Kilopascals","Megapascals","Pounds per Square Inch","Inches of Water"],
	// matchList
	["pressure"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// PascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa = Pa
// Unit.ToBase  : Pa => Pa = Pa

export const PascalsPressureUnit = new Unit(
	// title
	'Pascals',
	// name
	'Pascals',
	// symbol
	'Pa',
	// matchList
	["pa","pascal","pascals"],
	// type
	PressureUnitType,
	// base
	null,
		// fromBase converts Pa to Pa
	function fromBase (Pa: scalar): scalar {
	    return Pa
	},
		// toBase converts Pa to Pa
	function toBase (Pa: scalar): scalar {
	    return Pa
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// KilopascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.001   = kPa
// Unit.ToBase  : kPa => kPa * 1,000 = Pa

export const KilopascalsPressureUnit = new Unit(
	// title
	'Kilopascals',
	// name
	'Kilopascals',
	// symbol
	'kPa',
	// matchList
	["kpa","kilopascal","kilopascals"],
	// type
	PressureUnitType,
	// base
	PascalsPressureUnit,
		// fromBase converts Pa to kPa
	function fromBase (Pa: scalar): scalar {
	    return Pa * 0.001
	},
		// toBase converts kPa to Pa
	function toBase (kPa: scalar): scalar {
	    return kPa * 1000
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// MegapascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,001   = MPa
// Unit.ToBase  : MPa => MPa * 1,000,000 = Pa

export const MegapascalsPressureUnit = new Unit(
	// title
	'Megapascals',
	// name
	'Megapascals',
	// symbol
	'MPa',
	// matchList
	["mpa","megapascal","megapascals"],
	// type
	PressureUnitType,
	// base
	PascalsPressureUnit,
		// fromBase converts Pa to MPa
	function fromBase (Pa: scalar): scalar {
	    return Pa * 0.000001
	},
		// toBase converts MPa to Pa
	function toBase (MPa: scalar): scalar {
	    return MPa * 1000000
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// PoundsPerSquareInchPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,145,038 = psi
// Unit.ToBase  : psi => psi * 6,894.76    = Pa

export const PoundsPerSquareInchPressureUnit = new Unit(
	// title
	'PoundsPerSquareInch',
	// name
	'Pounds per Square Inch',
	// symbol
	'psi',
	// matchList
	["psi","poundspersquareinch","poundpersquareinch"],
	// type
	PressureUnitType,
	// base
	PascalsPressureUnit,
		// fromBase converts Pa to psi
	function fromBase (Pa: scalar): scalar {
	    return Pa * 0.000145038
	},
		// toBase converts psi to Pa
	function toBase (psi: scalar): scalar {
	    return psi * 6894.76
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// InchesOfWaterPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.004,014,74  = inH₂O
// Unit.ToBase  : inH2O => inH2O * 249.082 = Pa

export const InchesOfWaterPressureUnit = new Unit(
	// title
	'InchesOfWater',
	// name
	'Inches of Water',
	// symbol
	'inH₂O',
	// matchList
	["inh₂o","inh₂0","inh2o","inh20","incheswater","inchesofwater","inchwater","inchofwater"],
	// type
	PressureUnitType,
	// base
	PascalsPressureUnit,
		// fromBase converts Pa to inH₂O
	function fromBase (Pa: scalar): scalar {
	    return Pa * 0.00401474
	},
		// toBase converts inH₂O to Pa
	function toBase (inH2O: scalar): scalar {
	    return inH2O * 249.082
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

PressureUnitType.base = PascalsPressureUnit
PressureUnitType.units = [PascalsPressureUnit,KilopascalsPressureUnit,MegapascalsPressureUnit,PoundsPerSquareInchPressureUnit,InchesOfWaterPressureUnit]

// Temperature (UnitType)
// Contains 3 units:
//  - DegreesCelsiusTemperature    C => C                  = °C
//  - DegreesFahrenheitTemperature C => (C * (9 / 5)) + 32 = °F
//  - KelvinsTemperature           C => C + 273.15         = K
// Base: DegreesCelsiusTemperature

export const TemperatureUnitType = new UnitType(
	// title
	'Temperature',
	// name
	'Temperature',
	// unitList
	["Degrees Celsius","Degrees Fahrenheit","Kelvins"],
	// matchList
	["temperature","temp"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// DegreesCelsiusTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C = °C
// Unit.ToBase  : C => C = °C

export const DegreesCelsiusTemperatureUnit = new Unit(
	// title
	'DegreesCelsius',
	// name
	'Degrees Celsius',
	// symbol
	'°C',
	// matchList
	["c","°c","celsius","degreesc","degreec","degreescelsius","degreecelsius"],
	// type
	TemperatureUnitType,
	// base
	null,
		// fromBase converts °C to °C
	function fromBase (C: scalar): scalar {
	    return C
	},
		// toBase converts °C to °C
	function toBase (C: scalar): scalar {
	    return C
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// DegreesFahrenheitTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => (C * (9 / 5)) + 32 = °F
// Unit.ToBase  : F => (F - 32) * (5 / 9) = °C

export const DegreesFahrenheitTemperatureUnit = new Unit(
	// title
	'DegreesFahrenheit',
	// name
	'Degrees Fahrenheit',
	// symbol
	'°F',
	// matchList
	["f","°f","fahrenheit","degreesf","degreef","degreesfahrenheit","degreefahrenheit"],
	// type
	TemperatureUnitType,
	// base
	DegreesCelsiusTemperatureUnit,
		// fromBase converts °C to °F
	function fromBase (C: scalar): scalar {
	    return (C * (9 / 5)) + 32
	},
		// toBase converts °F to °C
	function toBase (F: scalar): scalar {
	    return (F - 32) * (5 / 9)
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// KelvinsTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C + 273.15 = K
// Unit.ToBase  : K => K - 273.15 = °C

export const KelvinsTemperatureUnit = new Unit(
	// title
	'Kelvins',
	// name
	'Kelvins',
	// symbol
	'K',
	// matchList
	["k","°k","kelvin","kelvins","degreesk","degreek","degreeskelvin","degreekelvin"],
	// type
	TemperatureUnitType,
	// base
	DegreesCelsiusTemperatureUnit,
		// fromBase converts °C to K
	function fromBase (C: scalar): scalar {
	    return C + 273.15
	},
		// toBase converts K to °C
	function toBase (K: scalar): scalar {
	    return K - 273.15
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

TemperatureUnitType.base = DegreesCelsiusTemperatureUnit
TemperatureUnitType.units = [DegreesCelsiusTemperatureUnit,DegreesFahrenheitTemperatureUnit,KelvinsTemperatureUnit]

// Flow (UnitType)
// Contains 3 units:
//  - CubicMetersPerSecondFlow    m3s => m3s            = m³/s
//  - CubicFeetPerSecondFlow      m3s => m3s * 35.314,7 = ft³/s
//  - ThousandCubicFeetPerDayFlow m3s => m3s * 3,051.19 = MCFD
// Base: CubicMetersPerSecondFlow

export const FlowUnitType = new UnitType(
	// title
	'Flow',
	// name
	'Flow',
	// unitList
	["Cubic Meters per Second","CubicFeetPerSecond","Thousand Cubic Feet per Day"],
	// matchList
	["flow","flowrate","flow_rate","gasflow","gasflowrate","gas_flow","gas_flow_rate"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// CubicMetersPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s = m³/s
// Unit.ToBase  : m3s => m3s = m³/s

export const CubicMetersPerSecondFlowUnit = new Unit(
	// title
	'CubicMetersPerSecond',
	// name
	'Cubic Meters per Second',
	// symbol
	'm³/s',
	// matchList
	["m³/s","m³s","m3/s","m3s","m^3/s","m^3s","cubicmeterspersecond","cubicmeterpersecond","cubicmeters/second","cubicmeter/second"],
	// type
	FlowUnitType,
	// base
	null,
		// fromBase converts m³/s to m³/s
	function fromBase (m3s: scalar): scalar {
	    return m3s
	},
		// toBase converts m³/s to m³/s
	function toBase (m3s: scalar): scalar {
	    return m3s
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// CubicFeetPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 35.314,7      = ft³/s
// Unit.ToBase  : ft3s => ft3s * 0.028,316,8 = m³/s

export const CubicFeetPerSecondFlowUnit = new Unit(
	// title
	'CubicFeetPerSecond',
	// name
	'CubicFeetPerSecond',
	// symbol
	'ft³/s',
	// matchList
	["ft³/s","ft³s","ft3/s","ft3s","ft^3/s","ft^3s","f³/s","f³s","f3/s","f3s","f^3/s","f^3s","cubicfeetpersecond","cubicfootpersecond","cubicfeet/second","cubicfoot/second"],
	// type
	FlowUnitType,
	// base
	CubicMetersPerSecondFlowUnit,
		// fromBase converts m³/s to ft³/s
	function fromBase (m3s: scalar): scalar {
	    return m3s * 35.3147
	},
		// toBase converts ft³/s to m³/s
	function toBase (ft3s: scalar): scalar {
	    return ft3s * 0.0283168
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// ThousandCubicFeetPerDayFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 3,051.19        = MCFD
// Unit.ToBase  : MCFD => MCFD * 0.000,327,741 = m³/s

export const ThousandCubicFeetPerDayFlowUnit = new Unit(
	// title
	'ThousandCubicFeetPerDay',
	// name
	'Thousand Cubic Feet per Day',
	// symbol
	'MCFD',
	// matchList
	["mcfd","mcf/d","mcftd","mcft/d","mft³/d","mft³d","mft3/d","mft3d","mft^3/d","mft^3d","mf³/d","mf³d","mf3/d","mf3d","mf^3/d","mf^3d","thousandcubicfeetperday","thousandcubicfeet/day"],
	// type
	FlowUnitType,
	// base
	CubicMetersPerSecondFlowUnit,
		// fromBase converts m³/s to MCFD
	function fromBase (m3s: scalar): scalar {
	    return m3s * 3051.19
	},
		// toBase converts MCFD to m³/s
	function toBase (MCFD: scalar): scalar {
	    return MCFD * 0.000327741
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

FlowUnitType.base = CubicMetersPerSecondFlowUnit
FlowUnitType.units = [CubicMetersPerSecondFlowUnit,CubicFeetPerSecondFlowUnit,ThousandCubicFeetPerDayFlowUnit]

// Volume (UnitType)
// Contains 3 units:
//  - CubicMetersVolume          m3 => m3               = m³
//  - CubicFeetVolume            m3 => m3 * 35.314,7    = cu ft
//  - ThousandsOfCubicFeetVolume m3 => m3 * 0.035,314,7 = MCF
// Base: CubicMetersVolume

export const VolumeUnitType = new UnitType(
	// title
	'Volume',
	// name
	'Volume',
	// unitList
	["Cubic Meters","Cubic Feet","Thousands of Cubic Feet"],
	// matchList
	["volume"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// CubicMetersVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 = m³
// Unit.ToBase  : m3 => m3 = m³

export const CubicMetersVolumeUnit = new Unit(
	// title
	'CubicMeters',
	// name
	'Cubic Meters',
	// symbol
	'm³',
	// matchList
	["m³","m3","cubicmeter","cubicmeters"],
	// type
	VolumeUnitType,
	// base
	null,
		// fromBase converts m³ to m³
	function fromBase (m3: scalar): scalar {
	    return m3
	},
		// toBase converts m³ to m³
	function toBase (m3: scalar): scalar {
	    return m3
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// CubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 35.314,7        = cu ft
// Unit.ToBase  : cuft => cuft * 0.028,316,8 = m³

export const CubicFeetVolumeUnit = new Unit(
	// title
	'CubicFeet',
	// name
	'Cubic Feet',
	// symbol
	'cu ft',
	// matchList
	["cuft","ft³","f³","cubicfoot","cubicfeet"],
	// type
	VolumeUnitType,
	// base
	CubicMetersVolumeUnit,
		// fromBase converts m³ to cu ft
	function fromBase (m3: scalar): scalar {
	    return m3 * 35.3147
	},
		// toBase converts cu ft to m³
	function toBase (cuft: scalar): scalar {
	    return cuft * 0.0283168
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// ThousandsOfCubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 0.035,314,7 = MCF
// Unit.ToBase  : MCF => MCF * 28.316,8  = m³

export const ThousandsOfCubicFeetVolumeUnit = new Unit(
	// title
	'ThousandsOfCubicFeet',
	// name
	'Thousands of Cubic Feet',
	// symbol
	'MCF',
	// matchList
	["mcf","mft³","mf³","thousandcubicfeet","thousandsofcubicfeet","thousandscubicfeet"],
	// type
	VolumeUnitType,
	// base
	CubicMetersVolumeUnit,
		// fromBase converts m³ to MCF
	function fromBase (m3: scalar): scalar {
	    return m3 * 0.0353147
	},
		// toBase converts MCF to m³
	function toBase (MCF: scalar): scalar {
	    return MCF * 28.3168
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

VolumeUnitType.base = CubicMetersVolumeUnit
VolumeUnitType.units = [CubicMetersVolumeUnit,CubicFeetVolumeUnit,ThousandsOfCubicFeetVolumeUnit]

// ElectricPotential (UnitType)
// Contains 1 units:
//  - VoltsElectricPotential V => V = V
// Base: VoltsElectricPotential

export const ElectricPotentialUnitType = new UnitType(
	// title
	'ElectricPotential',
	// name
	'Electric Potential',
	// unitList
	["Volts"],
	// matchList
	["electricpotential","voltage"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// VoltsElectricPotential (Unit)
// UnitType     : ElectricPotential
// UnitType.Base: VoltsElectricPotential
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V

export const VoltsElectricPotentialUnit = new Unit(
	// title
	'Volts',
	// name
	'Volts',
	// symbol
	'V',
	// matchList
	["volt","volts","v"],
	// type
	ElectricPotentialUnitType,
	// base
	null,
		// fromBase converts V to V
	function fromBase (V: scalar): scalar {
	    return V
	},
		// toBase converts V to V
	function toBase (V: scalar): scalar {
	    return V
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

ElectricPotentialUnitType.base = VoltsElectricPotentialUnit
ElectricPotentialUnitType.units = [VoltsElectricPotentialUnit]

// ElectricPotentialLoaded (UnitType)
// Contains 1 units:
//  - VoltsElectricPotentialLoaded V => V = V
// Base: VoltsElectricPotentialLoaded

export const ElectricPotentialLoadedUnitType = new UnitType(
	// title
	'ElectricPotentialLoaded',
	// name
	'Electric Potential Loaded',
	// unitList
	["Volts"],
	// matchList
	["electricpotentialloaded","voltageloaded"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// VoltsElectricPotentialLoaded (Unit)
// UnitType     : ElectricPotentialLoaded
// UnitType.Base: VoltsElectricPotentialLoaded
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V

export const VoltsElectricPotentialLoadedUnit = new Unit(
	// title
	'Volts',
	// name
	'Volts',
	// symbol
	'V',
	// matchList
	["volt","volts","v"],
	// type
	ElectricPotentialLoadedUnitType,
	// base
	null,
		// fromBase converts V to V
	function fromBase (V: scalar): scalar {
	    return V
	},
		// toBase converts V to V
	function toBase (V: scalar): scalar {
	    return V
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

ElectricPotentialLoadedUnitType.base = VoltsElectricPotentialLoadedUnit
ElectricPotentialLoadedUnitType.units = [VoltsElectricPotentialLoadedUnit]

// ElectricPotentialUnloaded (UnitType)
// Contains 1 units:
//  - VoltsElectricPotentialUnloaded V => V = V
// Base: VoltsElectricPotentialUnloaded

export const ElectricPotentialUnloadedUnitType = new UnitType(
	// title
	'ElectricPotentialUnloaded',
	// name
	'Electric Potential Unloaded',
	// unitList
	["Volts"],
	// matchList
	["electricpotentialunloaded","voltageunloaded"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// VoltsElectricPotentialUnloaded (Unit)
// UnitType     : ElectricPotentialUnloaded
// UnitType.Base: VoltsElectricPotentialUnloaded
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V

export const VoltsElectricPotentialUnloadedUnit = new Unit(
	// title
	'Volts',
	// name
	'Volts',
	// symbol
	'V',
	// matchList
	["volt","volts","v"],
	// type
	ElectricPotentialUnloadedUnitType,
	// base
	null,
		// fromBase converts V to V
	function fromBase (V: scalar): scalar {
	    return V
	},
		// toBase converts V to V
	function toBase (V: scalar): scalar {
	    return V
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

ElectricPotentialUnloadedUnitType.base = VoltsElectricPotentialUnloadedUnit
ElectricPotentialUnloadedUnitType.units = [VoltsElectricPotentialUnloadedUnit]

// Humidity (UnitType)
// Contains 1 units:
//  - PercentHumidity p => p = %
// Base: PercentHumidity

export const HumidityUnitType = new UnitType(
	// title
	'Humidity',
	// name
	'Humidity',
	// unitList
	["Percent"],
	// matchList
	["humidity"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// PercentHumidity (Unit)
// UnitType     : Humidity
// UnitType.Base: PercentHumidity
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %

export const PercentHumidityUnit = new Unit(
	// title
	'Percent',
	// name
	'Percent',
	// symbol
	'%',
	// matchList
	["%","percent","percentage"],
	// type
	HumidityUnitType,
	// base
	null,
		// fromBase converts % to %
	function fromBase (p: scalar): scalar {
	    return p
	},
		// toBase converts % to %
	function toBase (p: scalar): scalar {
	    return p
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

HumidityUnitType.base = PercentHumidityUnit
HumidityUnitType.units = [PercentHumidityUnit]

// Percentage (UnitType)
// Contains 1 units:
//  - PercentPercentage p => p = %
// Base: PercentPercentage

export const PercentageUnitType = new UnitType(
	// title
	'Percentage',
	// name
	'Percentage',
	// unitList
	["Percent"],
	// matchList
	["percentage"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// PercentPercentage (Unit)
// UnitType     : Percentage
// UnitType.Base: PercentPercentage
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %

export const PercentPercentageUnit = new Unit(
	// title
	'Percent',
	// name
	'Percent',
	// symbol
	'%',
	// matchList
	["%","percent","percentage"],
	// type
	PercentageUnitType,
	// base
	null,
		// fromBase converts % to %
	function fromBase (p: scalar): scalar {
	    return p
	},
		// toBase converts % to %
	function toBase (p: scalar): scalar {
	    return p
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

PercentageUnitType.base = PercentPercentageUnit
PercentageUnitType.units = [PercentPercentageUnit]

// Alarm (UnitType)
// Contains 1 units:
//  - PercentAlarm p => p = %
// Base: PercentAlarm

export const AlarmUnitType = new UnitType(
	// title
	'Alarm',
	// name
	'Alarm',
	// unitList
	["Percent"],
	// matchList
	["alarm"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// PercentAlarm (Unit)
// UnitType     : Alarm
// UnitType.Base: PercentAlarm
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %

export const PercentAlarmUnit = new Unit(
	// title
	'Percent',
	// name
	'Percent',
	// symbol
	'%',
	// matchList
	["%","percent","percentage"],
	// type
	AlarmUnitType,
	// base
	null,
		// fromBase converts % to %
	function fromBase (p: scalar): scalar {
	    return p
	},
		// toBase converts % to %
	function toBase (p: scalar): scalar {
	    return p
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

AlarmUnitType.base = PercentAlarmUnit
AlarmUnitType.units = [PercentAlarmUnit]

// Work (UnitType)
// Contains 4 units:
//  - JoulesWork                 J => J                         = J
//  - InchPoundsForceWork        J => J * 8.850,74              = in lbf
//  - CubicFeetOfNaturalGasWork  J => J * 0.000,000,947,817     = BTUᵢₜ
//  - BarrelsOfOilEquivalentWork J => J * 0.000,000,000,163,399 = bboe
// Base: JoulesWork

export const WorkUnitType = new UnitType(
	// title
	'Work',
	// name
	'Work',
	// unitList
	["Joules","Inch-pounds Force","Cubic Feet of Natural Gas","Barrels of Oil Equivalent"],
	// matchList
	["work"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// JoulesWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J = J
// Unit.ToBase  : J => J = J

export const JoulesWorkUnit = new Unit(
	// title
	'Joules',
	// name
	'Joules',
	// symbol
	'J',
	// matchList
	["j","joule","joules"],
	// type
	WorkUnitType,
	// base
	null,
		// fromBase converts J to J
	function fromBase (J: scalar): scalar {
	    return J
	},
		// toBase converts J to J
	function toBase (J: scalar): scalar {
	    return J
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// InchPoundsForceWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 8.850,74          = in lbf
// Unit.ToBase  : inlbf => inlbf * 0.112,985 = J

export const InchPoundsForceWorkUnit = new Unit(
	// title
	'InchPoundsForce',
	// name
	'Inch-pounds Force',
	// symbol
	'in lbf',
	// matchList
	["inlbf","inch-poundsforce","inch-poundforce","in-lbf"],
	// type
	WorkUnitType,
	// base
	JoulesWorkUnit,
		// fromBase converts J to in lbf
	function fromBase (J: scalar): scalar {
	    return J * 8.85074
	},
		// toBase converts in lbf to J
	function toBase (inlbf: scalar): scalar {
	    return inlbf * 0.112985
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// CubicFeetOfNaturalGasWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,947,817 = BTUᵢₜ
// Unit.ToBase  : btu => btu * 1,055,060     = J

export const CubicFeetOfNaturalGasWorkUnit = new Unit(
	// title
	'CubicFeetOfNaturalGas',
	// name
	'Cubic Feet of Natural Gas',
	// symbol
	'BTUᵢₜ',
	// matchList
	["btuᵢₜ","btuit","btu","cubicfeetofnaturalgas"],
	// type
	WorkUnitType,
	// base
	JoulesWorkUnit,
		// fromBase converts J to BTUᵢₜ
	function fromBase (J: scalar): scalar {
	    return J * 0.000000947817
	},
		// toBase converts BTUᵢₜ to J
	function toBase (btu: scalar): scalar {
	    return btu * 1055060
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// BarrelsOfOilEquivalentWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,000,163,399 = bboe
// Unit.ToBase  : bboe => bboe * 6,120,000,000   = J

export const BarrelsOfOilEquivalentWorkUnit = new Unit(
	// title
	'BarrelsOfOilEquivalent',
	// name
	'Barrels of Oil Equivalent',
	// symbol
	'bboe',
	// matchList
	["bboe","barrelsofoilequivalent"],
	// type
	WorkUnitType,
	// base
	JoulesWorkUnit,
		// fromBase converts J to bboe
	function fromBase (J: scalar): scalar {
	    return J * 0.000000000163399
	},
		// toBase converts bboe to J
	function toBase (bboe: scalar): scalar {
	    return bboe * 6120000000
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

WorkUnitType.base = JoulesWorkUnit
WorkUnitType.units = [JoulesWorkUnit,InchPoundsForceWorkUnit,CubicFeetOfNaturalGasWorkUnit,BarrelsOfOilEquivalentWorkUnit]

// Force (UnitType)
// Contains 3 units:
//  - NewtonsForce        N => N             = N
//  - PoundsForceForce    N => N * 0.224,809 = lbf
//  - KilogramsForceForce N => N * 0.101,972 = kgf
// Base: NewtonsForce

export const ForceUnitType = new UnitType(
	// title
	'Force',
	// name
	'Force',
	// unitList
	["Newtons","Pounds-force","Kilograms-force"],
	// matchList
	["force"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// NewtonsForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N

export const NewtonsForceUnit = new Unit(
	// title
	'Newtons',
	// name
	'Newtons',
	// symbol
	'N',
	// matchList
	["n","newton","newtons"],
	// type
	ForceUnitType,
	// base
	null,
		// fromBase converts N to N
	function fromBase (N: scalar): scalar {
	    return N
	},
		// toBase converts N to N
	function toBase (N: scalar): scalar {
	    return N
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// PoundsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N

export const PoundsForceForceUnit = new Unit(
	// title
	'PoundsForce',
	// name
	'Pounds-force',
	// symbol
	'lbf',
	// matchList
	["lbf","pounds-force","poundsforce","pound-force","poundforce"],
	// type
	ForceUnitType,
	// base
	NewtonsForceUnit,
		// fromBase converts N to lbf
	function fromBase (N: scalar): scalar {
	    return N * 0.224809
	},
		// toBase converts lbf to N
	function toBase (lbf: scalar): scalar {
	    return lbf * 4.44822
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// KilogramsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N

export const KilogramsForceForceUnit = new Unit(
	// title
	'KilogramsForce',
	// name
	'Kilograms-force',
	// symbol
	'kgf',
	// matchList
	["kgf","kilograms-force","kilogram-force"],
	// type
	ForceUnitType,
	// base
	NewtonsForceUnit,
		// fromBase converts N to kgf
	function fromBase (N: scalar): scalar {
	    return N * 0.101972
	},
		// toBase converts kgf to N
	function toBase (kgf: scalar): scalar {
	    return kgf * 9.80665
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

ForceUnitType.base = NewtonsForceUnit
ForceUnitType.units = [NewtonsForceUnit,PoundsForceForceUnit,KilogramsForceForceUnit]

// Length (UnitType)
// Contains 3 units:
//  - MetersLength m => m            = m
//  - FeetLength   m => m * 3.280,84 = ft
//  - InchesLength m => m * 39.370,1 = in
// Base: MetersLength

export const LengthUnitType = new UnitType(
	// title
	'Length',
	// name
	'Length',
	// unitList
	["Meters","Feet","Inches"],
	// matchList
	["l","length"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// MetersLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m

export const MetersLengthUnit = new Unit(
	// title
	'Meters',
	// name
	'Meters',
	// symbol
	'm',
	// matchList
	["m","meter","meters"],
	// type
	LengthUnitType,
	// base
	null,
		// fromBase converts m to m
	function fromBase (m: scalar): scalar {
	    return m
	},
		// toBase converts m to m
	function toBase (m: scalar): scalar {
	    return m
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// FeetLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m

export const FeetLengthUnit = new Unit(
	// title
	'Feet',
	// name
	'Feet',
	// symbol
	'ft',
	// matchList
	["ft","foot","feet"],
	// type
	LengthUnitType,
	// base
	MetersLengthUnit,
		// fromBase converts m to ft
	function fromBase (m: scalar): scalar {
	    return m * 3.28084
	},
		// toBase converts ft to m
	function toBase (ft: scalar): scalar {
	    return ft * 0.304800
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// InchesLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m

export const InchesLengthUnit = new Unit(
	// title
	'Inches',
	// name
	'Inches',
	// symbol
	'in',
	// matchList
	["in","inch","inches"],
	// type
	LengthUnitType,
	// base
	MetersLengthUnit,
		// fromBase converts m to in
	function fromBase (m: scalar): scalar {
	    return m * 39.3701
	},
		// toBase converts in to m
	function toBase (inch: scalar): scalar {
	    return inch
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

LengthUnitType.base = MetersLengthUnit
LengthUnitType.units = [MetersLengthUnit,FeetLengthUnit,InchesLengthUnit]

// StrokeRate (UnitType)
// Contains 1 units:
//  - StrokesPerSecondStrokeRate ss => ss = strokes/s
// Base: StrokesPerSecondStrokeRate

export const StrokeRateUnitType = new UnitType(
	// title
	'StrokeRate',
	// name
	'Stroke Rate',
	// unitList
	["Strokes per Second"],
	// matchList
	["strokerate","stroke-rate"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// StrokesPerSecondStrokeRate (Unit)
// UnitType     : StrokeRate
// UnitType.Base: StrokesPerSecondStrokeRate
// Unit.FromBase: ss => ss = strokes/s
// Unit.ToBase  : ss => ss = strokes/s

export const StrokesPerSecondStrokeRateUnit = new Unit(
	// title
	'StrokesPerSecond',
	// name
	'Strokes per Second',
	// symbol
	'strokes/s',
	// matchList
	["strokes/s","strokespersecond","s/s"],
	// type
	StrokeRateUnitType,
	// base
	null,
		// fromBase converts strokes/s to strokes/s
	function fromBase (ss: scalar): scalar {
	    return ss
	},
		// toBase converts strokes/s to strokes/s
	function toBase (ss: scalar): scalar {
	    return ss
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

StrokeRateUnitType.base = StrokesPerSecondStrokeRateUnit
StrokeRateUnitType.units = [StrokesPerSecondStrokeRateUnit]

// Overspeed (UnitType)
// Contains 1 units:
//  - NumberOverspeed n => n = 
// Base: NumberOverspeed

export const OverspeedUnitType = new UnitType(
	// title
	'Overspeed',
	// name
	'Overspeed',
	// unitList
	["Number"],
	// matchList
	["overspeed"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// NumberOverspeed (Unit)
// UnitType     : Overspeed
// UnitType.Base: NumberOverspeed
// Unit.FromBase: n => n = 
// Unit.ToBase  : n => n = 

export const NumberOverspeedUnit = new Unit(
	// title
	'Number',
	// name
	'Number',
	// symbol
	'',
	// matchList
	["number","*"],
	// type
	OverspeedUnitType,
	// base
	null,
		// fromBase converts  to 
	function fromBase (n: scalar): scalar {
	    return n
	},
		// toBase converts  to 
	function toBase (n: scalar): scalar {
	    return n
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

OverspeedUnitType.base = NumberOverspeedUnit
OverspeedUnitType.units = [NumberOverspeedUnit]

// Underspeed (UnitType)
// Contains 1 units:
//  - NumberUnderspeed n => n = 
// Base: NumberUnderspeed

export const UnderspeedUnitType = new UnitType(
	// title
	'Underspeed',
	// name
	'Underspeed',
	// unitList
	["Number"],
	// matchList
	["underspeed"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// NumberUnderspeed (Unit)
// UnitType     : Underspeed
// UnitType.Base: NumberUnderspeed
// Unit.FromBase: n => n = 
// Unit.ToBase  : n => n = 

export const NumberUnderspeedUnit = new Unit(
	// title
	'Number',
	// name
	'Number',
	// symbol
	'',
	// matchList
	["number","*"],
	// type
	UnderspeedUnitType,
	// base
	null,
		// fromBase converts  to 
	function fromBase (n: scalar): scalar {
	    return n
	},
		// toBase converts  to 
	function toBase (n: scalar): scalar {
	    return n
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

UnderspeedUnitType.base = NumberUnderspeedUnit
UnderspeedUnitType.units = [NumberUnderspeedUnit]

// Totaliser (UnitType)
// Contains 1 units:
//  - NumberTotaliser n => n = 
// Base: NumberTotaliser

export const TotaliserUnitType = new UnitType(
	// title
	'Totaliser',
	// name
	'Totaliser',
	// unitList
	["Number"],
	// matchList
	["totaliser"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// NumberTotaliser (Unit)
// UnitType     : Totaliser
// UnitType.Base: NumberTotaliser
// Unit.FromBase: n => n = 
// Unit.ToBase  : n => n = 

export const NumberTotaliserUnit = new Unit(
	// title
	'Number',
	// name
	'Number',
	// symbol
	'',
	// matchList
	["number","*"],
	// type
	TotaliserUnitType,
	// base
	null,
		// fromBase converts  to 
	function fromBase (n: scalar): scalar {
	    return n
	},
		// toBase converts  to 
	function toBase (n: scalar): scalar {
	    return n
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

TotaliserUnitType.base = NumberTotaliserUnit
TotaliserUnitType.units = [NumberTotaliserUnit]

// WMLFlowRate (UnitType)
// Contains 1 units:
//  - NumberWMLFlowRate n => n = 
// Base: NumberWMLFlowRate

export const WMLFlowRateUnitType = new UnitType(
	// title
	'WMLFlowRate',
	// name
	'WML Flow Rate',
	// unitList
	["Number"],
	// matchList
	["wmlflowrate"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// NumberWMLFlowRate (Unit)
// UnitType     : WMLFlowRate
// UnitType.Base: NumberWMLFlowRate
// Unit.FromBase: n => n = 
// Unit.ToBase  : n => n = 

export const NumberWMLFlowRateUnit = new Unit(
	// title
	'Number',
	// name
	'Number',
	// symbol
	'',
	// matchList
	["number","*"],
	// type
	WMLFlowRateUnitType,
	// base
	null,
		// fromBase converts  to 
	function fromBase (n: scalar): scalar {
	    return n
	},
		// toBase converts  to 
	function toBase (n: scalar): scalar {
	    return n
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

WMLFlowRateUnitType.base = NumberWMLFlowRateUnit
WMLFlowRateUnitType.units = [NumberWMLFlowRateUnit]

// Number (UnitType)
// Contains 1 units:
//  - NumberNumber n => n = 
// Base: NumberNumber

export const NumberUnitType = new UnitType(
	// title
	'Number',
	// name
	'Number',
	// unitList
	["Number"],
	// matchList
	["*"],
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: UnitType, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

// NumberNumber (Unit)
// UnitType     : Number
// UnitType.Base: NumberNumber
// Unit.FromBase: n => n = 
// Unit.ToBase  : n => n = 

export const NumberNumberUnit = new Unit(
	// title
	'Number',
	// name
	'Number',
	// symbol
	'',
	// matchList
	["number","*"],
	// type
	NumberUnitType,
	// base
	null,
		// fromBase converts  to 
	function fromBase (n: scalar): scalar {
	    return n
	},
		// toBase converts  to 
	function toBase (n: scalar): scalar {
	    return n
	},
		// matcher returns true if check matches our possible names.
	// Helpful when a user is allowed to enter in unit types
	// freehand, for example.
	function matcher (this: Unit, check: string): boolean {
	    check = sanitizeString(check)
	    for (const m of this.matchList) {
	    	if (m === check || m === '*') return true
	    }
	    return false
	}
)

NumberUnitType.base = NumberNumberUnit
NumberUnitType.units = [NumberNumberUnit]