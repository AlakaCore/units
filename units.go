package units

// File autogenerated on 2022-02-10 14:51:08.420225129 -0600 CST m=+0.000675880.
// Do not edit directly

// Unit represents a scalar type of unit which can be converted to and from a base
type Unit interface {
	// Title is used for code interfaces
	Title() string
	// Name is used for displays
	Name() string
	// Symbol is the symbol of the unit and can be displayed beside scalars
	Symbol() string
	// FromBase converts the given number of the unit type base to this unit
	FromBase(float64) float64
	// ToBase converts the given number of this unit type to the base unit
	ToBase(float64) float64
	// MatchList is a list of matching strings which should represent this unit in userland
	MatchList() []string
	// Matches compares a string to a switch of all possible matches
	Matches(string) bool
	// TypeOf returns the UnitType of this unit. You can access the BaseUnit from there
	TypeOf() UnitType
	// Base returns the base Unit of this UnitType directly
	Base() Unit
}

// UnitType represents a collection of related units
type UnitType interface {
	// Title is used for code interfaces
	Title() string
	// Name is used for displays
	Name() string
	// Base returns the primary unit of this unit type that is stored in Alaka.
	// Most of the time this is an SI unit, but not always (temperature is C,
	// not K, for example)
	Base() Unit
	// Units returns all of the supported units of this unit type
	Units() []Unit
	// UnitList returns all of the supported units of this unit type as strings
	UnitList() []string
	// MatchList is a list of matching strings which should represent this unit type in userland
	MatchList() []string
	// Matches compares a string to a switch of all possible matches
	Matches(string) bool
}

var UnitMap = make(map[string]Unit)
var TypeMap = make(map[string]UnitType)

// GetType returns the unit type which matches input or NumberUnitType
func GetType(input string) UnitType {
	switch input {
	case "pressure":
		return PressureUnitType
	case "temperature":
		return TemperatureUnitType
	case "temp":
		return TemperatureUnitType
	case "flow":
		return FlowUnitType
	case "flowrate":
		return FlowUnitType
	case "flow_rate":
		return FlowUnitType
	case "gasflow":
		return FlowUnitType
	case "gasflowrate":
		return FlowUnitType
	case "gas_flow":
		return FlowUnitType
	case "gas_flow_rate":
		return FlowUnitType
	case "volume":
		return VolumeUnitType
	case "electricpotential":
		return ElectricPotentialUnitType
	case "voltage":
		return ElectricPotentialUnitType
	case "humidity":
		return HumidityUnitType
	case "percentage":
		return PercentageUnitType
	case "alarm":
		return AlarmUnitType
	case "work":
		return WorkUnitType
	case "force":
		return ForceUnitType
	case "l":
		return LengthUnitType
	case "length":
		return LengthUnitType
	case "strokerate":
		return StrokeRateUnitType
	case "stroke-rate":
		return StrokeRateUnitType
	case "*":
		return NumberUnitType
	default:
		return NumberUnitType
	}
}

// GetUnit returns the unit which matches input or _NumberNumberUnit
func GetUnit(input string, typeOf UnitType) Unit {
	search := typeOf.Title() + "->" + input

	switch search {
	case "Pressure->pa":
		return PascalsPressureUnit
	case "Pressure->pascal":
		return PascalsPressureUnit
	case "Pressure->pascals":
		return PascalsPressureUnit
	case "Pressure->kpa":
		return KilopascalsPressureUnit
	case "Pressure->kilopascal":
		return KilopascalsPressureUnit
	case "Pressure->kilopascals":
		return KilopascalsPressureUnit
	case "Pressure->mpa":
		return MegapascalsPressureUnit
	case "Pressure->megapascal":
		return MegapascalsPressureUnit
	case "Pressure->megapascals":
		return MegapascalsPressureUnit
	case "Pressure->psi":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->poundspersquareinch":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->poundpersquareinch":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->inh₂o":
		return InchesOfWaterPressureUnit
	case "Pressure->inh₂0":
		return InchesOfWaterPressureUnit
	case "Pressure->inh2o":
		return InchesOfWaterPressureUnit
	case "Pressure->inh20":
		return InchesOfWaterPressureUnit
	case "Pressure->incheswater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchesofwater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchwater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchofwater":
		return InchesOfWaterPressureUnit
	case "Temperature->c":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->°c":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->celsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreesc":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreec":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreescelsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreecelsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->f":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->°f":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->fahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreesf":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreef":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreesfahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreefahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->k":
		return KelvinsTemperatureUnit
	case "Temperature->°k":
		return KelvinsTemperatureUnit
	case "Temperature->kelvin":
		return KelvinsTemperatureUnit
	case "Temperature->kelvins":
		return KelvinsTemperatureUnit
	case "Temperature->degreesk":
		return KelvinsTemperatureUnit
	case "Temperature->degreek":
		return KelvinsTemperatureUnit
	case "Temperature->degreeskelvin":
		return KelvinsTemperatureUnit
	case "Temperature->degreekelvin":
		return KelvinsTemperatureUnit
	case "Flow->m³/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m³s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m3/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m3s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m^3/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m^3s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeterspersecond":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeterpersecond":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeters/second":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeter/second":
		return CubicMetersPerSecondFlowUnit
	case "Flow->ft³/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft³s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft^3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft^3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f³/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f³s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f^3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f^3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfeetpersecond":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfootpersecond":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfeet/second":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfoot/second":
		return CubicFeetPerSecondFlowUnit
	case "Flow->mcfd":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcf/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcftd":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcft/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft³/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft³d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft^3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft^3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf³/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf³d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf^3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf^3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->thousandcubicfeetperday":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->thousandcubicfeet/day":
		return ThousandCubicFeetPerDayFlowUnit
	case "Volume->m³":
		return CubicMetersVolumeUnit
	case "Volume->m3":
		return CubicMetersVolumeUnit
	case "Volume->cubicmeter":
		return CubicMetersVolumeUnit
	case "Volume->cubicmeters":
		return CubicMetersVolumeUnit
	case "Volume->cuft":
		return CubicFeetVolumeUnit
	case "Volume->ft³":
		return CubicFeetVolumeUnit
	case "Volume->f³":
		return CubicFeetVolumeUnit
	case "Volume->cubicfoot":
		return CubicFeetVolumeUnit
	case "Volume->cubicfeet":
		return CubicFeetVolumeUnit
	case "Volume->mcf":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->mft³":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->mf³":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandcubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandsofcubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandscubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "ElectricPotential->volt":
		return VoltsElectricPotentialUnit
	case "ElectricPotential->volts":
		return VoltsElectricPotentialUnit
	case "ElectricPotential->v":
		return VoltsElectricPotentialUnit
	case "Humidity->%":
		return PercentHumidityUnit
	case "Humidity->percent":
		return PercentHumidityUnit
	case "Humidity->percentage":
		return PercentHumidityUnit
	case "Percentage->%":
		return PercentPercentageUnit
	case "Percentage->percent":
		return PercentPercentageUnit
	case "Percentage->percentage":
		return PercentPercentageUnit
	case "Alarm->%":
		return PercentAlarmUnit
	case "Alarm->percent":
		return PercentAlarmUnit
	case "Alarm->percentage":
		return PercentAlarmUnit
	case "Work->j":
		return JoulesWorkUnit
	case "Work->joule":
		return JoulesWorkUnit
	case "Work->joules":
		return JoulesWorkUnit
	case "Work->inlbf":
		return InchPoundsForceWorkUnit
	case "Work->inch-poundsforce":
		return InchPoundsForceWorkUnit
	case "Work->inch-poundforce":
		return InchPoundsForceWorkUnit
	case "Work->in-lbf":
		return InchPoundsForceWorkUnit
	case "Work->btuᵢₜ":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->btuit":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->btu":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->cubicfeetofnaturalgas":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->bboe":
		return BarrelsOfOilEquivalentWorkUnit
	case "Work->barrelsofoilequivalent":
		return BarrelsOfOilEquivalentWorkUnit
	case "Force->n":
		return NewtonsForceUnit
	case "Force->newton":
		return NewtonsForceUnit
	case "Force->newtons":
		return NewtonsForceUnit
	case "Force->lbf":
		return PoundsForceForceUnit
	case "Force->pounds-force":
		return PoundsForceForceUnit
	case "Force->poundsforce":
		return PoundsForceForceUnit
	case "Force->pound-force":
		return PoundsForceForceUnit
	case "Force->poundforce":
		return PoundsForceForceUnit
	case "Force->kgf":
		return KilogramsForceForceUnit
	case "Force->kilograms-force":
		return KilogramsForceForceUnit
	case "Force->kilogram-force":
		return KilogramsForceForceUnit
	case "Length->m":
		return MetersLengthUnit
	case "Length->meter":
		return MetersLengthUnit
	case "Length->meters":
		return MetersLengthUnit
	case "Length->ft":
		return FeetLengthUnit
	case "Length->foot":
		return FeetLengthUnit
	case "Length->feet":
		return FeetLengthUnit
	case "Length->in":
		return InchesLengthUnit
	case "Length->inch":
		return InchesLengthUnit
	case "Length->inches":
		return InchesLengthUnit
	case "StrokeRate->strokes/s":
		return StrokesPerSecondStrokeRateUnit
	case "StrokeRate->strokespersecond":
		return StrokesPerSecondStrokeRateUnit
	case "StrokeRate->s/s":
		return StrokesPerSecondStrokeRateUnit
	case "Number->number":
		return _NumberNumberUnit
	case "Number->*":
		return _NumberNumberUnit
	default:
		return _NumberNumberUnit
	}
}

// GetTypeUnit returns the unit type and unit which matches input or (NumberUnitType, _NumberNumberUnit)
func GetTypeUnit(input string) (UnitType, Unit) {
	switch input {
	case "Pressure_Pascals":
		return PressureUnitType, PascalsPressureUnit
	case "Pressure_Kilopascals":
		return PressureUnitType, KilopascalsPressureUnit
	case "Pressure_Megapascals":
		return PressureUnitType, MegapascalsPressureUnit
	case "Pressure_PoundsperSquareInch":
		return PressureUnitType, PoundsPerSquareInchPressureUnit
	case "Pressure_InchesofWater":
		return PressureUnitType, InchesOfWaterPressureUnit
	case "Temperature_DegreesCelsius":
		return TemperatureUnitType, DegreesCelsiusTemperatureUnit
	case "Temperature_DegreesFahrenheit":
		return TemperatureUnitType, DegreesFahrenheitTemperatureUnit
	case "Temperature_Kelvins":
		return TemperatureUnitType, KelvinsTemperatureUnit
	case "Flow_CubicMetersperSecond":
		return FlowUnitType, CubicMetersPerSecondFlowUnit
	case "Flow_CubicFeetPerSecond":
		return FlowUnitType, CubicFeetPerSecondFlowUnit
	case "Flow_ThousandCubicFeetperDay":
		return FlowUnitType, ThousandCubicFeetPerDayFlowUnit
	case "Volume_CubicMeters":
		return VolumeUnitType, CubicMetersVolumeUnit
	case "Volume_CubicFeet":
		return VolumeUnitType, CubicFeetVolumeUnit
	case "Volume_ThousandsofCubicFeet":
		return VolumeUnitType, ThousandsOfCubicFeetVolumeUnit
	case "ElectricPotential_Volts":
		return ElectricPotentialUnitType, VoltsElectricPotentialUnit
	case "Humidity_Percent":
		return HumidityUnitType, PercentHumidityUnit
	case "Percentage_Percent":
		return PercentageUnitType, PercentPercentageUnit
	case "Alarm_Percent":
		return AlarmUnitType, PercentAlarmUnit
	case "Work_Joules":
		return WorkUnitType, JoulesWorkUnit
	case "Work_Inch-poundsForce":
		return WorkUnitType, InchPoundsForceWorkUnit
	case "Work_CubicFeetofNaturalGas":
		return WorkUnitType, CubicFeetOfNaturalGasWorkUnit
	case "Work_BarrelsofOilEquivalent":
		return WorkUnitType, BarrelsOfOilEquivalentWorkUnit
	case "Force_Newtons":
		return ForceUnitType, NewtonsForceUnit
	case "Force_Pounds-force":
		return ForceUnitType, PoundsForceForceUnit
	case "Force_Kilograms-force":
		return ForceUnitType, KilogramsForceForceUnit
	case "Length_Meters":
		return LengthUnitType, MetersLengthUnit
	case "Length_Feet":
		return LengthUnitType, FeetLengthUnit
	case "Length_Inches":
		return LengthUnitType, InchesLengthUnit
	case "StrokeRate_StrokesperSecond":
		return StrokeRateUnitType, StrokesPerSecondStrokeRateUnit
	case "Number_Number":
		return NumberUnitType, _NumberNumberUnit
	default:
		return NumberUnitType, _NumberNumberUnit
	}
}

// Pressure (UnitType)
// Contains 5 units:
//  - PascalsPressure             Pa => Pa                 = Pa
//  - KilopascalsPressure         Pa => Pa * 0.001         = kPa
//  - MegapascalsPressure         Pa => Pa * 0.000,001     = MPa
//  - PoundsPerSquareInchPressure Pa => Pa * 0.000,145,038 = psi
//  - InchesOfWaterPressure       Pa => Pa * 0.004,014,74  = inH₂O
// Base: PascalsPressure
type Pressure struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Pressure) Name() string {
	return x.name
}

// Base gets the base field
func (x Pressure) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Pressure) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Pressure) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Pressure) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Pressure) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var PressureUnitType = Pressure{
	name:    "Pressure",
	base:    PascalsPressureUnit,
	matches: []string{"pressure"},
	units:   []Unit{PascalsPressureUnit, KilopascalsPressureUnit, MegapascalsPressureUnit, PoundsPerSquareInchPressureUnit, InchesOfWaterPressureUnit},
}

// PascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa = Pa
// Unit.ToBase  : Pa => Pa = Pa
type PascalsPressure struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x PascalsPressure) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x PascalsPressure) Symbol() string {
	return x.symbol
}

// FromBase converts Pa to Pa
func (x PascalsPressure) FromBase(Pa float64) float64 {
	return Pa
}

// ToBase converts Pa to Pa
func (x PascalsPressure) ToBase(Pa float64) float64 {
	return Pa
}

// MatchList gets the matches field
func (x PascalsPressure) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PascalsPressure) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x PascalsPressure) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x PascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var PascalsPressureUnit = PascalsPressure{
	name:     "Pascals",
	symbol:   "Pa",
	fromBase: "Pa => Pa",
	toBase:   "Pa => Pa",
	matches:  []string{"pa", "pascal", "pascals"},
	typeOf:   PressureUnitType,
}

// KilopascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.001   = kPa
// Unit.ToBase  : kPa => kPa * 1,000 = Pa
type KilopascalsPressure struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x KilopascalsPressure) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x KilopascalsPressure) Symbol() string {
	return x.symbol
}

// FromBase converts Pa to kPa
func (x KilopascalsPressure) FromBase(Pa float64) float64 {
	return Pa * 0.001
}

// ToBase converts Pa to kPa
func (x KilopascalsPressure) ToBase(kPa float64) float64 {
	return kPa * 1000
}

// MatchList gets the matches field
func (x KilopascalsPressure) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilopascalsPressure) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x KilopascalsPressure) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x KilopascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var KilopascalsPressureUnit = KilopascalsPressure{
	name:     "Kilopascals",
	symbol:   "kPa",
	fromBase: "Pa => Pa * 0.001",
	toBase:   "kPa => kPa * 1,000",
	matches:  []string{"kpa", "kilopascal", "kilopascals"},
	typeOf:   PressureUnitType,
}

// MegapascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,001   = MPa
// Unit.ToBase  : MPa => MPa * 1,000,000 = Pa
type MegapascalsPressure struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x MegapascalsPressure) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x MegapascalsPressure) Symbol() string {
	return x.symbol
}

// FromBase converts Pa to MPa
func (x MegapascalsPressure) FromBase(Pa float64) float64 {
	return Pa * 0.000001
}

// ToBase converts Pa to MPa
func (x MegapascalsPressure) ToBase(MPa float64) float64 {
	return MPa * 1000000
}

// MatchList gets the matches field
func (x MegapascalsPressure) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MegapascalsPressure) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x MegapascalsPressure) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x MegapascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var MegapascalsPressureUnit = MegapascalsPressure{
	name:     "Megapascals",
	symbol:   "MPa",
	fromBase: "Pa => Pa * 0.000,001",
	toBase:   "MPa => MPa * 1,000,000",
	matches:  []string{"mpa", "megapascal", "megapascals"},
	typeOf:   PressureUnitType,
}

// PoundsPerSquareInchPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,145,038 = psi
// Unit.ToBase  : psi => psi * 6,894.76    = Pa
type PoundsPerSquareInchPressure struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x PoundsPerSquareInchPressure) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x PoundsPerSquareInchPressure) Symbol() string {
	return x.symbol
}

// FromBase converts Pa to psi
func (x PoundsPerSquareInchPressure) FromBase(Pa float64) float64 {
	return Pa * 0.000145038
}

// ToBase converts Pa to psi
func (x PoundsPerSquareInchPressure) ToBase(psi float64) float64 {
	return psi * 6894.76
}

// MatchList gets the matches field
func (x PoundsPerSquareInchPressure) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsPerSquareInchPressure) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x PoundsPerSquareInchPressure) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x PoundsPerSquareInchPressure) Base() Unit {
	return PascalsPressureUnit
}

var PoundsPerSquareInchPressureUnit = PoundsPerSquareInchPressure{
	name:     "Pounds per Square Inch",
	symbol:   "psi",
	fromBase: "Pa => Pa * 0.000,145,038",
	toBase:   "psi => psi * 6,894.76",
	matches:  []string{"psi", "poundspersquareinch", "poundpersquareinch"},
	typeOf:   PressureUnitType,
}

// InchesOfWaterPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.004,014,74  = inH₂O
// Unit.ToBase  : inH2O => inH2O * 249.082 = Pa
type InchesOfWaterPressure struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x InchesOfWaterPressure) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x InchesOfWaterPressure) Symbol() string {
	return x.symbol
}

// FromBase converts Pa to inH₂O
func (x InchesOfWaterPressure) FromBase(Pa float64) float64 {
	return Pa * 0.00401474
}

// ToBase converts Pa to inH₂O
func (x InchesOfWaterPressure) ToBase(inH2O float64) float64 {
	return inH2O * 249.082
}

// MatchList gets the matches field
func (x InchesOfWaterPressure) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesOfWaterPressure) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x InchesOfWaterPressure) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x InchesOfWaterPressure) Base() Unit {
	return PascalsPressureUnit
}

var InchesOfWaterPressureUnit = InchesOfWaterPressure{
	name:     "Inches of Water",
	symbol:   "inH₂O",
	fromBase: "Pa => Pa * 0.004,014,74",
	toBase:   "inH2O => inH2O * 249.082",
	matches:  []string{"inh₂o", "inh₂0", "inh2o", "inh20", "incheswater", "inchesofwater", "inchwater", "inchofwater"},
	typeOf:   PressureUnitType,
}

// Temperature (UnitType)
// Contains 3 units:
//  - DegreesCelsiusTemperature    C => C                  = °C
//  - DegreesFahrenheitTemperature C => (C * (9 / 5)) + 32 = °F
//  - KelvinsTemperature           C => C + 273.15         = K
// Base: DegreesCelsiusTemperature
type Temperature struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Temperature) Name() string {
	return x.name
}

// Base gets the base field
func (x Temperature) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Temperature) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Temperature) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Temperature) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Temperature) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var TemperatureUnitType = Temperature{
	name:    "Temperature",
	base:    DegreesCelsiusTemperatureUnit,
	matches: []string{"temperature", "temp"},
	units:   []Unit{DegreesCelsiusTemperatureUnit, DegreesFahrenheitTemperatureUnit, KelvinsTemperatureUnit},
}

// DegreesCelsiusTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C = °C
// Unit.ToBase  : C => C = °C
type DegreesCelsiusTemperature struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Temperature
}

// Name gets the name field
func (x DegreesCelsiusTemperature) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x DegreesCelsiusTemperature) Symbol() string {
	return x.symbol
}

// FromBase converts °C to °C
func (x DegreesCelsiusTemperature) FromBase(C float64) float64 {
	return C
}

// ToBase converts °C to °C
func (x DegreesCelsiusTemperature) ToBase(C float64) float64 {
	return C
}

// MatchList gets the matches field
func (x DegreesCelsiusTemperature) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesCelsiusTemperature) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x DegreesCelsiusTemperature) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x DegreesCelsiusTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var DegreesCelsiusTemperatureUnit = DegreesCelsiusTemperature{
	name:     "Degrees Celsius",
	symbol:   "°C",
	fromBase: "C => C",
	toBase:   "C => C",
	matches:  []string{"c", "°c", "celsius", "degreesc", "degreec", "degreescelsius", "degreecelsius"},
	typeOf:   TemperatureUnitType,
}

// DegreesFahrenheitTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => (C * (9 / 5)) + 32 = °F
// Unit.ToBase  : F => (F - 32) * (5 / 9) = °C
type DegreesFahrenheitTemperature struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Temperature
}

// Name gets the name field
func (x DegreesFahrenheitTemperature) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x DegreesFahrenheitTemperature) Symbol() string {
	return x.symbol
}

// FromBase converts °C to °F
func (x DegreesFahrenheitTemperature) FromBase(C float64) float64 {
	return (C * (9 / 5)) + 32
}

// ToBase converts °C to °F
func (x DegreesFahrenheitTemperature) ToBase(F float64) float64 {
	return (F - 32) * (5 / 9)
}

// MatchList gets the matches field
func (x DegreesFahrenheitTemperature) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesFahrenheitTemperature) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x DegreesFahrenheitTemperature) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x DegreesFahrenheitTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var DegreesFahrenheitTemperatureUnit = DegreesFahrenheitTemperature{
	name:     "Degrees Fahrenheit",
	symbol:   "°F",
	fromBase: "C => (C * (9 / 5)) + 32",
	toBase:   "F => (F - 32) * (5 / 9)",
	matches:  []string{"f", "°f", "fahrenheit", "degreesf", "degreef", "degreesfahrenheit", "degreefahrenheit"},
	typeOf:   TemperatureUnitType,
}

// KelvinsTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C + 273.15 = K
// Unit.ToBase  : K => K - 273.15 = °C
type KelvinsTemperature struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Temperature
}

// Name gets the name field
func (x KelvinsTemperature) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x KelvinsTemperature) Symbol() string {
	return x.symbol
}

// FromBase converts °C to K
func (x KelvinsTemperature) FromBase(C float64) float64 {
	return C + 273.15
}

// ToBase converts °C to K
func (x KelvinsTemperature) ToBase(K float64) float64 {
	return K - 273.15
}

// MatchList gets the matches field
func (x KelvinsTemperature) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KelvinsTemperature) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x KelvinsTemperature) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x KelvinsTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var KelvinsTemperatureUnit = KelvinsTemperature{
	name:     "Kelvins",
	symbol:   "K",
	fromBase: "C => C + 273.15",
	toBase:   "K => K - 273.15",
	matches:  []string{"k", "°k", "kelvin", "kelvins", "degreesk", "degreek", "degreeskelvin", "degreekelvin"},
	typeOf:   TemperatureUnitType,
}

// Flow (UnitType)
// Contains 3 units:
//  - CubicMetersPerSecondFlow    m3s => m3s            = m³/s
//  - CubicFeetPerSecondFlow      m3s => m3s * 35.314,7 = ft³/s
//  - ThousandCubicFeetPerDayFlow m3s => m3s * 3,051.19 = MCFD
// Base: CubicMetersPerSecondFlow
type Flow struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Flow) Name() string {
	return x.name
}

// Base gets the base field
func (x Flow) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Flow) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Flow) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Flow) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Flow) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var FlowUnitType = Flow{
	name:    "Flow",
	base:    CubicMetersPerSecondFlowUnit,
	matches: []string{"flow", "flowrate", "flow_rate", "gasflow", "gasflowrate", "gas_flow", "gas_flow_rate"},
	units:   []Unit{CubicMetersPerSecondFlowUnit, CubicFeetPerSecondFlowUnit, ThousandCubicFeetPerDayFlowUnit},
}

// CubicMetersPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s = m³/s
// Unit.ToBase  : m3s => m3s = m³/s
type CubicMetersPerSecondFlow struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Flow
}

// Name gets the name field
func (x CubicMetersPerSecondFlow) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x CubicMetersPerSecondFlow) Symbol() string {
	return x.symbol
}

// FromBase converts m³/s to m³/s
func (x CubicMetersPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s
}

// ToBase converts m³/s to m³/s
func (x CubicMetersPerSecondFlow) ToBase(m3s float64) float64 {
	return m3s
}

// MatchList gets the matches field
func (x CubicMetersPerSecondFlow) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMetersPerSecondFlow) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x CubicMetersPerSecondFlow) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x CubicMetersPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var CubicMetersPerSecondFlowUnit = CubicMetersPerSecondFlow{
	name:     "Cubic Meters per Second",
	symbol:   "m³/s",
	fromBase: "m3s => m3s",
	toBase:   "m3s => m3s",
	matches:  []string{"m³/s", "m³s", "m3/s", "m3s", "m^3/s", "m^3s", "cubicmeterspersecond", "cubicmeterpersecond", "cubicmeters/second", "cubicmeter/second"},
	typeOf:   FlowUnitType,
}

// CubicFeetPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 35.314,7      = ft³/s
// Unit.ToBase  : ft3s => ft3s * 0.028,316,8 = m³/s
type CubicFeetPerSecondFlow struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Flow
}

// Name gets the name field
func (x CubicFeetPerSecondFlow) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x CubicFeetPerSecondFlow) Symbol() string {
	return x.symbol
}

// FromBase converts m³/s to ft³/s
func (x CubicFeetPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s * 35.3147
}

// ToBase converts m³/s to ft³/s
func (x CubicFeetPerSecondFlow) ToBase(ft3s float64) float64 {
	return ft3s * 0.0283168
}

// MatchList gets the matches field
func (x CubicFeetPerSecondFlow) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetPerSecondFlow) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x CubicFeetPerSecondFlow) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x CubicFeetPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var CubicFeetPerSecondFlowUnit = CubicFeetPerSecondFlow{
	name:     "CubicFeetPerSecond",
	symbol:   "ft³/s",
	fromBase: "m3s => m3s * 35.314,7",
	toBase:   "ft3s => ft3s * 0.028,316,8",
	matches:  []string{"ft³/s", "ft³s", "ft3/s", "ft3s", "ft^3/s", "ft^3s", "f³/s", "f³s", "f3/s", "f3s", "f^3/s", "f^3s", "cubicfeetpersecond", "cubicfootpersecond", "cubicfeet/second", "cubicfoot/second"},
	typeOf:   FlowUnitType,
}

// ThousandCubicFeetPerDayFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 3,051.19        = MCFD
// Unit.ToBase  : MCFD => MCFD * 0.000,327,741 = m³/s
type ThousandCubicFeetPerDayFlow struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Flow
}

// Name gets the name field
func (x ThousandCubicFeetPerDayFlow) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x ThousandCubicFeetPerDayFlow) Symbol() string {
	return x.symbol
}

// FromBase converts m³/s to MCFD
func (x ThousandCubicFeetPerDayFlow) FromBase(m3s float64) float64 {
	return m3s * 3051.19
}

// ToBase converts m³/s to MCFD
func (x ThousandCubicFeetPerDayFlow) ToBase(MCFD float64) float64 {
	return MCFD * 0.000327741
}

// MatchList gets the matches field
func (x ThousandCubicFeetPerDayFlow) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandCubicFeetPerDayFlow) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x ThousandCubicFeetPerDayFlow) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x ThousandCubicFeetPerDayFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var ThousandCubicFeetPerDayFlowUnit = ThousandCubicFeetPerDayFlow{
	name:     "Thousand Cubic Feet per Day",
	symbol:   "MCFD",
	fromBase: "m3s => m3s * 3,051.19",
	toBase:   "MCFD => MCFD * 0.000,327,741",
	matches:  []string{"mcfd", "mcf/d", "mcftd", "mcft/d", "mft³/d", "mft³d", "mft3/d", "mft3d", "mft^3/d", "mft^3d", "mf³/d", "mf³d", "mf3/d", "mf3d", "mf^3/d", "mf^3d", "thousandcubicfeetperday", "thousandcubicfeet/day"},
	typeOf:   FlowUnitType,
}

// Volume (UnitType)
// Contains 3 units:
//  - CubicMetersVolume          m3 => m3               = m³
//  - CubicFeetVolume            m3 => m3 * 35.314,7    = cu ft
//  - ThousandsOfCubicFeetVolume m3 => m3 * 0.035,314,7 = MCF
// Base: CubicMetersVolume
type Volume struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Volume) Name() string {
	return x.name
}

// Base gets the base field
func (x Volume) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Volume) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Volume) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Volume) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Volume) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var VolumeUnitType = Volume{
	name:    "Volume",
	base:    CubicMetersVolumeUnit,
	matches: []string{"volume"},
	units:   []Unit{CubicMetersVolumeUnit, CubicFeetVolumeUnit, ThousandsOfCubicFeetVolumeUnit},
}

// CubicMetersVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 = m³
// Unit.ToBase  : m3 => m3 = m³
type CubicMetersVolume struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Volume
}

// Name gets the name field
func (x CubicMetersVolume) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x CubicMetersVolume) Symbol() string {
	return x.symbol
}

// FromBase converts m³ to m³
func (x CubicMetersVolume) FromBase(m3 float64) float64 {
	return m3
}

// ToBase converts m³ to m³
func (x CubicMetersVolume) ToBase(m3 float64) float64 {
	return m3
}

// MatchList gets the matches field
func (x CubicMetersVolume) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMetersVolume) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x CubicMetersVolume) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x CubicMetersVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var CubicMetersVolumeUnit = CubicMetersVolume{
	name:     "Cubic Meters",
	symbol:   "m³",
	fromBase: "m3 => m3",
	toBase:   "m3 => m3",
	matches:  []string{"m³", "m3", "cubicmeter", "cubicmeters"},
	typeOf:   VolumeUnitType,
}

// CubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 35.314,7        = cu ft
// Unit.ToBase  : cuft => cuft * 0.028,316,8 = m³
type CubicFeetVolume struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Volume
}

// Name gets the name field
func (x CubicFeetVolume) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x CubicFeetVolume) Symbol() string {
	return x.symbol
}

// FromBase converts m³ to cu ft
func (x CubicFeetVolume) FromBase(m3 float64) float64 {
	return m3 * 35.3147
}

// ToBase converts m³ to cu ft
func (x CubicFeetVolume) ToBase(cuft float64) float64 {
	return cuft * 0.0283168
}

// MatchList gets the matches field
func (x CubicFeetVolume) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetVolume) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x CubicFeetVolume) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x CubicFeetVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var CubicFeetVolumeUnit = CubicFeetVolume{
	name:     "Cubic Feet",
	symbol:   "cu ft",
	fromBase: "m3 => m3 * 35.314,7",
	toBase:   "cuft => cuft * 0.028,316,8",
	matches:  []string{"cuft", "ft³", "f³", "cubicfoot", "cubicfeet"},
	typeOf:   VolumeUnitType,
}

// ThousandsOfCubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 0.035,314,7 = MCF
// Unit.ToBase  : MCF => MCF * 28.316,8  = m³
type ThousandsOfCubicFeetVolume struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Volume
}

// Name gets the name field
func (x ThousandsOfCubicFeetVolume) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x ThousandsOfCubicFeetVolume) Symbol() string {
	return x.symbol
}

// FromBase converts m³ to MCF
func (x ThousandsOfCubicFeetVolume) FromBase(m3 float64) float64 {
	return m3 * 0.0353147
}

// ToBase converts m³ to MCF
func (x ThousandsOfCubicFeetVolume) ToBase(MCF float64) float64 {
	return MCF * 28.3168
}

// MatchList gets the matches field
func (x ThousandsOfCubicFeetVolume) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandsOfCubicFeetVolume) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x ThousandsOfCubicFeetVolume) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x ThousandsOfCubicFeetVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var ThousandsOfCubicFeetVolumeUnit = ThousandsOfCubicFeetVolume{
	name:     "Thousands of Cubic Feet",
	symbol:   "MCF",
	fromBase: "m3 => m3 * 0.035,314,7",
	toBase:   "MCF => MCF * 28.316,8",
	matches:  []string{"mcf", "mft³", "mf³", "thousandcubicfeet", "thousandsofcubicfeet", "thousandscubicfeet"},
	typeOf:   VolumeUnitType,
}

// ElectricPotential (UnitType)
// Contains 1 units:
//  - VoltsElectricPotential V => V = V
// Base: VoltsElectricPotential
type ElectricPotential struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x ElectricPotential) Name() string {
	return x.name
}

// Base gets the base field
func (x ElectricPotential) Base() Unit {
	return x.base
}

// Units gets the units field
func (x ElectricPotential) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x ElectricPotential) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x ElectricPotential) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotential) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ElectricPotentialUnitType = ElectricPotential{
	name:    "Electric Potential",
	base:    VoltsElectricPotentialUnit,
	matches: []string{"electricpotential", "voltage"},
	units:   []Unit{VoltsElectricPotentialUnit},
}

// VoltsElectricPotential (Unit)
// UnitType     : ElectricPotential
// UnitType.Base: VoltsElectricPotential
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type VoltsElectricPotential struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   ElectricPotential
}

// Name gets the name field
func (x VoltsElectricPotential) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x VoltsElectricPotential) Symbol() string {
	return x.symbol
}

// FromBase converts V to V
func (x VoltsElectricPotential) FromBase(V float64) float64 {
	return V
}

// ToBase converts V to V
func (x VoltsElectricPotential) ToBase(V float64) float64 {
	return V
}

// MatchList gets the matches field
func (x VoltsElectricPotential) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x VoltsElectricPotential) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x VoltsElectricPotential) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x VoltsElectricPotential) Base() Unit {
	return VoltsElectricPotentialUnit
}

var VoltsElectricPotentialUnit = VoltsElectricPotential{
	name:     "Volts",
	symbol:   "V",
	fromBase: "V => V",
	toBase:   "V => V",
	matches:  []string{"volt", "volts", "v"},
	typeOf:   ElectricPotentialUnitType,
}

// Humidity (UnitType)
// Contains 1 units:
//  - PercentHumidity p => p = %
// Base: PercentHumidity
type Humidity struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Humidity) Name() string {
	return x.name
}

// Base gets the base field
func (x Humidity) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Humidity) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Humidity) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Humidity) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Humidity) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var HumidityUnitType = Humidity{
	name:    "Humidity",
	base:    PercentHumidityUnit,
	matches: []string{"humidity"},
	units:   []Unit{PercentHumidityUnit},
}

// PercentHumidity (Unit)
// UnitType     : Humidity
// UnitType.Base: PercentHumidity
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentHumidity struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Humidity
}

// Name gets the name field
func (x PercentHumidity) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x PercentHumidity) Symbol() string {
	return x.symbol
}

// FromBase converts % to %
func (x PercentHumidity) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentHumidity) ToBase(p float64) float64 {
	return p
}

// MatchList gets the matches field
func (x PercentHumidity) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentHumidity) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x PercentHumidity) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x PercentHumidity) Base() Unit {
	return PercentHumidityUnit
}

var PercentHumidityUnit = PercentHumidity{
	name:     "Percent",
	symbol:   "%",
	fromBase: "p => p",
	toBase:   "p => p",
	matches:  []string{"%", "percent", "percentage"},
	typeOf:   HumidityUnitType,
}

// Percentage (UnitType)
// Contains 1 units:
//  - PercentPercentage p => p = %
// Base: PercentPercentage
type Percentage struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Percentage) Name() string {
	return x.name
}

// Base gets the base field
func (x Percentage) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Percentage) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Percentage) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Percentage) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Percentage) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var PercentageUnitType = Percentage{
	name:    "Percentage",
	base:    PercentPercentageUnit,
	matches: []string{"percentage"},
	units:   []Unit{PercentPercentageUnit},
}

// PercentPercentage (Unit)
// UnitType     : Percentage
// UnitType.Base: PercentPercentage
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentPercentage struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Percentage
}

// Name gets the name field
func (x PercentPercentage) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x PercentPercentage) Symbol() string {
	return x.symbol
}

// FromBase converts % to %
func (x PercentPercentage) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentPercentage) ToBase(p float64) float64 {
	return p
}

// MatchList gets the matches field
func (x PercentPercentage) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentPercentage) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x PercentPercentage) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x PercentPercentage) Base() Unit {
	return PercentPercentageUnit
}

var PercentPercentageUnit = PercentPercentage{
	name:     "Percent",
	symbol:   "%",
	fromBase: "p => p",
	toBase:   "p => p",
	matches:  []string{"%", "percent", "percentage"},
	typeOf:   PercentageUnitType,
}

// Alarm (UnitType)
// Contains 1 units:
//  - PercentAlarm p => p = %
// Base: PercentAlarm
type Alarm struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Alarm) Name() string {
	return x.name
}

// Base gets the base field
func (x Alarm) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Alarm) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Alarm) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Alarm) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Alarm) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var AlarmUnitType = Alarm{
	name:    "Alarm",
	base:    PercentAlarmUnit,
	matches: []string{"alarm"},
	units:   []Unit{PercentAlarmUnit},
}

// PercentAlarm (Unit)
// UnitType     : Alarm
// UnitType.Base: PercentAlarm
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentAlarm struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Alarm
}

// Name gets the name field
func (x PercentAlarm) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x PercentAlarm) Symbol() string {
	return x.symbol
}

// FromBase converts % to %
func (x PercentAlarm) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentAlarm) ToBase(p float64) float64 {
	return p
}

// MatchList gets the matches field
func (x PercentAlarm) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentAlarm) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x PercentAlarm) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x PercentAlarm) Base() Unit {
	return PercentAlarmUnit
}

var PercentAlarmUnit = PercentAlarm{
	name:     "Percent",
	symbol:   "%",
	fromBase: "p => p",
	toBase:   "p => p",
	matches:  []string{"%", "percent", "percentage"},
	typeOf:   AlarmUnitType,
}

// Work (UnitType)
// Contains 4 units:
//  - JoulesWork                 J => J                         = J
//  - InchPoundsForceWork        J => J * 8.850,74              = in lbf
//  - CubicFeetOfNaturalGasWork  J => J * 0.000,000,947,817     = BTUᵢₜ
//  - BarrelsOfOilEquivalentWork J => J * 0.000,000,000,163,399 = bboe
// Base: JoulesWork
type Work struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Work) Name() string {
	return x.name
}

// Base gets the base field
func (x Work) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Work) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Work) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Work) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Work) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var WorkUnitType = Work{
	name:    "Work",
	base:    JoulesWorkUnit,
	matches: []string{"work"},
	units:   []Unit{JoulesWorkUnit, InchPoundsForceWorkUnit, CubicFeetOfNaturalGasWorkUnit, BarrelsOfOilEquivalentWorkUnit},
}

// JoulesWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J = J
// Unit.ToBase  : J => J = J
type JoulesWork struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x JoulesWork) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x JoulesWork) Symbol() string {
	return x.symbol
}

// FromBase converts J to J
func (x JoulesWork) FromBase(J float64) float64 {
	return J
}

// ToBase converts J to J
func (x JoulesWork) ToBase(J float64) float64 {
	return J
}

// MatchList gets the matches field
func (x JoulesWork) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x JoulesWork) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x JoulesWork) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x JoulesWork) Base() Unit {
	return JoulesWorkUnit
}

var JoulesWorkUnit = JoulesWork{
	name:     "Joules",
	symbol:   "J",
	fromBase: "J => J",
	toBase:   "J => J",
	matches:  []string{"j", "joule", "joules"},
	typeOf:   WorkUnitType,
}

// InchPoundsForceWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 8.850,74          = in lbf
// Unit.ToBase  : inlbf => inlbf * 0.112,985 = J
type InchPoundsForceWork struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x InchPoundsForceWork) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x InchPoundsForceWork) Symbol() string {
	return x.symbol
}

// FromBase converts J to in lbf
func (x InchPoundsForceWork) FromBase(J float64) float64 {
	return J * 8.85074
}

// ToBase converts J to in lbf
func (x InchPoundsForceWork) ToBase(inlbf float64) float64 {
	return inlbf * 0.112985
}

// MatchList gets the matches field
func (x InchPoundsForceWork) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchPoundsForceWork) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x InchPoundsForceWork) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x InchPoundsForceWork) Base() Unit {
	return JoulesWorkUnit
}

var InchPoundsForceWorkUnit = InchPoundsForceWork{
	name:     "Inch-pounds Force",
	symbol:   "in lbf",
	fromBase: "J => J * 8.850,74",
	toBase:   "inlbf => inlbf * 0.112,985",
	matches:  []string{"inlbf", "inch-poundsforce", "inch-poundforce", "in-lbf"},
	typeOf:   WorkUnitType,
}

// CubicFeetOfNaturalGasWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,947,817 = BTUᵢₜ
// Unit.ToBase  : btu => btu * 1,055,060     = J
type CubicFeetOfNaturalGasWork struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x CubicFeetOfNaturalGasWork) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x CubicFeetOfNaturalGasWork) Symbol() string {
	return x.symbol
}

// FromBase converts J to BTUᵢₜ
func (x CubicFeetOfNaturalGasWork) FromBase(J float64) float64 {
	return J * 0.000000947817
}

// ToBase converts J to BTUᵢₜ
func (x CubicFeetOfNaturalGasWork) ToBase(btu float64) float64 {
	return btu * 1055060
}

// MatchList gets the matches field
func (x CubicFeetOfNaturalGasWork) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetOfNaturalGasWork) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x CubicFeetOfNaturalGasWork) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x CubicFeetOfNaturalGasWork) Base() Unit {
	return JoulesWorkUnit
}

var CubicFeetOfNaturalGasWorkUnit = CubicFeetOfNaturalGasWork{
	name:     "Cubic Feet of Natural Gas",
	symbol:   "BTUᵢₜ",
	fromBase: "J => J * 0.000,000,947,817",
	toBase:   "btu => btu * 1,055,060",
	matches:  []string{"btuᵢₜ", "btuit", "btu", "cubicfeetofnaturalgas"},
	typeOf:   WorkUnitType,
}

// BarrelsOfOilEquivalentWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,000,163,399 = bboe
// Unit.ToBase  : bboe => bboe * 6,120,000,000   = J
type BarrelsOfOilEquivalentWork struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x BarrelsOfOilEquivalentWork) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x BarrelsOfOilEquivalentWork) Symbol() string {
	return x.symbol
}

// FromBase converts J to bboe
func (x BarrelsOfOilEquivalentWork) FromBase(J float64) float64 {
	return J * 0.000000000163399
}

// ToBase converts J to bboe
func (x BarrelsOfOilEquivalentWork) ToBase(bboe float64) float64 {
	return bboe * 6120000000
}

// MatchList gets the matches field
func (x BarrelsOfOilEquivalentWork) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x BarrelsOfOilEquivalentWork) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x BarrelsOfOilEquivalentWork) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x BarrelsOfOilEquivalentWork) Base() Unit {
	return JoulesWorkUnit
}

var BarrelsOfOilEquivalentWorkUnit = BarrelsOfOilEquivalentWork{
	name:     "Barrels of Oil Equivalent",
	symbol:   "bboe",
	fromBase: "J => J * 0.000,000,000,163,399",
	toBase:   "bboe => bboe * 6,120,000,000",
	matches:  []string{"bboe", "barrelsofoilequivalent"},
	typeOf:   WorkUnitType,
}

// Force (UnitType)
// Contains 3 units:
//  - NewtonsForce        N => N             = N
//  - PoundsForceForce    N => N * 0.224,809 = lbf
//  - KilogramsForceForce N => N * 0.101,972 = kgf
// Base: NewtonsForce
type Force struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Force) Name() string {
	return x.name
}

// Base gets the base field
func (x Force) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Force) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Force) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Force) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Force) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ForceUnitType = Force{
	name:    "Force",
	base:    NewtonsForceUnit,
	matches: []string{"force"},
	units:   []Unit{NewtonsForceUnit, PoundsForceForceUnit, KilogramsForceForceUnit},
}

// NewtonsForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type NewtonsForce struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Force
}

// Name gets the name field
func (x NewtonsForce) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x NewtonsForce) Symbol() string {
	return x.symbol
}

// FromBase converts N to N
func (x NewtonsForce) FromBase(N float64) float64 {
	return N
}

// ToBase converts N to N
func (x NewtonsForce) ToBase(N float64) float64 {
	return N
}

// MatchList gets the matches field
func (x NewtonsForce) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NewtonsForce) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x NewtonsForce) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x NewtonsForce) Base() Unit {
	return NewtonsForceUnit
}

var NewtonsForceUnit = NewtonsForce{
	name:     "Newtons",
	symbol:   "N",
	fromBase: "N => N",
	toBase:   "N => N",
	matches:  []string{"n", "newton", "newtons"},
	typeOf:   ForceUnitType,
}

// PoundsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForceForce struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Force
}

// Name gets the name field
func (x PoundsForceForce) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x PoundsForceForce) Symbol() string {
	return x.symbol
}

// FromBase converts N to lbf
func (x PoundsForceForce) FromBase(N float64) float64 {
	return N * 0.224809
}

// ToBase converts N to lbf
func (x PoundsForceForce) ToBase(lbf float64) float64 {
	return lbf * 4.44822
}

// MatchList gets the matches field
func (x PoundsForceForce) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForceForce) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x PoundsForceForce) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x PoundsForceForce) Base() Unit {
	return NewtonsForceUnit
}

var PoundsForceForceUnit = PoundsForceForce{
	name:     "Pounds-force",
	symbol:   "lbf",
	fromBase: "N => N * 0.224,809",
	toBase:   "lbf => lbf * 4.448,22",
	matches:  []string{"lbf", "pounds-force", "poundsforce", "pound-force", "poundforce"},
	typeOf:   ForceUnitType,
}

// KilogramsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForceForce struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Force
}

// Name gets the name field
func (x KilogramsForceForce) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x KilogramsForceForce) Symbol() string {
	return x.symbol
}

// FromBase converts N to kgf
func (x KilogramsForceForce) FromBase(N float64) float64 {
	return N * 0.101972
}

// ToBase converts N to kgf
func (x KilogramsForceForce) ToBase(kgf float64) float64 {
	return kgf * 9.80665
}

// MatchList gets the matches field
func (x KilogramsForceForce) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForceForce) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x KilogramsForceForce) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x KilogramsForceForce) Base() Unit {
	return NewtonsForceUnit
}

var KilogramsForceForceUnit = KilogramsForceForce{
	name:     "Kilograms-force",
	symbol:   "kgf",
	fromBase: "N => N * 0.101,972",
	toBase:   "kgf => kgf * 9.806,65",
	matches:  []string{"kgf", "kilograms-force", "kilogram-force"},
	typeOf:   ForceUnitType,
}

// Length (UnitType)
// Contains 3 units:
//  - MetersLength m => m            = m
//  - FeetLength   m => m * 3.280,84 = ft
//  - InchesLength m => m * 39.370,1 = in
// Base: MetersLength
type Length struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Length) Name() string {
	return x.name
}

// Base gets the base field
func (x Length) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Length) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Length) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Length) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Length) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var LengthUnitType = Length{
	name:    "Length",
	base:    MetersLengthUnit,
	matches: []string{"l", "length"},
	units:   []Unit{MetersLengthUnit, FeetLengthUnit, InchesLengthUnit},
}

// MetersLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m
type MetersLength struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Length
}

// Name gets the name field
func (x MetersLength) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x MetersLength) Symbol() string {
	return x.symbol
}

// FromBase converts m to m
func (x MetersLength) FromBase(m float64) float64 {
	return m
}

// ToBase converts m to m
func (x MetersLength) ToBase(m float64) float64 {
	return m
}

// MatchList gets the matches field
func (x MetersLength) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MetersLength) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x MetersLength) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x MetersLength) Base() Unit {
	return MetersLengthUnit
}

var MetersLengthUnit = MetersLength{
	name:     "Meters",
	symbol:   "m",
	fromBase: "m => m",
	toBase:   "m => m",
	matches:  []string{"m", "meter", "meters"},
	typeOf:   LengthUnitType,
}

// FeetLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m
type FeetLength struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Length
}

// Name gets the name field
func (x FeetLength) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x FeetLength) Symbol() string {
	return x.symbol
}

// FromBase converts m to ft
func (x FeetLength) FromBase(m float64) float64 {
	return m * 3.28084
}

// ToBase converts m to ft
func (x FeetLength) ToBase(ft float64) float64 {
	return ft * 0.304800
}

// MatchList gets the matches field
func (x FeetLength) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x FeetLength) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x FeetLength) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x FeetLength) Base() Unit {
	return MetersLengthUnit
}

var FeetLengthUnit = FeetLength{
	name:     "Feet",
	symbol:   "ft",
	fromBase: "m => m * 3.280,84",
	toBase:   "ft => ft * 0.304,800",
	matches:  []string{"ft", "foot", "feet"},
	typeOf:   LengthUnitType,
}

// InchesLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m
type InchesLength struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Length
}

// Name gets the name field
func (x InchesLength) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x InchesLength) Symbol() string {
	return x.symbol
}

// FromBase converts m to in
func (x InchesLength) FromBase(m float64) float64 {
	return m * 39.3701
}

// ToBase converts m to in
func (x InchesLength) ToBase(in float64) float64 {
	return in * 0.0254000
}

// MatchList gets the matches field
func (x InchesLength) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesLength) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x InchesLength) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x InchesLength) Base() Unit {
	return MetersLengthUnit
}

var InchesLengthUnit = InchesLength{
	name:     "Inches",
	symbol:   "in",
	fromBase: "m => m * 39.370,1",
	toBase:   "in => in * 0.0254,000",
	matches:  []string{"in", "inch", "inches"},
	typeOf:   LengthUnitType,
}

// StrokeRate (UnitType)
// Contains 1 units:
//  - StrokesPerSecondStrokeRate ss => ss = strokes/s
// Base: StrokesPerSecondStrokeRate
type StrokeRate struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x StrokeRate) Name() string {
	return x.name
}

// Base gets the base field
func (x StrokeRate) Base() Unit {
	return x.base
}

// Units gets the units field
func (x StrokeRate) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x StrokeRate) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x StrokeRate) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokeRate) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var StrokeRateUnitType = StrokeRate{
	name:    "Stroke Rate",
	base:    StrokesPerSecondStrokeRateUnit,
	matches: []string{"strokerate", "stroke-rate"},
	units:   []Unit{StrokesPerSecondStrokeRateUnit},
}

// StrokesPerSecondStrokeRate (Unit)
// UnitType     : StrokeRate
// UnitType.Base: StrokesPerSecondStrokeRate
// Unit.FromBase: ss => ss = strokes/s
// Unit.ToBase  : ss => ss = strokes/s
type StrokesPerSecondStrokeRate struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   StrokeRate
}

// Name gets the name field
func (x StrokesPerSecondStrokeRate) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x StrokesPerSecondStrokeRate) Symbol() string {
	return x.symbol
}

// FromBase converts strokes/s to strokes/s
func (x StrokesPerSecondStrokeRate) FromBase(ss float64) float64 {
	return ss
}

// ToBase converts strokes/s to strokes/s
func (x StrokesPerSecondStrokeRate) ToBase(ss float64) float64 {
	return ss
}

// MatchList gets the matches field
func (x StrokesPerSecondStrokeRate) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokesPerSecondStrokeRate) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x StrokesPerSecondStrokeRate) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x StrokesPerSecondStrokeRate) Base() Unit {
	return StrokesPerSecondStrokeRateUnit
}

var StrokesPerSecondStrokeRateUnit = StrokesPerSecondStrokeRate{
	name:     "Strokes per Second",
	symbol:   "strokes/s",
	fromBase: "ss => ss",
	toBase:   "ss => ss",
	matches:  []string{"strokes/s", "strokespersecond", "s/s"},
	typeOf:   StrokeRateUnitType,
}

// Number (UnitType)
// Contains 1 units:
//  - _NumberNumber n => n =
// Base: _NumberNumber
type Number struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Number) Name() string {
	return x.name
}

// Base gets the base field
func (x Number) Base() Unit {
	return x.base
}

// Units gets the units field
func (x Number) Units() []Unit {
	return x.units
}

// UnitList returns the list of units as strings
func (x Number) UnitList() []string {
	var list []string
	for _, u := range x.units {
		list = append(list, u.Name())
	}
	return list
}

// MatchList gets the matches field
func (x Number) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Number) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var NumberUnitType = Number{
	name:    "Number",
	base:    _NumberNumberUnit,
	matches: []string{"*"},
	units:   []Unit{_NumberNumberUnit},
}

// _NumberNumber (Unit)
// UnitType     : Number
// UnitType.Base: _NumberNumber
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type _NumberNumber struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Number
}

// Name gets the name field
func (x _NumberNumber) Name() string {
	return x.name
}

// Symbol gets the symbol field
func (x _NumberNumber) Symbol() string {
	return x.symbol
}

// FromBase converts  to
func (x _NumberNumber) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x _NumberNumber) ToBase(n float64) float64 {
	return n
}

// MatchList gets the matches field
func (x _NumberNumber) MatchList() []string {
	return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x _NumberNumber) Matches(check string) bool {
	for _, m := range x.matches {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf gets the typeOf field
func (x _NumberNumber) TypeOf() UnitType {
	return x.typeOf
}

// Base returns the base unit
func (x _NumberNumber) Base() Unit {
	return _NumberNumberUnit
}

var _NumberNumberUnit = _NumberNumber{
	name:     "Number",
	symbol:   "",
	fromBase: "n => n",
	toBase:   "n => n",
	matches:  []string{"number", "*"},
	typeOf:   NumberUnitType,
}
