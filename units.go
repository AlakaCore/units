// Package units provides a standard way of working with unit for
// Alaka and Alakans alike. It's automatically generated via a
// .yaml file with a format that makes it really easy to add new
// units. Because we use code generation, we can provide functions
// that are super fast by using explicit values without the work
// of hand copying hundreds of methods across a bunch of permutations
// of the same thing.
//
// All the primary UnitTypes and Units of this package are built
// directly on the float64 construct. This allows go users to treat
// scalars as the Unit or UnitType that they actually represent,
// including the ability to use those type definitions as guards in
// functions that depend on a particular Unit or UnitType. Eg.:
//
// func AddPressure (p1, p2 PascalsPressure) PascalsPressure {
//     returns p1 + p2
// }
package units

import (
	"regexp"
	"strings"
)

// File autogenerated on 2022-02-24 17:10:38.114554038 -0600 CST m=+0.000724664.
// Do not edit directly

// Unit represents a scalar type of unit which can be converted to and from a base
type Unit interface {
	// Title is used for code interfaces
	Title() string
	// Name is used for displays
	Name() string
	// Symbol is the symbol of the unit and can be displayed beside scalars
	Symbol() string
	// FromBase converts the given number of the unit type base to this unit
	FromBase(float64) float64
	// ToBase converts the given number of this unit type to the base unit
	ToBase(float64) float64
	// MatchList is a list of matching strings which should represent this unit in userland
	MatchList() []string
	// Matches compares a string to a switch of all possible matches
	Matches(string) bool
	// TypeOf returns the UnitType of this unit. You can access the BaseUnit from there
	TypeOf() UnitType
	// Base returns the base Unit of this UnitType directly
	Base() Unit
}

// UnitType represents a collection of related units
type UnitType interface {
	// Title is used for code interfaces
	Title() string
	// Name is used for displays
	Name() string
	// Base returns the primary unit of this unit type that is stored in Alaka.
	// Most of the time this is an SI unit, but not always (temperature is C,
	// not K, for example)
	Base() Unit
	// Units returns all the supported units of this unit type
	Units() []Unit
	// UnitList returns all the supported units of this unit type as strings
	UnitList() []string
	// MatchList is a list of matching strings which should represent this unit type in userland
	MatchList() []string
	// Matches compares a string to a switch of all possible matches
	Matches(string) bool
}

var WhitespaceRegex = regexp.MustCompile(`\s`)

// SanitizeString removes whitespace and lower cases the string
func SanitizeString(input string) string {
	out := strings.ToLower(input)
	out = WhitespaceRegex.ReplaceAllString(out, "")
	return out
}

// AlakaTitle returns the Alaka string representing this particular unit and unit type combo
func AlakaTitle(ut UnitType, u Unit) string {
	return ut.Title() + "_" + u.Title()
}

// AllTypes is a list of all available types below
var AllTypes = [...]string{
	"Pressure",
	"Temperature",
	"Flow",
	"Volume",
	"ElectricPotential",
	"ElectricPotentialLoaded",
	"ElectricPotentialUnloaded",
	"Humidity",
	"Percentage",
	"Alarm",
	"Work",
	"Force",
	"Length",
	"StrokeRate",
	"Overspeed",
	"Underspeed",
	"Totaliser",
	"WMLFlowRate",
	"Number",
}

// AllUnits is a map of unit type -> units
var AllUnits = map[string][]string{
	"Pressure":                  {"Pascals", "Kilopascals", "Megapascals", "PoundsPerSquareInch", "InchesOfWater"},
	"Temperature":               {"DegreesCelsius", "DegreesFahrenheit", "Kelvins"},
	"Flow":                      {"CubicMetersPerSecond", "CubicFeetPerSecond", "ThousandCubicFeetPerDay"},
	"Volume":                    {"CubicMeters", "CubicFeet", "ThousandsOfCubicFeet"},
	"ElectricPotential":         {"Volts"},
	"ElectricPotentialLoaded":   {"Volts"},
	"ElectricPotentialUnloaded": {"Volts"},
	"Humidity":                  {"Percent"},
	"Percentage":                {"Percent"},
	"Alarm":                     {"Percent"},
	"Work":                      {"Joules", "InchPoundsForce", "CubicFeetOfNaturalGas", "BarrelsOfOilEquivalent"},
	"Force":                     {"Newtons", "PoundsForce", "KilogramsForce"},
	"Length":                    {"Meters", "Feet", "Inches"},
	"StrokeRate":                {"StrokesPerSecond"},
	"Overspeed":                 {"Number"},
	"Underspeed":                {"Number"},
	"Totaliser":                 {"Number"},
	"WMLFlowRate":               {"Number"},
	"Number":                    {"Number"},
}

// AllUnitTypes is a list of all available Unit and Type combos below
// AKA the list of all possible output combinations of AlakaTitle
var AllUnitTypes = [...]string{
	"Pressure_Pascals",
	"Pressure_Kilopascals",
	"Pressure_Megapascals",
	"Pressure_PoundsPerSquareInch",
	"Pressure_InchesOfWater",
	"Temperature_DegreesCelsius",
	"Temperature_DegreesFahrenheit",
	"Temperature_Kelvins",
	"Flow_CubicMetersPerSecond",
	"Flow_CubicFeetPerSecond",
	"Flow_ThousandCubicFeetPerDay",
	"Volume_CubicMeters",
	"Volume_CubicFeet",
	"Volume_ThousandsOfCubicFeet",
	"ElectricPotential_Volts",
	"ElectricPotentialLoaded_Volts",
	"ElectricPotentialUnloaded_Volts",
	"Humidity_Percent",
	"Percentage_Percent",
	"Alarm_Percent",
	"Work_Joules",
	"Work_InchPoundsForce",
	"Work_CubicFeetOfNaturalGas",
	"Work_BarrelsOfOilEquivalent",
	"Force_Newtons",
	"Force_PoundsForce",
	"Force_KilogramsForce",
	"Length_Meters",
	"Length_Feet",
	"Length_Inches",
	"StrokeRate_StrokesPerSecond",
	"Overspeed_Number",
	"Underspeed_Number",
	"Totaliser_Number",
	"WMLFlowRate_Number",
	"Number_Number",
}

// GetType returns the unit type which matches input or NumberUnitType
func GetType(input string) UnitType {
	switch SanitizeString(input) {
	case "pressure":
		return PressureUnitType
	case "temperature":
		return TemperatureUnitType
	case "temp":
		return TemperatureUnitType
	case "flow":
		return FlowUnitType
	case "flowrate":
		return FlowUnitType
	case "flow_rate":
		return FlowUnitType
	case "gasflow":
		return FlowUnitType
	case "gasflowrate":
		return FlowUnitType
	case "gas_flow":
		return FlowUnitType
	case "gas_flow_rate":
		return FlowUnitType
	case "volume":
		return VolumeUnitType
	case "electricpotential":
		return ElectricPotentialUnitType
	case "voltage":
		return ElectricPotentialUnitType
	case "electricpotentialloaded":
		return ElectricPotentialLoadedUnitType
	case "voltageloaded":
		return ElectricPotentialLoadedUnitType
	case "electricpotentialunloaded":
		return ElectricPotentialUnloadedUnitType
	case "voltageunloaded":
		return ElectricPotentialUnloadedUnitType
	case "humidity":
		return HumidityUnitType
	case "percentage":
		return PercentageUnitType
	case "alarm":
		return AlarmUnitType
	case "work":
		return WorkUnitType
	case "force":
		return ForceUnitType
	case "l":
		return LengthUnitType
	case "length":
		return LengthUnitType
	case "strokerate":
		return StrokeRateUnitType
	case "stroke-rate":
		return StrokeRateUnitType
	case "overspeed":
		return OverspeedUnitType
	case "underspeed":
		return UnderspeedUnitType
	case "totaliser":
		return TotaliserUnitType
	case "wmlflowrate":
		return WMLFlowRateUnitType
	case "*":
		return NumberUnitType
	default:
		return NumberUnitType
	}
}

// GetUnit returns the unit which matches input or NumberNumberUnit
func GetUnit(input string, typeOf UnitType) Unit {
	search := typeOf.Title() + "->" + SanitizeString(input)
	switch search {
	case "Pressure->pa":
		return PascalsPressureUnit
	case "Pressure->pascal":
		return PascalsPressureUnit
	case "Pressure->pascals":
		return PascalsPressureUnit
	case "Pressure->kpa":
		return KilopascalsPressureUnit
	case "Pressure->kilopascal":
		return KilopascalsPressureUnit
	case "Pressure->kilopascals":
		return KilopascalsPressureUnit
	case "Pressure->mpa":
		return MegapascalsPressureUnit
	case "Pressure->megapascal":
		return MegapascalsPressureUnit
	case "Pressure->megapascals":
		return MegapascalsPressureUnit
	case "Pressure->psi":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->poundspersquareinch":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->poundpersquareinch":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->inh₂o":
		return InchesOfWaterPressureUnit
	case "Pressure->inh₂0":
		return InchesOfWaterPressureUnit
	case "Pressure->inh2o":
		return InchesOfWaterPressureUnit
	case "Pressure->inh20":
		return InchesOfWaterPressureUnit
	case "Pressure->incheswater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchesofwater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchwater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchofwater":
		return InchesOfWaterPressureUnit
	case "Temperature->c":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->°c":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->celsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreesc":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreec":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreescelsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreecelsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->f":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->°f":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->fahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreesf":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreef":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreesfahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreefahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->k":
		return KelvinsTemperatureUnit
	case "Temperature->°k":
		return KelvinsTemperatureUnit
	case "Temperature->kelvin":
		return KelvinsTemperatureUnit
	case "Temperature->kelvins":
		return KelvinsTemperatureUnit
	case "Temperature->degreesk":
		return KelvinsTemperatureUnit
	case "Temperature->degreek":
		return KelvinsTemperatureUnit
	case "Temperature->degreeskelvin":
		return KelvinsTemperatureUnit
	case "Temperature->degreekelvin":
		return KelvinsTemperatureUnit
	case "Flow->m³/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m³s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m3/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m3s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m^3/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m^3s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeterspersecond":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeterpersecond":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeters/second":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeter/second":
		return CubicMetersPerSecondFlowUnit
	case "Flow->ft³/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft³s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft^3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft^3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f³/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f³s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f^3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f^3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfeetpersecond":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfootpersecond":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfeet/second":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfoot/second":
		return CubicFeetPerSecondFlowUnit
	case "Flow->mcfd":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcf/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcftd":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcft/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft³/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft³d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft^3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft^3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf³/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf³d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf^3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf^3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->thousandcubicfeetperday":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->thousandcubicfeet/day":
		return ThousandCubicFeetPerDayFlowUnit
	case "Volume->m³":
		return CubicMetersVolumeUnit
	case "Volume->m3":
		return CubicMetersVolumeUnit
	case "Volume->cubicmeter":
		return CubicMetersVolumeUnit
	case "Volume->cubicmeters":
		return CubicMetersVolumeUnit
	case "Volume->cuft":
		return CubicFeetVolumeUnit
	case "Volume->ft³":
		return CubicFeetVolumeUnit
	case "Volume->f³":
		return CubicFeetVolumeUnit
	case "Volume->cubicfoot":
		return CubicFeetVolumeUnit
	case "Volume->cubicfeet":
		return CubicFeetVolumeUnit
	case "Volume->mcf":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->mft³":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->mf³":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandcubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandsofcubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandscubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "ElectricPotential->volt":
		return VoltsElectricPotentialUnit
	case "ElectricPotential->volts":
		return VoltsElectricPotentialUnit
	case "ElectricPotential->v":
		return VoltsElectricPotentialUnit
	case "ElectricPotentialLoaded->volt":
		return VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialLoaded->volts":
		return VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialLoaded->v":
		return VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialUnloaded->volt":
		return VoltsElectricPotentialUnloadedUnit
	case "ElectricPotentialUnloaded->volts":
		return VoltsElectricPotentialUnloadedUnit
	case "ElectricPotentialUnloaded->v":
		return VoltsElectricPotentialUnloadedUnit
	case "Humidity->%":
		return PercentHumidityUnit
	case "Humidity->percent":
		return PercentHumidityUnit
	case "Humidity->percentage":
		return PercentHumidityUnit
	case "Percentage->%":
		return PercentPercentageUnit
	case "Percentage->percent":
		return PercentPercentageUnit
	case "Percentage->percentage":
		return PercentPercentageUnit
	case "Alarm->%":
		return PercentAlarmUnit
	case "Alarm->percent":
		return PercentAlarmUnit
	case "Alarm->percentage":
		return PercentAlarmUnit
	case "Work->j":
		return JoulesWorkUnit
	case "Work->joule":
		return JoulesWorkUnit
	case "Work->joules":
		return JoulesWorkUnit
	case "Work->inlbf":
		return InchPoundsForceWorkUnit
	case "Work->inch-poundsforce":
		return InchPoundsForceWorkUnit
	case "Work->inch-poundforce":
		return InchPoundsForceWorkUnit
	case "Work->in-lbf":
		return InchPoundsForceWorkUnit
	case "Work->btuᵢₜ":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->btuit":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->btu":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->cubicfeetofnaturalgas":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->bboe":
		return BarrelsOfOilEquivalentWorkUnit
	case "Work->barrelsofoilequivalent":
		return BarrelsOfOilEquivalentWorkUnit
	case "Force->n":
		return NewtonsForceUnit
	case "Force->newton":
		return NewtonsForceUnit
	case "Force->newtons":
		return NewtonsForceUnit
	case "Force->lbf":
		return PoundsForceForceUnit
	case "Force->pounds-force":
		return PoundsForceForceUnit
	case "Force->poundsforce":
		return PoundsForceForceUnit
	case "Force->pound-force":
		return PoundsForceForceUnit
	case "Force->poundforce":
		return PoundsForceForceUnit
	case "Force->kgf":
		return KilogramsForceForceUnit
	case "Force->kilograms-force":
		return KilogramsForceForceUnit
	case "Force->kilogram-force":
		return KilogramsForceForceUnit
	case "Length->m":
		return MetersLengthUnit
	case "Length->meter":
		return MetersLengthUnit
	case "Length->meters":
		return MetersLengthUnit
	case "Length->ft":
		return FeetLengthUnit
	case "Length->foot":
		return FeetLengthUnit
	case "Length->feet":
		return FeetLengthUnit
	case "Length->in":
		return InchesLengthUnit
	case "Length->inch":
		return InchesLengthUnit
	case "Length->inches":
		return InchesLengthUnit
	case "StrokeRate->strokes/s":
		return StrokesPerSecondStrokeRateUnit
	case "StrokeRate->strokespersecond":
		return StrokesPerSecondStrokeRateUnit
	case "StrokeRate->s/s":
		return StrokesPerSecondStrokeRateUnit
	case "Overspeed->number":
		return NumberOverspeedUnit
	case "Overspeed->*":
		return NumberOverspeedUnit
	case "Underspeed->number":
		return NumberUnderspeedUnit
	case "Underspeed->*":
		return NumberUnderspeedUnit
	case "Totaliser->number":
		return NumberTotaliserUnit
	case "Totaliser->*":
		return NumberTotaliserUnit
	case "WMLFlowRate->number":
		return NumberWMLFlowRateUnit
	case "WMLFlowRate->*":
		return NumberWMLFlowRateUnit
	case "Number->number":
		return NumberNumberUnit
	case "Number->*":
		return NumberNumberUnit
	default:
		return NumberNumberUnit
	}
}

// GetTypeUnit returns the unit type and unit which matches input or (NumberUnitType, NumberNumberUnit).
// Opposite of AlakaTitle
func GetTypeUnit(input string) (UnitType, Unit) {
	switch input {
	case "Pressure_Pascals":
		return PressureUnitType, PascalsPressureUnit
	case "Pressure_Kilopascals":
		return PressureUnitType, KilopascalsPressureUnit
	case "Pressure_Megapascals":
		return PressureUnitType, MegapascalsPressureUnit
	case "Pressure_PoundsPerSquareInch":
		return PressureUnitType, PoundsPerSquareInchPressureUnit
	case "Pressure_InchesOfWater":
		return PressureUnitType, InchesOfWaterPressureUnit
	case "Temperature_DegreesCelsius":
		return TemperatureUnitType, DegreesCelsiusTemperatureUnit
	case "Temperature_DegreesFahrenheit":
		return TemperatureUnitType, DegreesFahrenheitTemperatureUnit
	case "Temperature_Kelvins":
		return TemperatureUnitType, KelvinsTemperatureUnit
	case "Flow_CubicMetersPerSecond":
		return FlowUnitType, CubicMetersPerSecondFlowUnit
	case "Flow_CubicFeetPerSecond":
		return FlowUnitType, CubicFeetPerSecondFlowUnit
	case "Flow_ThousandCubicFeetPerDay":
		return FlowUnitType, ThousandCubicFeetPerDayFlowUnit
	case "Volume_CubicMeters":
		return VolumeUnitType, CubicMetersVolumeUnit
	case "Volume_CubicFeet":
		return VolumeUnitType, CubicFeetVolumeUnit
	case "Volume_ThousandsOfCubicFeet":
		return VolumeUnitType, ThousandsOfCubicFeetVolumeUnit
	case "ElectricPotential_Volts":
		return ElectricPotentialUnitType, VoltsElectricPotentialUnit
	case "ElectricPotentialLoaded_Volts":
		return ElectricPotentialLoadedUnitType, VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialUnloaded_Volts":
		return ElectricPotentialUnloadedUnitType, VoltsElectricPotentialUnloadedUnit
	case "Humidity_Percent":
		return HumidityUnitType, PercentHumidityUnit
	case "Percentage_Percent":
		return PercentageUnitType, PercentPercentageUnit
	case "Alarm_Percent":
		return AlarmUnitType, PercentAlarmUnit
	case "Work_Joules":
		return WorkUnitType, JoulesWorkUnit
	case "Work_InchPoundsForce":
		return WorkUnitType, InchPoundsForceWorkUnit
	case "Work_CubicFeetOfNaturalGas":
		return WorkUnitType, CubicFeetOfNaturalGasWorkUnit
	case "Work_BarrelsOfOilEquivalent":
		return WorkUnitType, BarrelsOfOilEquivalentWorkUnit
	case "Force_Newtons":
		return ForceUnitType, NewtonsForceUnit
	case "Force_PoundsForce":
		return ForceUnitType, PoundsForceForceUnit
	case "Force_KilogramsForce":
		return ForceUnitType, KilogramsForceForceUnit
	case "Length_Meters":
		return LengthUnitType, MetersLengthUnit
	case "Length_Feet":
		return LengthUnitType, FeetLengthUnit
	case "Length_Inches":
		return LengthUnitType, InchesLengthUnit
	case "StrokeRate_StrokesPerSecond":
		return StrokeRateUnitType, StrokesPerSecondStrokeRateUnit
	case "Overspeed_Number":
		return OverspeedUnitType, NumberOverspeedUnit
	case "Underspeed_Number":
		return UnderspeedUnitType, NumberUnderspeedUnit
	case "Totaliser_Number":
		return TotaliserUnitType, NumberTotaliserUnit
	case "WMLFlowRate_Number":
		return WMLFlowRateUnitType, NumberWMLFlowRateUnit
	case "Number_Number":
		return NumberUnitType, NumberNumberUnit
	default:
		return NumberUnitType, NumberNumberUnit
	}
}

// Pressure (UnitType)
// Contains 5 units:
//  - PascalsPressure             Pa => Pa                 = Pa
//  - KilopascalsPressure         Pa => Pa * 0.001         = kPa
//  - MegapascalsPressure         Pa => Pa * 0.000,001     = MPa
//  - PoundsPerSquareInchPressure Pa => Pa * 0.000,145,038 = psi
//  - InchesOfWaterPressure       Pa => Pa * 0.004,014,74  = inH₂O
// Base: PascalsPressure
type Pressure float64

// Title always returns "Pressure"
func (x Pressure) Title() string {
	return "Pressure"
}

// Name always returns "Pressure"
func (x Pressure) Name() string {
	return "Pressure"
}

// Base always returns PascalsPressureUnit
func (x Pressure) Base() Unit {
	return PascalsPressureUnit
}

// PressureUnits is effectively a constant
var PressureUnits = [...]Unit{PascalsPressureUnit, KilopascalsPressureUnit, MegapascalsPressureUnit, PoundsPerSquareInchPressureUnit, InchesOfWaterPressureUnit}

// Units always returns PressureUnits[:]
func (x Pressure) Units() []Unit {
	return PressureUnits[:]
}

// PressureUnitList is effectively a constant
var PressureUnitList = [...]string{"Pascals", "Kilopascals", "Megapascals", "Pounds per Square Inch", "Inches of Water"}

// UnitList always returns PressureUnitList[:]
func (x Pressure) UnitList() []string {
	return PressureUnitList[:]
}

// PressureMatchList is effectively a constant
var PressureMatchList = [...]string{"pressure"}

// MatchList always returns PressureMatchList[:]
func (x Pressure) MatchList() []string {
	return PressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Pressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var PressureUnitType Pressure = 0.0

// PascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa = Pa
// Unit.ToBase  : Pa => Pa = Pa
type PascalsPressure Pressure

// Title always returns "Pascals"
func (x PascalsPressure) Title() string {
	return "Pascals"
}

// Name always returns "Pascals"
func (x PascalsPressure) Name() string {
	return "Pascals"
}

// Symbol always returns "Pa"
func (x PascalsPressure) Symbol() string {
	return "Pa"
}

// FromBase converts Pa to Pa
func (x PascalsPressure) FromBase(Pa float64) float64 {
	return Pa
}

// ToBase converts Pa to Pa
func (x PascalsPressure) ToBase(Pa float64) float64 {
	return Pa
}

// PascalsPressureMatchList is effectively a constant
var PascalsPressureMatchList = [...]string{"pa", "pascal", "pascals"}

// MatchList always returns PascalsPressureMatchList[:]
func (x PascalsPressure) MatchList() []string {
	return PascalsPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PascalsPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x PascalsPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x PascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var PascalsPressureUnit PascalsPressure = 0.0

// KilopascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.001   = kPa
// Unit.ToBase  : kPa => kPa * 1,000 = Pa
type KilopascalsPressure Pressure

// Title always returns "Kilopascals"
func (x KilopascalsPressure) Title() string {
	return "Kilopascals"
}

// Name always returns "Kilopascals"
func (x KilopascalsPressure) Name() string {
	return "Kilopascals"
}

// Symbol always returns "kPa"
func (x KilopascalsPressure) Symbol() string {
	return "kPa"
}

// FromBase converts Pa to kPa
func (x KilopascalsPressure) FromBase(Pa float64) float64 {
	return Pa * 0.001
}

// ToBase converts kPa to Pa
func (x KilopascalsPressure) ToBase(kPa float64) float64 {
	return kPa * 1000
}

// KilopascalsPressureMatchList is effectively a constant
var KilopascalsPressureMatchList = [...]string{"kpa", "kilopascal", "kilopascals"}

// MatchList always returns KilopascalsPressureMatchList[:]
func (x KilopascalsPressure) MatchList() []string {
	return KilopascalsPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilopascalsPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x KilopascalsPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x KilopascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var KilopascalsPressureUnit KilopascalsPressure = 0.0

// MegapascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,001   = MPa
// Unit.ToBase  : MPa => MPa * 1,000,000 = Pa
type MegapascalsPressure Pressure

// Title always returns "Megapascals"
func (x MegapascalsPressure) Title() string {
	return "Megapascals"
}

// Name always returns "Megapascals"
func (x MegapascalsPressure) Name() string {
	return "Megapascals"
}

// Symbol always returns "MPa"
func (x MegapascalsPressure) Symbol() string {
	return "MPa"
}

// FromBase converts Pa to MPa
func (x MegapascalsPressure) FromBase(Pa float64) float64 {
	return Pa * 0.000001
}

// ToBase converts MPa to Pa
func (x MegapascalsPressure) ToBase(MPa float64) float64 {
	return MPa * 1000000
}

// MegapascalsPressureMatchList is effectively a constant
var MegapascalsPressureMatchList = [...]string{"mpa", "megapascal", "megapascals"}

// MatchList always returns MegapascalsPressureMatchList[:]
func (x MegapascalsPressure) MatchList() []string {
	return MegapascalsPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MegapascalsPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x MegapascalsPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x MegapascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var MegapascalsPressureUnit MegapascalsPressure = 0.0

// PoundsPerSquareInchPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,145,038 = psi
// Unit.ToBase  : psi => psi * 6,894.76    = Pa
type PoundsPerSquareInchPressure Pressure

// Title always returns "PoundsPerSquareInch"
func (x PoundsPerSquareInchPressure) Title() string {
	return "PoundsPerSquareInch"
}

// Name always returns "Pounds per Square Inch"
func (x PoundsPerSquareInchPressure) Name() string {
	return "Pounds per Square Inch"
}

// Symbol always returns "psi"
func (x PoundsPerSquareInchPressure) Symbol() string {
	return "psi"
}

// FromBase converts Pa to psi
func (x PoundsPerSquareInchPressure) FromBase(Pa float64) float64 {
	return Pa * 0.000145038
}

// ToBase converts psi to Pa
func (x PoundsPerSquareInchPressure) ToBase(psi float64) float64 {
	return psi * 6894.76
}

// PoundsPerSquareInchPressureMatchList is effectively a constant
var PoundsPerSquareInchPressureMatchList = [...]string{"psi", "poundspersquareinch", "poundpersquareinch"}

// MatchList always returns PoundsPerSquareInchPressureMatchList[:]
func (x PoundsPerSquareInchPressure) MatchList() []string {
	return PoundsPerSquareInchPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsPerSquareInchPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x PoundsPerSquareInchPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x PoundsPerSquareInchPressure) Base() Unit {
	return PascalsPressureUnit
}

var PoundsPerSquareInchPressureUnit PoundsPerSquareInchPressure = 0.0

// InchesOfWaterPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.004,014,74  = inH₂O
// Unit.ToBase  : inH2O => inH2O * 249.082 = Pa
type InchesOfWaterPressure Pressure

// Title always returns "InchesOfWater"
func (x InchesOfWaterPressure) Title() string {
	return "InchesOfWater"
}

// Name always returns "Inches of Water"
func (x InchesOfWaterPressure) Name() string {
	return "Inches of Water"
}

// Symbol always returns "inH₂O"
func (x InchesOfWaterPressure) Symbol() string {
	return "inH₂O"
}

// FromBase converts Pa to inH₂O
func (x InchesOfWaterPressure) FromBase(Pa float64) float64 {
	return Pa * 0.00401474
}

// ToBase converts inH₂O to Pa
func (x InchesOfWaterPressure) ToBase(inH2O float64) float64 {
	return inH2O * 249.082
}

// InchesOfWaterPressureMatchList is effectively a constant
var InchesOfWaterPressureMatchList = [...]string{"inh₂o", "inh₂0", "inh2o", "inh20", "incheswater", "inchesofwater", "inchwater", "inchofwater"}

// MatchList always returns InchesOfWaterPressureMatchList[:]
func (x InchesOfWaterPressure) MatchList() []string {
	return InchesOfWaterPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesOfWaterPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x InchesOfWaterPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x InchesOfWaterPressure) Base() Unit {
	return PascalsPressureUnit
}

var InchesOfWaterPressureUnit InchesOfWaterPressure = 0.0

// Temperature (UnitType)
// Contains 3 units:
//  - DegreesCelsiusTemperature    C => C                  = °C
//  - DegreesFahrenheitTemperature C => (C * (9 / 5)) + 32 = °F
//  - KelvinsTemperature           C => C + 273.15         = K
// Base: DegreesCelsiusTemperature
type Temperature float64

// Title always returns "Temperature"
func (x Temperature) Title() string {
	return "Temperature"
}

// Name always returns "Temperature"
func (x Temperature) Name() string {
	return "Temperature"
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x Temperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

// TemperatureUnits is effectively a constant
var TemperatureUnits = [...]Unit{DegreesCelsiusTemperatureUnit, DegreesFahrenheitTemperatureUnit, KelvinsTemperatureUnit}

// Units always returns TemperatureUnits[:]
func (x Temperature) Units() []Unit {
	return TemperatureUnits[:]
}

// TemperatureUnitList is effectively a constant
var TemperatureUnitList = [...]string{"Degrees Celsius", "Degrees Fahrenheit", "Kelvins"}

// UnitList always returns TemperatureUnitList[:]
func (x Temperature) UnitList() []string {
	return TemperatureUnitList[:]
}

// TemperatureMatchList is effectively a constant
var TemperatureMatchList = [...]string{"temperature", "temp"}

// MatchList always returns TemperatureMatchList[:]
func (x Temperature) MatchList() []string {
	return TemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Temperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var TemperatureUnitType Temperature = 0.0

// DegreesCelsiusTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C = °C
// Unit.ToBase  : C => C = °C
type DegreesCelsiusTemperature Temperature

// Title always returns "DegreesCelsius"
func (x DegreesCelsiusTemperature) Title() string {
	return "DegreesCelsius"
}

// Name always returns "Degrees Celsius"
func (x DegreesCelsiusTemperature) Name() string {
	return "Degrees Celsius"
}

// Symbol always returns "°C"
func (x DegreesCelsiusTemperature) Symbol() string {
	return "°C"
}

// FromBase converts °C to °C
func (x DegreesCelsiusTemperature) FromBase(C float64) float64 {
	return C
}

// ToBase converts °C to °C
func (x DegreesCelsiusTemperature) ToBase(C float64) float64 {
	return C
}

// DegreesCelsiusTemperatureMatchList is effectively a constant
var DegreesCelsiusTemperatureMatchList = [...]string{"c", "°c", "celsius", "degreesc", "degreec", "degreescelsius", "degreecelsius"}

// MatchList always returns DegreesCelsiusTemperatureMatchList[:]
func (x DegreesCelsiusTemperature) MatchList() []string {
	return DegreesCelsiusTemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesCelsiusTemperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TemperatureUnitType
func (x DegreesCelsiusTemperature) TypeOf() UnitType {
	return TemperatureUnitType
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x DegreesCelsiusTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var DegreesCelsiusTemperatureUnit DegreesCelsiusTemperature = 0.0

// DegreesFahrenheitTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => (C * (9 / 5)) + 32 = °F
// Unit.ToBase  : F => (F - 32) * (5 / 9) = °C
type DegreesFahrenheitTemperature Temperature

// Title always returns "DegreesFahrenheit"
func (x DegreesFahrenheitTemperature) Title() string {
	return "DegreesFahrenheit"
}

// Name always returns "Degrees Fahrenheit"
func (x DegreesFahrenheitTemperature) Name() string {
	return "Degrees Fahrenheit"
}

// Symbol always returns "°F"
func (x DegreesFahrenheitTemperature) Symbol() string {
	return "°F"
}

// FromBase converts °C to °F
func (x DegreesFahrenheitTemperature) FromBase(C float64) float64 {
	return (C * (9 / 5)) + 32
}

// ToBase converts °F to °C
func (x DegreesFahrenheitTemperature) ToBase(F float64) float64 {
	return (F - 32) * (5 / 9)
}

// DegreesFahrenheitTemperatureMatchList is effectively a constant
var DegreesFahrenheitTemperatureMatchList = [...]string{"f", "°f", "fahrenheit", "degreesf", "degreef", "degreesfahrenheit", "degreefahrenheit"}

// MatchList always returns DegreesFahrenheitTemperatureMatchList[:]
func (x DegreesFahrenheitTemperature) MatchList() []string {
	return DegreesFahrenheitTemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesFahrenheitTemperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TemperatureUnitType
func (x DegreesFahrenheitTemperature) TypeOf() UnitType {
	return TemperatureUnitType
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x DegreesFahrenheitTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var DegreesFahrenheitTemperatureUnit DegreesFahrenheitTemperature = 0.0

// KelvinsTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C + 273.15 = K
// Unit.ToBase  : K => K - 273.15 = °C
type KelvinsTemperature Temperature

// Title always returns "Kelvins"
func (x KelvinsTemperature) Title() string {
	return "Kelvins"
}

// Name always returns "Kelvins"
func (x KelvinsTemperature) Name() string {
	return "Kelvins"
}

// Symbol always returns "K"
func (x KelvinsTemperature) Symbol() string {
	return "K"
}

// FromBase converts °C to K
func (x KelvinsTemperature) FromBase(C float64) float64 {
	return C + 273.15
}

// ToBase converts K to °C
func (x KelvinsTemperature) ToBase(K float64) float64 {
	return K - 273.15
}

// KelvinsTemperatureMatchList is effectively a constant
var KelvinsTemperatureMatchList = [...]string{"k", "°k", "kelvin", "kelvins", "degreesk", "degreek", "degreeskelvin", "degreekelvin"}

// MatchList always returns KelvinsTemperatureMatchList[:]
func (x KelvinsTemperature) MatchList() []string {
	return KelvinsTemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KelvinsTemperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TemperatureUnitType
func (x KelvinsTemperature) TypeOf() UnitType {
	return TemperatureUnitType
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x KelvinsTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var KelvinsTemperatureUnit KelvinsTemperature = 0.0

// Flow (UnitType)
// Contains 3 units:
//  - CubicMetersPerSecondFlow    m3s => m3s            = m³/s
//  - CubicFeetPerSecondFlow      m3s => m3s * 35.314,7 = ft³/s
//  - ThousandCubicFeetPerDayFlow m3s => m3s * 3,051.19 = MCFD
// Base: CubicMetersPerSecondFlow
type Flow float64

// Title always returns "Flow"
func (x Flow) Title() string {
	return "Flow"
}

// Name always returns "Flow"
func (x Flow) Name() string {
	return "Flow"
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x Flow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

// FlowUnits is effectively a constant
var FlowUnits = [...]Unit{CubicMetersPerSecondFlowUnit, CubicFeetPerSecondFlowUnit, ThousandCubicFeetPerDayFlowUnit}

// Units always returns FlowUnits[:]
func (x Flow) Units() []Unit {
	return FlowUnits[:]
}

// FlowUnitList is effectively a constant
var FlowUnitList = [...]string{"Cubic Meters per Second", "CubicFeetPerSecond", "Thousand Cubic Feet per Day"}

// UnitList always returns FlowUnitList[:]
func (x Flow) UnitList() []string {
	return FlowUnitList[:]
}

// FlowMatchList is effectively a constant
var FlowMatchList = [...]string{"flow", "flowrate", "flow_rate", "gasflow", "gasflowrate", "gas_flow", "gas_flow_rate"}

// MatchList always returns FlowMatchList[:]
func (x Flow) MatchList() []string {
	return FlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Flow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var FlowUnitType Flow = 0.0

// CubicMetersPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s = m³/s
// Unit.ToBase  : m3s => m3s = m³/s
type CubicMetersPerSecondFlow Flow

// Title always returns "CubicMetersPerSecond"
func (x CubicMetersPerSecondFlow) Title() string {
	return "CubicMetersPerSecond"
}

// Name always returns "Cubic Meters per Second"
func (x CubicMetersPerSecondFlow) Name() string {
	return "Cubic Meters per Second"
}

// Symbol always returns "m³/s"
func (x CubicMetersPerSecondFlow) Symbol() string {
	return "m³/s"
}

// FromBase converts m³/s to m³/s
func (x CubicMetersPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s
}

// ToBase converts m³/s to m³/s
func (x CubicMetersPerSecondFlow) ToBase(m3s float64) float64 {
	return m3s
}

// CubicMetersPerSecondFlowMatchList is effectively a constant
var CubicMetersPerSecondFlowMatchList = [...]string{"m³/s", "m³s", "m3/s", "m3s", "m^3/s", "m^3s", "cubicmeterspersecond", "cubicmeterpersecond", "cubicmeters/second", "cubicmeter/second"}

// MatchList always returns CubicMetersPerSecondFlowMatchList[:]
func (x CubicMetersPerSecondFlow) MatchList() []string {
	return CubicMetersPerSecondFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMetersPerSecondFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x CubicMetersPerSecondFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x CubicMetersPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var CubicMetersPerSecondFlowUnit CubicMetersPerSecondFlow = 0.0

// CubicFeetPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 35.314,7      = ft³/s
// Unit.ToBase  : ft3s => ft3s * 0.028,316,8 = m³/s
type CubicFeetPerSecondFlow Flow

// Title always returns "CubicFeetPerSecond"
func (x CubicFeetPerSecondFlow) Title() string {
	return "CubicFeetPerSecond"
}

// Name always returns "CubicFeetPerSecond"
func (x CubicFeetPerSecondFlow) Name() string {
	return "CubicFeetPerSecond"
}

// Symbol always returns "ft³/s"
func (x CubicFeetPerSecondFlow) Symbol() string {
	return "ft³/s"
}

// FromBase converts m³/s to ft³/s
func (x CubicFeetPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s * 35.3147
}

// ToBase converts ft³/s to m³/s
func (x CubicFeetPerSecondFlow) ToBase(ft3s float64) float64 {
	return ft3s * 0.0283168
}

// CubicFeetPerSecondFlowMatchList is effectively a constant
var CubicFeetPerSecondFlowMatchList = [...]string{"ft³/s", "ft³s", "ft3/s", "ft3s", "ft^3/s", "ft^3s", "f³/s", "f³s", "f3/s", "f3s", "f^3/s", "f^3s", "cubicfeetpersecond", "cubicfootpersecond", "cubicfeet/second", "cubicfoot/second"}

// MatchList always returns CubicFeetPerSecondFlowMatchList[:]
func (x CubicFeetPerSecondFlow) MatchList() []string {
	return CubicFeetPerSecondFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetPerSecondFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x CubicFeetPerSecondFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x CubicFeetPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var CubicFeetPerSecondFlowUnit CubicFeetPerSecondFlow = 0.0

// ThousandCubicFeetPerDayFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 3,051.19        = MCFD
// Unit.ToBase  : MCFD => MCFD * 0.000,327,741 = m³/s
type ThousandCubicFeetPerDayFlow Flow

// Title always returns "ThousandCubicFeetPerDay"
func (x ThousandCubicFeetPerDayFlow) Title() string {
	return "ThousandCubicFeetPerDay"
}

// Name always returns "Thousand Cubic Feet per Day"
func (x ThousandCubicFeetPerDayFlow) Name() string {
	return "Thousand Cubic Feet per Day"
}

// Symbol always returns "MCFD"
func (x ThousandCubicFeetPerDayFlow) Symbol() string {
	return "MCFD"
}

// FromBase converts m³/s to MCFD
func (x ThousandCubicFeetPerDayFlow) FromBase(m3s float64) float64 {
	return m3s * 3051.19
}

// ToBase converts MCFD to m³/s
func (x ThousandCubicFeetPerDayFlow) ToBase(MCFD float64) float64 {
	return MCFD * 0.000327741
}

// ThousandCubicFeetPerDayFlowMatchList is effectively a constant
var ThousandCubicFeetPerDayFlowMatchList = [...]string{"mcfd", "mcf/d", "mcftd", "mcft/d", "mft³/d", "mft³d", "mft3/d", "mft3d", "mft^3/d", "mft^3d", "mf³/d", "mf³d", "mf3/d", "mf3d", "mf^3/d", "mf^3d", "thousandcubicfeetperday", "thousandcubicfeet/day"}

// MatchList always returns ThousandCubicFeetPerDayFlowMatchList[:]
func (x ThousandCubicFeetPerDayFlow) MatchList() []string {
	return ThousandCubicFeetPerDayFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandCubicFeetPerDayFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x ThousandCubicFeetPerDayFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x ThousandCubicFeetPerDayFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var ThousandCubicFeetPerDayFlowUnit ThousandCubicFeetPerDayFlow = 0.0

// Volume (UnitType)
// Contains 3 units:
//  - CubicMetersVolume          m3 => m3               = m³
//  - CubicFeetVolume            m3 => m3 * 35.314,7    = cu ft
//  - ThousandsOfCubicFeetVolume m3 => m3 * 0.035,314,7 = MCF
// Base: CubicMetersVolume
type Volume float64

// Title always returns "Volume"
func (x Volume) Title() string {
	return "Volume"
}

// Name always returns "Volume"
func (x Volume) Name() string {
	return "Volume"
}

// Base always returns CubicMetersVolumeUnit
func (x Volume) Base() Unit {
	return CubicMetersVolumeUnit
}

// VolumeUnits is effectively a constant
var VolumeUnits = [...]Unit{CubicMetersVolumeUnit, CubicFeetVolumeUnit, ThousandsOfCubicFeetVolumeUnit}

// Units always returns VolumeUnits[:]
func (x Volume) Units() []Unit {
	return VolumeUnits[:]
}

// VolumeUnitList is effectively a constant
var VolumeUnitList = [...]string{"Cubic Meters", "Cubic Feet", "Thousands of Cubic Feet"}

// UnitList always returns VolumeUnitList[:]
func (x Volume) UnitList() []string {
	return VolumeUnitList[:]
}

// VolumeMatchList is effectively a constant
var VolumeMatchList = [...]string{"volume"}

// MatchList always returns VolumeMatchList[:]
func (x Volume) MatchList() []string {
	return VolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Volume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var VolumeUnitType Volume = 0.0

// CubicMetersVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 = m³
// Unit.ToBase  : m3 => m3 = m³
type CubicMetersVolume Volume

// Title always returns "CubicMeters"
func (x CubicMetersVolume) Title() string {
	return "CubicMeters"
}

// Name always returns "Cubic Meters"
func (x CubicMetersVolume) Name() string {
	return "Cubic Meters"
}

// Symbol always returns "m³"
func (x CubicMetersVolume) Symbol() string {
	return "m³"
}

// FromBase converts m³ to m³
func (x CubicMetersVolume) FromBase(m3 float64) float64 {
	return m3
}

// ToBase converts m³ to m³
func (x CubicMetersVolume) ToBase(m3 float64) float64 {
	return m3
}

// CubicMetersVolumeMatchList is effectively a constant
var CubicMetersVolumeMatchList = [...]string{"m³", "m3", "cubicmeter", "cubicmeters"}

// MatchList always returns CubicMetersVolumeMatchList[:]
func (x CubicMetersVolume) MatchList() []string {
	return CubicMetersVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMetersVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x CubicMetersVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x CubicMetersVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var CubicMetersVolumeUnit CubicMetersVolume = 0.0

// CubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 35.314,7        = cu ft
// Unit.ToBase  : cuft => cuft * 0.028,316,8 = m³
type CubicFeetVolume Volume

// Title always returns "CubicFeet"
func (x CubicFeetVolume) Title() string {
	return "CubicFeet"
}

// Name always returns "Cubic Feet"
func (x CubicFeetVolume) Name() string {
	return "Cubic Feet"
}

// Symbol always returns "cu ft"
func (x CubicFeetVolume) Symbol() string {
	return "cu ft"
}

// FromBase converts m³ to cu ft
func (x CubicFeetVolume) FromBase(m3 float64) float64 {
	return m3 * 35.3147
}

// ToBase converts cu ft to m³
func (x CubicFeetVolume) ToBase(cuft float64) float64 {
	return cuft * 0.0283168
}

// CubicFeetVolumeMatchList is effectively a constant
var CubicFeetVolumeMatchList = [...]string{"cuft", "ft³", "f³", "cubicfoot", "cubicfeet"}

// MatchList always returns CubicFeetVolumeMatchList[:]
func (x CubicFeetVolume) MatchList() []string {
	return CubicFeetVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x CubicFeetVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x CubicFeetVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var CubicFeetVolumeUnit CubicFeetVolume = 0.0

// ThousandsOfCubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 0.035,314,7 = MCF
// Unit.ToBase  : MCF => MCF * 28.316,8  = m³
type ThousandsOfCubicFeetVolume Volume

// Title always returns "ThousandsOfCubicFeet"
func (x ThousandsOfCubicFeetVolume) Title() string {
	return "ThousandsOfCubicFeet"
}

// Name always returns "Thousands of Cubic Feet"
func (x ThousandsOfCubicFeetVolume) Name() string {
	return "Thousands of Cubic Feet"
}

// Symbol always returns "MCF"
func (x ThousandsOfCubicFeetVolume) Symbol() string {
	return "MCF"
}

// FromBase converts m³ to MCF
func (x ThousandsOfCubicFeetVolume) FromBase(m3 float64) float64 {
	return m3 * 0.0353147
}

// ToBase converts MCF to m³
func (x ThousandsOfCubicFeetVolume) ToBase(MCF float64) float64 {
	return MCF * 28.3168
}

// ThousandsOfCubicFeetVolumeMatchList is effectively a constant
var ThousandsOfCubicFeetVolumeMatchList = [...]string{"mcf", "mft³", "mf³", "thousandcubicfeet", "thousandsofcubicfeet", "thousandscubicfeet"}

// MatchList always returns ThousandsOfCubicFeetVolumeMatchList[:]
func (x ThousandsOfCubicFeetVolume) MatchList() []string {
	return ThousandsOfCubicFeetVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandsOfCubicFeetVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x ThousandsOfCubicFeetVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x ThousandsOfCubicFeetVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var ThousandsOfCubicFeetVolumeUnit ThousandsOfCubicFeetVolume = 0.0

// ElectricPotential (UnitType)
// Contains 1 units:
//  - VoltsElectricPotential V => V = V
// Base: VoltsElectricPotential
type ElectricPotential float64

// Title always returns "ElectricPotential"
func (x ElectricPotential) Title() string {
	return "ElectricPotential"
}

// Name always returns "Electric Potential"
func (x ElectricPotential) Name() string {
	return "Electric Potential"
}

// Base always returns VoltsElectricPotentialUnit
func (x ElectricPotential) Base() Unit {
	return VoltsElectricPotentialUnit
}

// ElectricPotentialUnits is effectively a constant
var ElectricPotentialUnits = [...]Unit{VoltsElectricPotentialUnit}

// Units always returns ElectricPotentialUnits[:]
func (x ElectricPotential) Units() []Unit {
	return ElectricPotentialUnits[:]
}

// ElectricPotentialUnitList is effectively a constant
var ElectricPotentialUnitList = [...]string{"Volts"}

// UnitList always returns ElectricPotentialUnitList[:]
func (x ElectricPotential) UnitList() []string {
	return ElectricPotentialUnitList[:]
}

// ElectricPotentialMatchList is effectively a constant
var ElectricPotentialMatchList = [...]string{"electricpotential", "voltage"}

// MatchList always returns ElectricPotentialMatchList[:]
func (x ElectricPotential) MatchList() []string {
	return ElectricPotentialMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotential) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ElectricPotentialUnitType ElectricPotential = 0.0

// VoltsElectricPotential (Unit)
// UnitType     : ElectricPotential
// UnitType.Base: VoltsElectricPotential
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type VoltsElectricPotential ElectricPotential

// Title always returns "Volts"
func (x VoltsElectricPotential) Title() string {
	return "Volts"
}

// Name always returns "Volts"
func (x VoltsElectricPotential) Name() string {
	return "Volts"
}

// Symbol always returns "V"
func (x VoltsElectricPotential) Symbol() string {
	return "V"
}

// FromBase converts V to V
func (x VoltsElectricPotential) FromBase(V float64) float64 {
	return V
}

// ToBase converts V to V
func (x VoltsElectricPotential) ToBase(V float64) float64 {
	return V
}

// VoltsElectricPotentialMatchList is effectively a constant
var VoltsElectricPotentialMatchList = [...]string{"volt", "volts", "v"}

// MatchList always returns VoltsElectricPotentialMatchList[:]
func (x VoltsElectricPotential) MatchList() []string {
	return VoltsElectricPotentialMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x VoltsElectricPotential) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ElectricPotentialUnitType
func (x VoltsElectricPotential) TypeOf() UnitType {
	return ElectricPotentialUnitType
}

// Base always returns VoltsElectricPotentialUnit
func (x VoltsElectricPotential) Base() Unit {
	return VoltsElectricPotentialUnit
}

var VoltsElectricPotentialUnit VoltsElectricPotential = 0.0

// ElectricPotentialLoaded (UnitType)
// Contains 1 units:
//  - VoltsElectricPotentialLoaded V => V = V
// Base: VoltsElectricPotentialLoaded
type ElectricPotentialLoaded float64

// Title always returns "ElectricPotentialLoaded"
func (x ElectricPotentialLoaded) Title() string {
	return "ElectricPotentialLoaded"
}

// Name always returns "Electric Potential Loaded"
func (x ElectricPotentialLoaded) Name() string {
	return "Electric Potential Loaded"
}

// Base always returns VoltsElectricPotentialLoadedUnit
func (x ElectricPotentialLoaded) Base() Unit {
	return VoltsElectricPotentialLoadedUnit
}

// ElectricPotentialLoadedUnits is effectively a constant
var ElectricPotentialLoadedUnits = [...]Unit{VoltsElectricPotentialLoadedUnit}

// Units always returns ElectricPotentialLoadedUnits[:]
func (x ElectricPotentialLoaded) Units() []Unit {
	return ElectricPotentialLoadedUnits[:]
}

// ElectricPotentialLoadedUnitList is effectively a constant
var ElectricPotentialLoadedUnitList = [...]string{"Volts"}

// UnitList always returns ElectricPotentialLoadedUnitList[:]
func (x ElectricPotentialLoaded) UnitList() []string {
	return ElectricPotentialLoadedUnitList[:]
}

// ElectricPotentialLoadedMatchList is effectively a constant
var ElectricPotentialLoadedMatchList = [...]string{"electricpotentialloaded", "voltageloaded"}

// MatchList always returns ElectricPotentialLoadedMatchList[:]
func (x ElectricPotentialLoaded) MatchList() []string {
	return ElectricPotentialLoadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotentialLoaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ElectricPotentialLoadedUnitType ElectricPotentialLoaded = 0.0

// VoltsElectricPotentialLoaded (Unit)
// UnitType     : ElectricPotentialLoaded
// UnitType.Base: VoltsElectricPotentialLoaded
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type VoltsElectricPotentialLoaded ElectricPotentialLoaded

// Title always returns "Volts"
func (x VoltsElectricPotentialLoaded) Title() string {
	return "Volts"
}

// Name always returns "Volts"
func (x VoltsElectricPotentialLoaded) Name() string {
	return "Volts"
}

// Symbol always returns "V"
func (x VoltsElectricPotentialLoaded) Symbol() string {
	return "V"
}

// FromBase converts V to V
func (x VoltsElectricPotentialLoaded) FromBase(V float64) float64 {
	return V
}

// ToBase converts V to V
func (x VoltsElectricPotentialLoaded) ToBase(V float64) float64 {
	return V
}

// VoltsElectricPotentialLoadedMatchList is effectively a constant
var VoltsElectricPotentialLoadedMatchList = [...]string{"volt", "volts", "v"}

// MatchList always returns VoltsElectricPotentialLoadedMatchList[:]
func (x VoltsElectricPotentialLoaded) MatchList() []string {
	return VoltsElectricPotentialLoadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x VoltsElectricPotentialLoaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ElectricPotentialLoadedUnitType
func (x VoltsElectricPotentialLoaded) TypeOf() UnitType {
	return ElectricPotentialLoadedUnitType
}

// Base always returns VoltsElectricPotentialLoadedUnit
func (x VoltsElectricPotentialLoaded) Base() Unit {
	return VoltsElectricPotentialLoadedUnit
}

var VoltsElectricPotentialLoadedUnit VoltsElectricPotentialLoaded = 0.0

// ElectricPotentialUnloaded (UnitType)
// Contains 1 units:
//  - VoltsElectricPotentialUnloaded V => V = V
// Base: VoltsElectricPotentialUnloaded
type ElectricPotentialUnloaded float64

// Title always returns "ElectricPotentialUnloaded"
func (x ElectricPotentialUnloaded) Title() string {
	return "ElectricPotentialUnloaded"
}

// Name always returns "Electric Potential Unloaded"
func (x ElectricPotentialUnloaded) Name() string {
	return "Electric Potential Unloaded"
}

// Base always returns VoltsElectricPotentialUnloadedUnit
func (x ElectricPotentialUnloaded) Base() Unit {
	return VoltsElectricPotentialUnloadedUnit
}

// ElectricPotentialUnloadedUnits is effectively a constant
var ElectricPotentialUnloadedUnits = [...]Unit{VoltsElectricPotentialUnloadedUnit}

// Units always returns ElectricPotentialUnloadedUnits[:]
func (x ElectricPotentialUnloaded) Units() []Unit {
	return ElectricPotentialUnloadedUnits[:]
}

// ElectricPotentialUnloadedUnitList is effectively a constant
var ElectricPotentialUnloadedUnitList = [...]string{"Volts"}

// UnitList always returns ElectricPotentialUnloadedUnitList[:]
func (x ElectricPotentialUnloaded) UnitList() []string {
	return ElectricPotentialUnloadedUnitList[:]
}

// ElectricPotentialUnloadedMatchList is effectively a constant
var ElectricPotentialUnloadedMatchList = [...]string{"electricpotentialunloaded", "voltageunloaded"}

// MatchList always returns ElectricPotentialUnloadedMatchList[:]
func (x ElectricPotentialUnloaded) MatchList() []string {
	return ElectricPotentialUnloadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotentialUnloaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ElectricPotentialUnloadedUnitType ElectricPotentialUnloaded = 0.0

// VoltsElectricPotentialUnloaded (Unit)
// UnitType     : ElectricPotentialUnloaded
// UnitType.Base: VoltsElectricPotentialUnloaded
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type VoltsElectricPotentialUnloaded ElectricPotentialUnloaded

// Title always returns "Volts"
func (x VoltsElectricPotentialUnloaded) Title() string {
	return "Volts"
}

// Name always returns "Volts"
func (x VoltsElectricPotentialUnloaded) Name() string {
	return "Volts"
}

// Symbol always returns "V"
func (x VoltsElectricPotentialUnloaded) Symbol() string {
	return "V"
}

// FromBase converts V to V
func (x VoltsElectricPotentialUnloaded) FromBase(V float64) float64 {
	return V
}

// ToBase converts V to V
func (x VoltsElectricPotentialUnloaded) ToBase(V float64) float64 {
	return V
}

// VoltsElectricPotentialUnloadedMatchList is effectively a constant
var VoltsElectricPotentialUnloadedMatchList = [...]string{"volt", "volts", "v"}

// MatchList always returns VoltsElectricPotentialUnloadedMatchList[:]
func (x VoltsElectricPotentialUnloaded) MatchList() []string {
	return VoltsElectricPotentialUnloadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x VoltsElectricPotentialUnloaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ElectricPotentialUnloadedUnitType
func (x VoltsElectricPotentialUnloaded) TypeOf() UnitType {
	return ElectricPotentialUnloadedUnitType
}

// Base always returns VoltsElectricPotentialUnloadedUnit
func (x VoltsElectricPotentialUnloaded) Base() Unit {
	return VoltsElectricPotentialUnloadedUnit
}

var VoltsElectricPotentialUnloadedUnit VoltsElectricPotentialUnloaded = 0.0

// Humidity (UnitType)
// Contains 1 units:
//  - PercentHumidity p => p = %
// Base: PercentHumidity
type Humidity float64

// Title always returns "Humidity"
func (x Humidity) Title() string {
	return "Humidity"
}

// Name always returns "Humidity"
func (x Humidity) Name() string {
	return "Humidity"
}

// Base always returns PercentHumidityUnit
func (x Humidity) Base() Unit {
	return PercentHumidityUnit
}

// HumidityUnits is effectively a constant
var HumidityUnits = [...]Unit{PercentHumidityUnit}

// Units always returns HumidityUnits[:]
func (x Humidity) Units() []Unit {
	return HumidityUnits[:]
}

// HumidityUnitList is effectively a constant
var HumidityUnitList = [...]string{"Percent"}

// UnitList always returns HumidityUnitList[:]
func (x Humidity) UnitList() []string {
	return HumidityUnitList[:]
}

// HumidityMatchList is effectively a constant
var HumidityMatchList = [...]string{"humidity"}

// MatchList always returns HumidityMatchList[:]
func (x Humidity) MatchList() []string {
	return HumidityMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Humidity) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var HumidityUnitType Humidity = 0.0

// PercentHumidity (Unit)
// UnitType     : Humidity
// UnitType.Base: PercentHumidity
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentHumidity Humidity

// Title always returns "Percent"
func (x PercentHumidity) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentHumidity) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentHumidity) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentHumidity) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentHumidity) ToBase(p float64) float64 {
	return p
}

// PercentHumidityMatchList is effectively a constant
var PercentHumidityMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentHumidityMatchList[:]
func (x PercentHumidity) MatchList() []string {
	return PercentHumidityMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentHumidity) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns HumidityUnitType
func (x PercentHumidity) TypeOf() UnitType {
	return HumidityUnitType
}

// Base always returns PercentHumidityUnit
func (x PercentHumidity) Base() Unit {
	return PercentHumidityUnit
}

var PercentHumidityUnit PercentHumidity = 0.0

// Percentage (UnitType)
// Contains 1 units:
//  - PercentPercentage p => p = %
// Base: PercentPercentage
type Percentage float64

// Title always returns "Percentage"
func (x Percentage) Title() string {
	return "Percentage"
}

// Name always returns "Percentage"
func (x Percentage) Name() string {
	return "Percentage"
}

// Base always returns PercentPercentageUnit
func (x Percentage) Base() Unit {
	return PercentPercentageUnit
}

// PercentageUnits is effectively a constant
var PercentageUnits = [...]Unit{PercentPercentageUnit}

// Units always returns PercentageUnits[:]
func (x Percentage) Units() []Unit {
	return PercentageUnits[:]
}

// PercentageUnitList is effectively a constant
var PercentageUnitList = [...]string{"Percent"}

// UnitList always returns PercentageUnitList[:]
func (x Percentage) UnitList() []string {
	return PercentageUnitList[:]
}

// PercentageMatchList is effectively a constant
var PercentageMatchList = [...]string{"percentage"}

// MatchList always returns PercentageMatchList[:]
func (x Percentage) MatchList() []string {
	return PercentageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Percentage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var PercentageUnitType Percentage = 0.0

// PercentPercentage (Unit)
// UnitType     : Percentage
// UnitType.Base: PercentPercentage
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentPercentage Percentage

// Title always returns "Percent"
func (x PercentPercentage) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentPercentage) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentPercentage) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentPercentage) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentPercentage) ToBase(p float64) float64 {
	return p
}

// PercentPercentageMatchList is effectively a constant
var PercentPercentageMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentPercentageMatchList[:]
func (x PercentPercentage) MatchList() []string {
	return PercentPercentageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentPercentage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PercentageUnitType
func (x PercentPercentage) TypeOf() UnitType {
	return PercentageUnitType
}

// Base always returns PercentPercentageUnit
func (x PercentPercentage) Base() Unit {
	return PercentPercentageUnit
}

var PercentPercentageUnit PercentPercentage = 0.0

// Alarm (UnitType)
// Contains 1 units:
//  - PercentAlarm p => p = %
// Base: PercentAlarm
type Alarm float64

// Title always returns "Alarm"
func (x Alarm) Title() string {
	return "Alarm"
}

// Name always returns "Alarm"
func (x Alarm) Name() string {
	return "Alarm"
}

// Base always returns PercentAlarmUnit
func (x Alarm) Base() Unit {
	return PercentAlarmUnit
}

// AlarmUnits is effectively a constant
var AlarmUnits = [...]Unit{PercentAlarmUnit}

// Units always returns AlarmUnits[:]
func (x Alarm) Units() []Unit {
	return AlarmUnits[:]
}

// AlarmUnitList is effectively a constant
var AlarmUnitList = [...]string{"Percent"}

// UnitList always returns AlarmUnitList[:]
func (x Alarm) UnitList() []string {
	return AlarmUnitList[:]
}

// AlarmMatchList is effectively a constant
var AlarmMatchList = [...]string{"alarm"}

// MatchList always returns AlarmMatchList[:]
func (x Alarm) MatchList() []string {
	return AlarmMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Alarm) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var AlarmUnitType Alarm = 0.0

// PercentAlarm (Unit)
// UnitType     : Alarm
// UnitType.Base: PercentAlarm
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentAlarm Alarm

// Title always returns "Percent"
func (x PercentAlarm) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentAlarm) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentAlarm) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentAlarm) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentAlarm) ToBase(p float64) float64 {
	return p
}

// PercentAlarmMatchList is effectively a constant
var PercentAlarmMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentAlarmMatchList[:]
func (x PercentAlarm) MatchList() []string {
	return PercentAlarmMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentAlarm) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns AlarmUnitType
func (x PercentAlarm) TypeOf() UnitType {
	return AlarmUnitType
}

// Base always returns PercentAlarmUnit
func (x PercentAlarm) Base() Unit {
	return PercentAlarmUnit
}

var PercentAlarmUnit PercentAlarm = 0.0

// Work (UnitType)
// Contains 4 units:
//  - JoulesWork                 J => J                         = J
//  - InchPoundsForceWork        J => J * 8.850,74              = in lbf
//  - CubicFeetOfNaturalGasWork  J => J * 0.000,000,947,817     = BTUᵢₜ
//  - BarrelsOfOilEquivalentWork J => J * 0.000,000,000,163,399 = bboe
// Base: JoulesWork
type Work float64

// Title always returns "Work"
func (x Work) Title() string {
	return "Work"
}

// Name always returns "Work"
func (x Work) Name() string {
	return "Work"
}

// Base always returns JoulesWorkUnit
func (x Work) Base() Unit {
	return JoulesWorkUnit
}

// WorkUnits is effectively a constant
var WorkUnits = [...]Unit{JoulesWorkUnit, InchPoundsForceWorkUnit, CubicFeetOfNaturalGasWorkUnit, BarrelsOfOilEquivalentWorkUnit}

// Units always returns WorkUnits[:]
func (x Work) Units() []Unit {
	return WorkUnits[:]
}

// WorkUnitList is effectively a constant
var WorkUnitList = [...]string{"Joules", "Inch-pounds Force", "Cubic Feet of Natural Gas", "Barrels of Oil Equivalent"}

// UnitList always returns WorkUnitList[:]
func (x Work) UnitList() []string {
	return WorkUnitList[:]
}

// WorkMatchList is effectively a constant
var WorkMatchList = [...]string{"work"}

// MatchList always returns WorkMatchList[:]
func (x Work) MatchList() []string {
	return WorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Work) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var WorkUnitType Work = 0.0

// JoulesWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J = J
// Unit.ToBase  : J => J = J
type JoulesWork Work

// Title always returns "Joules"
func (x JoulesWork) Title() string {
	return "Joules"
}

// Name always returns "Joules"
func (x JoulesWork) Name() string {
	return "Joules"
}

// Symbol always returns "J"
func (x JoulesWork) Symbol() string {
	return "J"
}

// FromBase converts J to J
func (x JoulesWork) FromBase(J float64) float64 {
	return J
}

// ToBase converts J to J
func (x JoulesWork) ToBase(J float64) float64 {
	return J
}

// JoulesWorkMatchList is effectively a constant
var JoulesWorkMatchList = [...]string{"j", "joule", "joules"}

// MatchList always returns JoulesWorkMatchList[:]
func (x JoulesWork) MatchList() []string {
	return JoulesWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x JoulesWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x JoulesWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x JoulesWork) Base() Unit {
	return JoulesWorkUnit
}

var JoulesWorkUnit JoulesWork = 0.0

// InchPoundsForceWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 8.850,74          = in lbf
// Unit.ToBase  : inlbf => inlbf * 0.112,985 = J
type InchPoundsForceWork Work

// Title always returns "InchPoundsForce"
func (x InchPoundsForceWork) Title() string {
	return "InchPoundsForce"
}

// Name always returns "Inch-pounds Force"
func (x InchPoundsForceWork) Name() string {
	return "Inch-pounds Force"
}

// Symbol always returns "in lbf"
func (x InchPoundsForceWork) Symbol() string {
	return "in lbf"
}

// FromBase converts J to in lbf
func (x InchPoundsForceWork) FromBase(J float64) float64 {
	return J * 8.85074
}

// ToBase converts in lbf to J
func (x InchPoundsForceWork) ToBase(inlbf float64) float64 {
	return inlbf * 0.112985
}

// InchPoundsForceWorkMatchList is effectively a constant
var InchPoundsForceWorkMatchList = [...]string{"inlbf", "inch-poundsforce", "inch-poundforce", "in-lbf"}

// MatchList always returns InchPoundsForceWorkMatchList[:]
func (x InchPoundsForceWork) MatchList() []string {
	return InchPoundsForceWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchPoundsForceWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x InchPoundsForceWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x InchPoundsForceWork) Base() Unit {
	return JoulesWorkUnit
}

var InchPoundsForceWorkUnit InchPoundsForceWork = 0.0

// CubicFeetOfNaturalGasWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,947,817 = BTUᵢₜ
// Unit.ToBase  : btu => btu * 1,055,060     = J
type CubicFeetOfNaturalGasWork Work

// Title always returns "CubicFeetOfNaturalGas"
func (x CubicFeetOfNaturalGasWork) Title() string {
	return "CubicFeetOfNaturalGas"
}

// Name always returns "Cubic Feet of Natural Gas"
func (x CubicFeetOfNaturalGasWork) Name() string {
	return "Cubic Feet of Natural Gas"
}

// Symbol always returns "BTUᵢₜ"
func (x CubicFeetOfNaturalGasWork) Symbol() string {
	return "BTUᵢₜ"
}

// FromBase converts J to BTUᵢₜ
func (x CubicFeetOfNaturalGasWork) FromBase(J float64) float64 {
	return J * 0.000000947817
}

// ToBase converts BTUᵢₜ to J
func (x CubicFeetOfNaturalGasWork) ToBase(btu float64) float64 {
	return btu * 1055060
}

// CubicFeetOfNaturalGasWorkMatchList is effectively a constant
var CubicFeetOfNaturalGasWorkMatchList = [...]string{"btuᵢₜ", "btuit", "btu", "cubicfeetofnaturalgas"}

// MatchList always returns CubicFeetOfNaturalGasWorkMatchList[:]
func (x CubicFeetOfNaturalGasWork) MatchList() []string {
	return CubicFeetOfNaturalGasWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetOfNaturalGasWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x CubicFeetOfNaturalGasWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x CubicFeetOfNaturalGasWork) Base() Unit {
	return JoulesWorkUnit
}

var CubicFeetOfNaturalGasWorkUnit CubicFeetOfNaturalGasWork = 0.0

// BarrelsOfOilEquivalentWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,000,163,399 = bboe
// Unit.ToBase  : bboe => bboe * 6,120,000,000   = J
type BarrelsOfOilEquivalentWork Work

// Title always returns "BarrelsOfOilEquivalent"
func (x BarrelsOfOilEquivalentWork) Title() string {
	return "BarrelsOfOilEquivalent"
}

// Name always returns "Barrels of Oil Equivalent"
func (x BarrelsOfOilEquivalentWork) Name() string {
	return "Barrels of Oil Equivalent"
}

// Symbol always returns "bboe"
func (x BarrelsOfOilEquivalentWork) Symbol() string {
	return "bboe"
}

// FromBase converts J to bboe
func (x BarrelsOfOilEquivalentWork) FromBase(J float64) float64 {
	return J * 0.000000000163399
}

// ToBase converts bboe to J
func (x BarrelsOfOilEquivalentWork) ToBase(bboe float64) float64 {
	return bboe * 6120000000
}

// BarrelsOfOilEquivalentWorkMatchList is effectively a constant
var BarrelsOfOilEquivalentWorkMatchList = [...]string{"bboe", "barrelsofoilequivalent"}

// MatchList always returns BarrelsOfOilEquivalentWorkMatchList[:]
func (x BarrelsOfOilEquivalentWork) MatchList() []string {
	return BarrelsOfOilEquivalentWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x BarrelsOfOilEquivalentWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x BarrelsOfOilEquivalentWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x BarrelsOfOilEquivalentWork) Base() Unit {
	return JoulesWorkUnit
}

var BarrelsOfOilEquivalentWorkUnit BarrelsOfOilEquivalentWork = 0.0

// Force (UnitType)
// Contains 3 units:
//  - NewtonsForce        N => N             = N
//  - PoundsForceForce    N => N * 0.224,809 = lbf
//  - KilogramsForceForce N => N * 0.101,972 = kgf
// Base: NewtonsForce
type Force float64

// Title always returns "Force"
func (x Force) Title() string {
	return "Force"
}

// Name always returns "Force"
func (x Force) Name() string {
	return "Force"
}

// Base always returns NewtonsForceUnit
func (x Force) Base() Unit {
	return NewtonsForceUnit
}

// ForceUnits is effectively a constant
var ForceUnits = [...]Unit{NewtonsForceUnit, PoundsForceForceUnit, KilogramsForceForceUnit}

// Units always returns ForceUnits[:]
func (x Force) Units() []Unit {
	return ForceUnits[:]
}

// ForceUnitList is effectively a constant
var ForceUnitList = [...]string{"Newtons", "Pounds-force", "Kilograms-force"}

// UnitList always returns ForceUnitList[:]
func (x Force) UnitList() []string {
	return ForceUnitList[:]
}

// ForceMatchList is effectively a constant
var ForceMatchList = [...]string{"force"}

// MatchList always returns ForceMatchList[:]
func (x Force) MatchList() []string {
	return ForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Force) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ForceUnitType Force = 0.0

// NewtonsForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type NewtonsForce Force

// Title always returns "Newtons"
func (x NewtonsForce) Title() string {
	return "Newtons"
}

// Name always returns "Newtons"
func (x NewtonsForce) Name() string {
	return "Newtons"
}

// Symbol always returns "N"
func (x NewtonsForce) Symbol() string {
	return "N"
}

// FromBase converts N to N
func (x NewtonsForce) FromBase(N float64) float64 {
	return N
}

// ToBase converts N to N
func (x NewtonsForce) ToBase(N float64) float64 {
	return N
}

// NewtonsForceMatchList is effectively a constant
var NewtonsForceMatchList = [...]string{"n", "newton", "newtons"}

// MatchList always returns NewtonsForceMatchList[:]
func (x NewtonsForce) MatchList() []string {
	return NewtonsForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NewtonsForce) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ForceUnitType
func (x NewtonsForce) TypeOf() UnitType {
	return ForceUnitType
}

// Base always returns NewtonsForceUnit
func (x NewtonsForce) Base() Unit {
	return NewtonsForceUnit
}

var NewtonsForceUnit NewtonsForce = 0.0

// PoundsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForceForce Force

// Title always returns "PoundsForce"
func (x PoundsForceForce) Title() string {
	return "PoundsForce"
}

// Name always returns "Pounds-force"
func (x PoundsForceForce) Name() string {
	return "Pounds-force"
}

// Symbol always returns "lbf"
func (x PoundsForceForce) Symbol() string {
	return "lbf"
}

// FromBase converts N to lbf
func (x PoundsForceForce) FromBase(N float64) float64 {
	return N * 0.224809
}

// ToBase converts lbf to N
func (x PoundsForceForce) ToBase(lbf float64) float64 {
	return lbf * 4.44822
}

// PoundsForceForceMatchList is effectively a constant
var PoundsForceForceMatchList = [...]string{"lbf", "pounds-force", "poundsforce", "pound-force", "poundforce"}

// MatchList always returns PoundsForceForceMatchList[:]
func (x PoundsForceForce) MatchList() []string {
	return PoundsForceForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForceForce) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ForceUnitType
func (x PoundsForceForce) TypeOf() UnitType {
	return ForceUnitType
}

// Base always returns NewtonsForceUnit
func (x PoundsForceForce) Base() Unit {
	return NewtonsForceUnit
}

var PoundsForceForceUnit PoundsForceForce = 0.0

// KilogramsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForceForce Force

// Title always returns "KilogramsForce"
func (x KilogramsForceForce) Title() string {
	return "KilogramsForce"
}

// Name always returns "Kilograms-force"
func (x KilogramsForceForce) Name() string {
	return "Kilograms-force"
}

// Symbol always returns "kgf"
func (x KilogramsForceForce) Symbol() string {
	return "kgf"
}

// FromBase converts N to kgf
func (x KilogramsForceForce) FromBase(N float64) float64 {
	return N * 0.101972
}

// ToBase converts kgf to N
func (x KilogramsForceForce) ToBase(kgf float64) float64 {
	return kgf * 9.80665
}

// KilogramsForceForceMatchList is effectively a constant
var KilogramsForceForceMatchList = [...]string{"kgf", "kilograms-force", "kilogram-force"}

// MatchList always returns KilogramsForceForceMatchList[:]
func (x KilogramsForceForce) MatchList() []string {
	return KilogramsForceForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForceForce) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ForceUnitType
func (x KilogramsForceForce) TypeOf() UnitType {
	return ForceUnitType
}

// Base always returns NewtonsForceUnit
func (x KilogramsForceForce) Base() Unit {
	return NewtonsForceUnit
}

var KilogramsForceForceUnit KilogramsForceForce = 0.0

// Length (UnitType)
// Contains 3 units:
//  - MetersLength m => m            = m
//  - FeetLength   m => m * 3.280,84 = ft
//  - InchesLength m => m * 39.370,1 = in
// Base: MetersLength
type Length float64

// Title always returns "Length"
func (x Length) Title() string {
	return "Length"
}

// Name always returns "Length"
func (x Length) Name() string {
	return "Length"
}

// Base always returns MetersLengthUnit
func (x Length) Base() Unit {
	return MetersLengthUnit
}

// LengthUnits is effectively a constant
var LengthUnits = [...]Unit{MetersLengthUnit, FeetLengthUnit, InchesLengthUnit}

// Units always returns LengthUnits[:]
func (x Length) Units() []Unit {
	return LengthUnits[:]
}

// LengthUnitList is effectively a constant
var LengthUnitList = [...]string{"Meters", "Feet", "Inches"}

// UnitList always returns LengthUnitList[:]
func (x Length) UnitList() []string {
	return LengthUnitList[:]
}

// LengthMatchList is effectively a constant
var LengthMatchList = [...]string{"l", "length"}

// MatchList always returns LengthMatchList[:]
func (x Length) MatchList() []string {
	return LengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Length) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var LengthUnitType Length = 0.0

// MetersLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m
type MetersLength Length

// Title always returns "Meters"
func (x MetersLength) Title() string {
	return "Meters"
}

// Name always returns "Meters"
func (x MetersLength) Name() string {
	return "Meters"
}

// Symbol always returns "m"
func (x MetersLength) Symbol() string {
	return "m"
}

// FromBase converts m to m
func (x MetersLength) FromBase(m float64) float64 {
	return m
}

// ToBase converts m to m
func (x MetersLength) ToBase(m float64) float64 {
	return m
}

// MetersLengthMatchList is effectively a constant
var MetersLengthMatchList = [...]string{"m", "meter", "meters"}

// MatchList always returns MetersLengthMatchList[:]
func (x MetersLength) MatchList() []string {
	return MetersLengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MetersLength) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LengthUnitType
func (x MetersLength) TypeOf() UnitType {
	return LengthUnitType
}

// Base always returns MetersLengthUnit
func (x MetersLength) Base() Unit {
	return MetersLengthUnit
}

var MetersLengthUnit MetersLength = 0.0

// FeetLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m
type FeetLength Length

// Title always returns "Feet"
func (x FeetLength) Title() string {
	return "Feet"
}

// Name always returns "Feet"
func (x FeetLength) Name() string {
	return "Feet"
}

// Symbol always returns "ft"
func (x FeetLength) Symbol() string {
	return "ft"
}

// FromBase converts m to ft
func (x FeetLength) FromBase(m float64) float64 {
	return m * 3.28084
}

// ToBase converts ft to m
func (x FeetLength) ToBase(ft float64) float64 {
	return ft * 0.304800
}

// FeetLengthMatchList is effectively a constant
var FeetLengthMatchList = [...]string{"ft", "foot", "feet"}

// MatchList always returns FeetLengthMatchList[:]
func (x FeetLength) MatchList() []string {
	return FeetLengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x FeetLength) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LengthUnitType
func (x FeetLength) TypeOf() UnitType {
	return LengthUnitType
}

// Base always returns MetersLengthUnit
func (x FeetLength) Base() Unit {
	return MetersLengthUnit
}

var FeetLengthUnit FeetLength = 0.0

// InchesLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m
type InchesLength Length

// Title always returns "Inches"
func (x InchesLength) Title() string {
	return "Inches"
}

// Name always returns "Inches"
func (x InchesLength) Name() string {
	return "Inches"
}

// Symbol always returns "in"
func (x InchesLength) Symbol() string {
	return "in"
}

// FromBase converts m to in
func (x InchesLength) FromBase(m float64) float64 {
	return m * 39.3701
}

// ToBase converts in to m
func (x InchesLength) ToBase(in float64) float64 {
	return in * 0.0254000
}

// InchesLengthMatchList is effectively a constant
var InchesLengthMatchList = [...]string{"in", "inch", "inches"}

// MatchList always returns InchesLengthMatchList[:]
func (x InchesLength) MatchList() []string {
	return InchesLengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesLength) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LengthUnitType
func (x InchesLength) TypeOf() UnitType {
	return LengthUnitType
}

// Base always returns MetersLengthUnit
func (x InchesLength) Base() Unit {
	return MetersLengthUnit
}

var InchesLengthUnit InchesLength = 0.0

// StrokeRate (UnitType)
// Contains 1 units:
//  - StrokesPerSecondStrokeRate ss => ss = strokes/s
// Base: StrokesPerSecondStrokeRate
type StrokeRate float64

// Title always returns "StrokeRate"
func (x StrokeRate) Title() string {
	return "StrokeRate"
}

// Name always returns "Stroke Rate"
func (x StrokeRate) Name() string {
	return "Stroke Rate"
}

// Base always returns StrokesPerSecondStrokeRateUnit
func (x StrokeRate) Base() Unit {
	return StrokesPerSecondStrokeRateUnit
}

// StrokeRateUnits is effectively a constant
var StrokeRateUnits = [...]Unit{StrokesPerSecondStrokeRateUnit}

// Units always returns StrokeRateUnits[:]
func (x StrokeRate) Units() []Unit {
	return StrokeRateUnits[:]
}

// StrokeRateUnitList is effectively a constant
var StrokeRateUnitList = [...]string{"Strokes per Second"}

// UnitList always returns StrokeRateUnitList[:]
func (x StrokeRate) UnitList() []string {
	return StrokeRateUnitList[:]
}

// StrokeRateMatchList is effectively a constant
var StrokeRateMatchList = [...]string{"strokerate", "stroke-rate"}

// MatchList always returns StrokeRateMatchList[:]
func (x StrokeRate) MatchList() []string {
	return StrokeRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokeRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var StrokeRateUnitType StrokeRate = 0.0

// StrokesPerSecondStrokeRate (Unit)
// UnitType     : StrokeRate
// UnitType.Base: StrokesPerSecondStrokeRate
// Unit.FromBase: ss => ss = strokes/s
// Unit.ToBase  : ss => ss = strokes/s
type StrokesPerSecondStrokeRate StrokeRate

// Title always returns "StrokesPerSecond"
func (x StrokesPerSecondStrokeRate) Title() string {
	return "StrokesPerSecond"
}

// Name always returns "Strokes per Second"
func (x StrokesPerSecondStrokeRate) Name() string {
	return "Strokes per Second"
}

// Symbol always returns "strokes/s"
func (x StrokesPerSecondStrokeRate) Symbol() string {
	return "strokes/s"
}

// FromBase converts strokes/s to strokes/s
func (x StrokesPerSecondStrokeRate) FromBase(ss float64) float64 {
	return ss
}

// ToBase converts strokes/s to strokes/s
func (x StrokesPerSecondStrokeRate) ToBase(ss float64) float64 {
	return ss
}

// StrokesPerSecondStrokeRateMatchList is effectively a constant
var StrokesPerSecondStrokeRateMatchList = [...]string{"strokes/s", "strokespersecond", "s/s"}

// MatchList always returns StrokesPerSecondStrokeRateMatchList[:]
func (x StrokesPerSecondStrokeRate) MatchList() []string {
	return StrokesPerSecondStrokeRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokesPerSecondStrokeRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns StrokeRateUnitType
func (x StrokesPerSecondStrokeRate) TypeOf() UnitType {
	return StrokeRateUnitType
}

// Base always returns StrokesPerSecondStrokeRateUnit
func (x StrokesPerSecondStrokeRate) Base() Unit {
	return StrokesPerSecondStrokeRateUnit
}

var StrokesPerSecondStrokeRateUnit StrokesPerSecondStrokeRate = 0.0

// Overspeed (UnitType)
// Contains 1 units:
//  - NumberOverspeed n => n =
// Base: NumberOverspeed
type Overspeed float64

// Title always returns "Overspeed"
func (x Overspeed) Title() string {
	return "Overspeed"
}

// Name always returns "Overspeed"
func (x Overspeed) Name() string {
	return "Overspeed"
}

// Base always returns NumberOverspeedUnit
func (x Overspeed) Base() Unit {
	return NumberOverspeedUnit
}

// OverspeedUnits is effectively a constant
var OverspeedUnits = [...]Unit{NumberOverspeedUnit}

// Units always returns OverspeedUnits[:]
func (x Overspeed) Units() []Unit {
	return OverspeedUnits[:]
}

// OverspeedUnitList is effectively a constant
var OverspeedUnitList = [...]string{"Number"}

// UnitList always returns OverspeedUnitList[:]
func (x Overspeed) UnitList() []string {
	return OverspeedUnitList[:]
}

// OverspeedMatchList is effectively a constant
var OverspeedMatchList = [...]string{"overspeed"}

// MatchList always returns OverspeedMatchList[:]
func (x Overspeed) MatchList() []string {
	return OverspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Overspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var OverspeedUnitType Overspeed = 0.0

// NumberOverspeed (Unit)
// UnitType     : Overspeed
// UnitType.Base: NumberOverspeed
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberOverspeed Overspeed

// Title always returns "Number"
func (x NumberOverspeed) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberOverspeed) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberOverspeed) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberOverspeed) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberOverspeed) ToBase(n float64) float64 {
	return n
}

// NumberOverspeedMatchList is effectively a constant
var NumberOverspeedMatchList = [...]string{"number", "*"}

// MatchList always returns NumberOverspeedMatchList[:]
func (x NumberOverspeed) MatchList() []string {
	return NumberOverspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberOverspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns OverspeedUnitType
func (x NumberOverspeed) TypeOf() UnitType {
	return OverspeedUnitType
}

// Base always returns NumberOverspeedUnit
func (x NumberOverspeed) Base() Unit {
	return NumberOverspeedUnit
}

var NumberOverspeedUnit NumberOverspeed = 0.0

// Underspeed (UnitType)
// Contains 1 units:
//  - NumberUnderspeed n => n =
// Base: NumberUnderspeed
type Underspeed float64

// Title always returns "Underspeed"
func (x Underspeed) Title() string {
	return "Underspeed"
}

// Name always returns "Underspeed"
func (x Underspeed) Name() string {
	return "Underspeed"
}

// Base always returns NumberUnderspeedUnit
func (x Underspeed) Base() Unit {
	return NumberUnderspeedUnit
}

// UnderspeedUnits is effectively a constant
var UnderspeedUnits = [...]Unit{NumberUnderspeedUnit}

// Units always returns UnderspeedUnits[:]
func (x Underspeed) Units() []Unit {
	return UnderspeedUnits[:]
}

// UnderspeedUnitList is effectively a constant
var UnderspeedUnitList = [...]string{"Number"}

// UnitList always returns UnderspeedUnitList[:]
func (x Underspeed) UnitList() []string {
	return UnderspeedUnitList[:]
}

// UnderspeedMatchList is effectively a constant
var UnderspeedMatchList = [...]string{"underspeed"}

// MatchList always returns UnderspeedMatchList[:]
func (x Underspeed) MatchList() []string {
	return UnderspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Underspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var UnderspeedUnitType Underspeed = 0.0

// NumberUnderspeed (Unit)
// UnitType     : Underspeed
// UnitType.Base: NumberUnderspeed
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberUnderspeed Underspeed

// Title always returns "Number"
func (x NumberUnderspeed) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberUnderspeed) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberUnderspeed) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberUnderspeed) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberUnderspeed) ToBase(n float64) float64 {
	return n
}

// NumberUnderspeedMatchList is effectively a constant
var NumberUnderspeedMatchList = [...]string{"number", "*"}

// MatchList always returns NumberUnderspeedMatchList[:]
func (x NumberUnderspeed) MatchList() []string {
	return NumberUnderspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberUnderspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns UnderspeedUnitType
func (x NumberUnderspeed) TypeOf() UnitType {
	return UnderspeedUnitType
}

// Base always returns NumberUnderspeedUnit
func (x NumberUnderspeed) Base() Unit {
	return NumberUnderspeedUnit
}

var NumberUnderspeedUnit NumberUnderspeed = 0.0

// Totaliser (UnitType)
// Contains 1 units:
//  - NumberTotaliser n => n =
// Base: NumberTotaliser
type Totaliser float64

// Title always returns "Totaliser"
func (x Totaliser) Title() string {
	return "Totaliser"
}

// Name always returns "Totaliser"
func (x Totaliser) Name() string {
	return "Totaliser"
}

// Base always returns NumberTotaliserUnit
func (x Totaliser) Base() Unit {
	return NumberTotaliserUnit
}

// TotaliserUnits is effectively a constant
var TotaliserUnits = [...]Unit{NumberTotaliserUnit}

// Units always returns TotaliserUnits[:]
func (x Totaliser) Units() []Unit {
	return TotaliserUnits[:]
}

// TotaliserUnitList is effectively a constant
var TotaliserUnitList = [...]string{"Number"}

// UnitList always returns TotaliserUnitList[:]
func (x Totaliser) UnitList() []string {
	return TotaliserUnitList[:]
}

// TotaliserMatchList is effectively a constant
var TotaliserMatchList = [...]string{"totaliser"}

// MatchList always returns TotaliserMatchList[:]
func (x Totaliser) MatchList() []string {
	return TotaliserMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Totaliser) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var TotaliserUnitType Totaliser = 0.0

// NumberTotaliser (Unit)
// UnitType     : Totaliser
// UnitType.Base: NumberTotaliser
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberTotaliser Totaliser

// Title always returns "Number"
func (x NumberTotaliser) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberTotaliser) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberTotaliser) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberTotaliser) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberTotaliser) ToBase(n float64) float64 {
	return n
}

// NumberTotaliserMatchList is effectively a constant
var NumberTotaliserMatchList = [...]string{"number", "*"}

// MatchList always returns NumberTotaliserMatchList[:]
func (x NumberTotaliser) MatchList() []string {
	return NumberTotaliserMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberTotaliser) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TotaliserUnitType
func (x NumberTotaliser) TypeOf() UnitType {
	return TotaliserUnitType
}

// Base always returns NumberTotaliserUnit
func (x NumberTotaliser) Base() Unit {
	return NumberTotaliserUnit
}

var NumberTotaliserUnit NumberTotaliser = 0.0

// WMLFlowRate (UnitType)
// Contains 1 units:
//  - NumberWMLFlowRate n => n =
// Base: NumberWMLFlowRate
type WMLFlowRate float64

// Title always returns "WMLFlowRate"
func (x WMLFlowRate) Title() string {
	return "WMLFlowRate"
}

// Name always returns "WML Flow Rate"
func (x WMLFlowRate) Name() string {
	return "WML Flow Rate"
}

// Base always returns NumberWMLFlowRateUnit
func (x WMLFlowRate) Base() Unit {
	return NumberWMLFlowRateUnit
}

// WMLFlowRateUnits is effectively a constant
var WMLFlowRateUnits = [...]Unit{NumberWMLFlowRateUnit}

// Units always returns WMLFlowRateUnits[:]
func (x WMLFlowRate) Units() []Unit {
	return WMLFlowRateUnits[:]
}

// WMLFlowRateUnitList is effectively a constant
var WMLFlowRateUnitList = [...]string{"Number"}

// UnitList always returns WMLFlowRateUnitList[:]
func (x WMLFlowRate) UnitList() []string {
	return WMLFlowRateUnitList[:]
}

// WMLFlowRateMatchList is effectively a constant
var WMLFlowRateMatchList = [...]string{"wmlflowrate"}

// MatchList always returns WMLFlowRateMatchList[:]
func (x WMLFlowRate) MatchList() []string {
	return WMLFlowRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x WMLFlowRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var WMLFlowRateUnitType WMLFlowRate = 0.0

// NumberWMLFlowRate (Unit)
// UnitType     : WMLFlowRate
// UnitType.Base: NumberWMLFlowRate
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberWMLFlowRate WMLFlowRate

// Title always returns "Number"
func (x NumberWMLFlowRate) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberWMLFlowRate) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberWMLFlowRate) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberWMLFlowRate) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberWMLFlowRate) ToBase(n float64) float64 {
	return n
}

// NumberWMLFlowRateMatchList is effectively a constant
var NumberWMLFlowRateMatchList = [...]string{"number", "*"}

// MatchList always returns NumberWMLFlowRateMatchList[:]
func (x NumberWMLFlowRate) MatchList() []string {
	return NumberWMLFlowRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberWMLFlowRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WMLFlowRateUnitType
func (x NumberWMLFlowRate) TypeOf() UnitType {
	return WMLFlowRateUnitType
}

// Base always returns NumberWMLFlowRateUnit
func (x NumberWMLFlowRate) Base() Unit {
	return NumberWMLFlowRateUnit
}

var NumberWMLFlowRateUnit NumberWMLFlowRate = 0.0

// Number (UnitType)
// Contains 1 units:
//  - NumberNumber n => n =
// Base: NumberNumber
type Number float64

// Title always returns "Number"
func (x Number) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x Number) Name() string {
	return "Number"
}

// Base always returns NumberNumberUnit
func (x Number) Base() Unit {
	return NumberNumberUnit
}

// NumberUnits is effectively a constant
var NumberUnits = [...]Unit{NumberNumberUnit}

// Units always returns NumberUnits[:]
func (x Number) Units() []Unit {
	return NumberUnits[:]
}

// NumberUnitList is effectively a constant
var NumberUnitList = [...]string{"Number"}

// UnitList always returns NumberUnitList[:]
func (x Number) UnitList() []string {
	return NumberUnitList[:]
}

// NumberMatchList is effectively a constant
var NumberMatchList = [...]string{"*"}

// MatchList always returns NumberMatchList[:]
func (x Number) MatchList() []string {
	return NumberMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Number) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var NumberUnitType Number = 0.0

// NumberNumber (Unit)
// UnitType     : Number
// UnitType.Base: NumberNumber
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberNumber Number

// Title always returns "Number"
func (x NumberNumber) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberNumber) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberNumber) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberNumber) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberNumber) ToBase(n float64) float64 {
	return n
}

// NumberNumberMatchList is effectively a constant
var NumberNumberMatchList = [...]string{"number", "*"}

// MatchList always returns NumberNumberMatchList[:]
func (x NumberNumber) MatchList() []string {
	return NumberNumberMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberNumber) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns NumberUnitType
func (x NumberNumber) TypeOf() UnitType {
	return NumberUnitType
}

// Base always returns NumberNumberUnit
func (x NumberNumber) Base() Unit {
	return NumberNumberUnit
}

var NumberNumberUnit NumberNumber = 0.0
