// Package units provides a standard way of working with unit for
// Alaka and Alakans alike. It's automatically generated via a
// .yaml file with a format that makes it really easy to add new
// units. Because we use code generation, we can provide functions
// that are super fast by using explicit values without the work
// of hand copying hundreds of methods across a bunch of permutations
// of the same thing.
//
// All the primary UnitTypes and Units of this package are built
// directly on the float64 construct. This allows go users to treat
// scalars as the Unit or UnitType that they actually represent,
// including the ability to use those type definitions as guards in
// functions that depend on a particular Unit or UnitType. Eg.:
//
// func AddPressure (p1, p2 PascalsPressure) PascalsPressure {
//     returns p1 + p2
// }
package units

import (
	"regexp"
	"strings"
)

// File autogenerated on 2022-03-30 12:49:37.990693739 -0500 CDT m=+0.000911949.
// Do not edit directly

// Unit represents a scalar type of unit which can be converted to and from a base
type Unit interface {
	// Title is used for code interfaces
	Title() string
	// Name is used for displays
	Name() string
	// Symbol is the symbol of the unit and can be displayed beside scalars
	Symbol() string
	// FromBase converts the given number of the unit type base to this unit
	FromBase(float64) float64
	// ToBase converts the given number of this unit type to the base unit
	ToBase(float64) float64
	// MatchList is a list of matching strings which should represent this unit in userland
	MatchList() []string
	// Matches compares a string to a switch of all possible matches
	Matches(string) bool
	// TypeOf returns the UnitType of this unit. You can access the BaseUnit from there
	TypeOf() UnitType
	// Base returns the base Unit of this UnitType directly
	Base() Unit
}

// UnitType represents a collection of related units
type UnitType interface {
	// Title is used for code interfaces
	Title() string
	// Name is used for displays
	Name() string
	// Base returns the primary unit of this unit type that is stored in Alaka.
	// Most of the time this is an SI unit, but not always (temperature is C,
	// not K, for example)
	Base() Unit
	// Units returns all the supported units of this unit type
	Units() []Unit
	// UnitList returns all the supported units of this unit type as strings
	UnitList() []string
	// MatchList is a list of matching strings which should represent this unit type in userland
	MatchList() []string
	// Matches compares a string to a switch of all possible matches
	Matches(string) bool
}

var WhitespaceRegex = regexp.MustCompile(`\s`)

// SanitizeString removes whitespace and lower cases the string
func SanitizeString(input string) string {
	out := strings.ToLower(input)
	out = WhitespaceRegex.ReplaceAllString(out, "")
	return out
}

// AlakaTitle returns the Alaka string representing this particular unit and unit type combo
func AlakaTitle(ut UnitType, u Unit) string {
	return ut.Title() + "_" + u.Title()
}

// AllTypes is a list of all available types below
var AllTypes = [...]string{
	"Pressure",
	"Temperature",
	"Flow",
	"Volume",
	"Mass",
	"MassFlow",
	"ElectricPotential",
	"ElectricPotentialLoaded",
	"ElectricPotentialUnloaded",
	"Percentage",
	"Fillage",
	"PumpFillage",
	"Humidity",
	"Alarm",
	"Work",
	"Force",
	"Load",
	"MaxLoad",
	"MinLoad",
	"FluidLoad",
	"Length",
	"Stroke",
	"GrossStroke",
	"NetStroke",
	"StrokeRate",
	"Number",
	"Overspeed",
	"Underspeed",
	"Totaliser",
	"WMLFlowRate",
}

// AllUnits is a map of unit type -> units
var AllUnits = map[string][]string{
	"Pressure":                  {"Pascals", "Kilopascals", "Megapascals", "PoundsPerSquareInch", "InchesOfWater"},
	"Temperature":               {"DegreesCelsius", "DegreesFahrenheit", "Kelvins"},
	"Flow":                      {"CubicMetersPerSecond", "CubicFeetPerSecond", "ThousandCubicFeetPerDay", "GallonsUSFluidPerSecond", "GallonsUSFluidPerMinute", "BarrelsPerSecond", "BarrelsPerMinute"},
	"Volume":                    {"CubicMeters", "CubicFeet", "ThousandsOfCubicFeet", "CubicDecimeter", "Liter", "GallonUSFluid", "BarrelsOfOil"},
	"Mass":                      {"Kilograms", "Pounds"},
	"MassFlow":                  {"KilogramsPerSecond", "PoundsPerSecond", "PoundsPerMinute"},
	"ElectricPotential":         {"Volts"},
	"ElectricPotentialLoaded":   {"Volts"},
	"ElectricPotentialUnloaded": {"Volts"},
	"Percentage":                {"Percent"},
	"Fillage":                   {"Percent"},
	"PumpFillage":               {"Percent"},
	"Humidity":                  {"Percent"},
	"Alarm":                     {"Percent"},
	"Work":                      {"Joules", "InchPoundsForce", "CubicFeetOfNaturalGas", "BarrelsOfOilEquivalent"},
	"Force":                     {"Newtons", "PoundsForce", "KilogramsForce"},
	"Load":                      {"Newtons", "PoundsForce", "KilogramsForce"},
	"MaxLoad":                   {"Newtons", "PoundsForce", "KilogramsForce"},
	"MinLoad":                   {"Newtons", "PoundsForce", "KilogramsForce"},
	"FluidLoad":                 {"Newtons", "PoundsForce", "KilogramsForce"},
	"Length":                    {"Meters", "Feet", "Inches"},
	"Stroke":                    {"Meters", "Feet", "Inches"},
	"GrossStroke":               {"Meters", "Feet", "Inches"},
	"NetStroke":                 {"Meters", "Feet", "Inches"},
	"StrokeRate":                {"StrokesPerSecond"},
	"Number":                    {"Number"},
	"Overspeed":                 {"Number"},
	"Underspeed":                {"Number"},
	"Totaliser":                 {"Number"},
	"WMLFlowRate":               {"Number"},
}

// AllUnitTypes is a list of all available Unit and Type combos below
// AKA the list of all possible output combinations of AlakaTitle
var AllUnitTypes = [...]string{
	"Pressure_Pascals",
	"Pressure_Kilopascals",
	"Pressure_Megapascals",
	"Pressure_PoundsPerSquareInch",
	"Pressure_InchesOfWater",
	"Temperature_DegreesCelsius",
	"Temperature_DegreesFahrenheit",
	"Temperature_Kelvins",
	"Flow_CubicMetersPerSecond",
	"Flow_CubicFeetPerSecond",
	"Flow_ThousandCubicFeetPerDay",
	"Flow_GallonsUSFluidPerSecond",
	"Flow_GallonsUSFluidPerMinute",
	"Flow_BarrelsPerSecond",
	"Flow_BarrelsPerMinute",
	"Volume_CubicMeters",
	"Volume_CubicFeet",
	"Volume_ThousandsOfCubicFeet",
	"Volume_CubicDecimeter",
	"Volume_Liter",
	"Volume_GallonUSFluid",
	"Volume_BarrelsOfOil",
	"Mass_Kilograms",
	"Mass_Pounds",
	"MassFlow_KilogramsPerSecond",
	"MassFlow_PoundsPerSecond",
	"MassFlow_PoundsPerMinute",
	"ElectricPotential_Volts",
	"ElectricPotentialLoaded_Volts",
	"ElectricPotentialUnloaded_Volts",
	"Percentage_Percent",
	"Fillage_Percent",
	"PumpFillage_Percent",
	"Humidity_Percent",
	"Alarm_Percent",
	"Work_Joules",
	"Work_InchPoundsForce",
	"Work_CubicFeetOfNaturalGas",
	"Work_BarrelsOfOilEquivalent",
	"Force_Newtons",
	"Force_PoundsForce",
	"Force_KilogramsForce",
	"Load_Newtons",
	"Load_PoundsForce",
	"Load_KilogramsForce",
	"MaxLoad_Newtons",
	"MaxLoad_PoundsForce",
	"MaxLoad_KilogramsForce",
	"MinLoad_Newtons",
	"MinLoad_PoundsForce",
	"MinLoad_KilogramsForce",
	"FluidLoad_Newtons",
	"FluidLoad_PoundsForce",
	"FluidLoad_KilogramsForce",
	"Length_Meters",
	"Length_Feet",
	"Length_Inches",
	"Stroke_Meters",
	"Stroke_Feet",
	"Stroke_Inches",
	"GrossStroke_Meters",
	"GrossStroke_Feet",
	"GrossStroke_Inches",
	"NetStroke_Meters",
	"NetStroke_Feet",
	"NetStroke_Inches",
	"StrokeRate_StrokesPerSecond",
	"Number_Number",
	"Overspeed_Number",
	"Underspeed_Number",
	"Totaliser_Number",
	"WMLFlowRate_Number",
}

// GetType returns the unit type which matches input or NumberUnitType
func GetType(input string) UnitType {
	switch SanitizeString(input) {
	case "pressure":
		return PressureUnitType
	case "temperature":
		return TemperatureUnitType
	case "temp":
		return TemperatureUnitType
	case "flow":
		return FlowUnitType
	case "flowrate":
		return FlowUnitType
	case "flow_rate":
		return FlowUnitType
	case "gasflow":
		return FlowUnitType
	case "gasflowrate":
		return FlowUnitType
	case "gas_flow":
		return FlowUnitType
	case "gas_flow_rate":
		return FlowUnitType
	case "volume":
		return VolumeUnitType
	case "mass":
		return MassUnitType
	case "massflow":
		return MassFlowUnitType
	case "massflowrate":
		return MassFlowUnitType
	case "flow(mass)":
		return MassFlowUnitType
	case "flowrate(mass)":
		return MassFlowUnitType
	case "electricpotential":
		return ElectricPotentialUnitType
	case "voltage":
		return ElectricPotentialUnitType
	case "electricpotentialloaded":
		return ElectricPotentialLoadedUnitType
	case "voltageloaded":
		return ElectricPotentialLoadedUnitType
	case "electricpotentialunloaded":
		return ElectricPotentialUnloadedUnitType
	case "voltageunloaded":
		return ElectricPotentialUnloadedUnitType
	case "percentage":
		return PercentageUnitType
	case "fillage":
		return FillageUnitType
	case "pumpfillage":
		return PumpFillageUnitType
	case "humidity":
		return HumidityUnitType
	case "alarm":
		return AlarmUnitType
	case "work":
		return WorkUnitType
	case "force":
		return ForceUnitType
	case "load":
		return LoadUnitType
	case "maxload":
		return MaxLoadUnitType
	case "minload":
		return MinLoadUnitType
	case "fluidload":
		return FluidLoadUnitType
	case "l":
		return LengthUnitType
	case "length":
		return LengthUnitType
	case "stroke":
		return StrokeUnitType
	case "grossstroke":
		return GrossStrokeUnitType
	case "netstroke":
		return NetStrokeUnitType
	case "strokerate":
		return StrokeRateUnitType
	case "stroke-rate":
		return StrokeRateUnitType
	case "*":
		return NumberUnitType
	case "overspeed":
		return OverspeedUnitType
	case "underspeed":
		return UnderspeedUnitType
	case "totaliser":
		return TotaliserUnitType
	case "wmlflowrate":
		return WMLFlowRateUnitType
	default:
		return NumberUnitType
	}
}

// GetUnit returns the unit which matches input or NumberNumberUnit
func GetUnit(input string, typeOf UnitType) Unit {
	search := typeOf.Title() + "->" + SanitizeString(input)
	switch search {
	case "Pressure->pa":
		return PascalsPressureUnit
	case "Pressure->pascal":
		return PascalsPressureUnit
	case "Pressure->pascals":
		return PascalsPressureUnit
	case "Pressure->kpa":
		return KilopascalsPressureUnit
	case "Pressure->kilopascal":
		return KilopascalsPressureUnit
	case "Pressure->kilopascals":
		return KilopascalsPressureUnit
	case "Pressure->mpa":
		return MegapascalsPressureUnit
	case "Pressure->megapascal":
		return MegapascalsPressureUnit
	case "Pressure->megapascals":
		return MegapascalsPressureUnit
	case "Pressure->psi":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->poundspersquareinch":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->poundpersquareinch":
		return PoundsPerSquareInchPressureUnit
	case "Pressure->inh₂o":
		return InchesOfWaterPressureUnit
	case "Pressure->inh₂0":
		return InchesOfWaterPressureUnit
	case "Pressure->inh2o":
		return InchesOfWaterPressureUnit
	case "Pressure->inh20":
		return InchesOfWaterPressureUnit
	case "Pressure->incheswater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchesofwater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchwater":
		return InchesOfWaterPressureUnit
	case "Pressure->inchofwater":
		return InchesOfWaterPressureUnit
	case "Temperature->c":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->°c":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->celsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreesc":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreec":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreescelsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->degreecelsius":
		return DegreesCelsiusTemperatureUnit
	case "Temperature->f":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->°f":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->fahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreesf":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreef":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreesfahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->degreefahrenheit":
		return DegreesFahrenheitTemperatureUnit
	case "Temperature->k":
		return KelvinsTemperatureUnit
	case "Temperature->°k":
		return KelvinsTemperatureUnit
	case "Temperature->kelvin":
		return KelvinsTemperatureUnit
	case "Temperature->kelvins":
		return KelvinsTemperatureUnit
	case "Temperature->degreesk":
		return KelvinsTemperatureUnit
	case "Temperature->degreek":
		return KelvinsTemperatureUnit
	case "Temperature->degreeskelvin":
		return KelvinsTemperatureUnit
	case "Temperature->degreekelvin":
		return KelvinsTemperatureUnit
	case "Flow->m³/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m³s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m3/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m3s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m^3/s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->m^3s":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeterspersecond":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeterpersecond":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeters/second":
		return CubicMetersPerSecondFlowUnit
	case "Flow->cubicmeter/second":
		return CubicMetersPerSecondFlowUnit
	case "Flow->ft³/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft³s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft^3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->ft^3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f³/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f³s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f^3/s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->f^3s":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfeetpersecond":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfootpersecond":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfeet/second":
		return CubicFeetPerSecondFlowUnit
	case "Flow->cubicfoot/second":
		return CubicFeetPerSecondFlowUnit
	case "Flow->mcfd":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcf/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcftd":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mcft/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft³/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft³d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft^3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mft^3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf³/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf³d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf^3/d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->mf^3d":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->thousandcubicfeetperday":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->thousandcubicfeet/day":
		return ThousandCubicFeetPerDayFlowUnit
	case "Flow->gal/s":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gals/s":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gals":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->galss":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gps":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gallonspersecond":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gallonpersecond":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gallons/second":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gallon/second":
		return GallonsUSFluidPerSecondFlowUnit
	case "Flow->gal/m":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gals/m":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->galm":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->galsm":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gpm":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallonsperminute":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallonperminute":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallonspermin":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallonpermin":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallons/minute":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallons/min":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallon/minute":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->gallon/min":
		return GallonsUSFluidPerMinuteFlowUnit
	case "Flow->bbl/s":
		return BarrelsPerSecondFlowUnit
	case "Flow->bbl/second":
		return BarrelsPerSecondFlowUnit
	case "Flow->bbls":
		return BarrelsPerSecondFlowUnit
	case "Flow->barrelpersecond":
		return BarrelsPerSecondFlowUnit
	case "Flow->barrelspersecond":
		return BarrelsPerSecondFlowUnit
	case "Flow->barrels/second":
		return BarrelsPerSecondFlowUnit
	case "Flow->barrel/second":
		return BarrelsPerSecondFlowUnit
	case "Flow->bbl/min":
		return BarrelsPerMinuteFlowUnit
	case "Flow->bbl/minute":
		return BarrelsPerMinuteFlowUnit
	case "Flow->bbl/m":
		return BarrelsPerMinuteFlowUnit
	case "Flow->bblm":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrelspermin":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrelsperminute":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrelpermin":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrelperminute":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrels/min":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrels/minute":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrel/min":
		return BarrelsPerMinuteFlowUnit
	case "Flow->barrel/minute":
		return BarrelsPerMinuteFlowUnit
	case "Volume->m³":
		return CubicMetersVolumeUnit
	case "Volume->m3":
		return CubicMetersVolumeUnit
	case "Volume->cubicmeter":
		return CubicMetersVolumeUnit
	case "Volume->cubicmeters":
		return CubicMetersVolumeUnit
	case "Volume->cuft":
		return CubicFeetVolumeUnit
	case "Volume->ft³":
		return CubicFeetVolumeUnit
	case "Volume->f³":
		return CubicFeetVolumeUnit
	case "Volume->cubicfoot":
		return CubicFeetVolumeUnit
	case "Volume->cubicfeet":
		return CubicFeetVolumeUnit
	case "Volume->mcf":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->mft³":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->mf³":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandcubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandsofcubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->thousandscubicfeet":
		return ThousandsOfCubicFeetVolumeUnit
	case "Volume->dm³":
		return CubicDecimeterVolumeUnit
	case "Volume->dm3":
		return CubicDecimeterVolumeUnit
	case "Volume->cubicdecimeter":
		return CubicDecimeterVolumeUnit
	case "Volume->cubicdecimeters":
		return CubicDecimeterVolumeUnit
	case "Volume->l":
		return LiterVolumeUnit
	case "Volume->liter":
		return LiterVolumeUnit
	case "Volume->liters":
		return LiterVolumeUnit
	case "Volume->litre":
		return LiterVolumeUnit
	case "Volume->litres":
		return LiterVolumeUnit
	case "Volume->gal":
		return GallonUSFluidVolumeUnit
	case "Volume->gallon":
		return GallonUSFluidVolumeUnit
	case "Volume->gals":
		return GallonUSFluidVolumeUnit
	case "Volume->gallons":
		return GallonUSFluidVolumeUnit
	case "Volume->gal(us)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallon(us)":
		return GallonUSFluidVolumeUnit
	case "Volume->gals(us)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallons(us)":
		return GallonUSFluidVolumeUnit
	case "Volume->gal(u.s.)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallon(u.s.)":
		return GallonUSFluidVolumeUnit
	case "Volume->gals(u.s.)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallons(u.s.)":
		return GallonUSFluidVolumeUnit
	case "Volume->gal(usfluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallon(usfluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->gals(usfluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallons(usfluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->gal(u.s.fluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallon(u.s.fluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->gals(u.s.fluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->gallons(u.s.fluid)":
		return GallonUSFluidVolumeUnit
	case "Volume->bbl":
		return BarrelsOfOilVolumeUnit
	case "Volume->bbls":
		return BarrelsOfOilVolumeUnit
	case "Volume->barrelsofoil":
		return BarrelsOfOilVolumeUnit
	case "Volume->barrelofoil":
		return BarrelsOfOilVolumeUnit
	case "Mass->kg":
		return KilogramsMassUnit
	case "Mass->kilogram":
		return KilogramsMassUnit
	case "Mass->kilo":
		return KilogramsMassUnit
	case "Mass->kgs":
		return KilogramsMassUnit
	case "Mass->kilograms":
		return KilogramsMassUnit
	case "Mass->kilos":
		return KilogramsMassUnit
	case "Mass->lb":
		return PoundsMassUnit
	case "Mass->lbs":
		return PoundsMassUnit
	case "Mass->pound":
		return PoundsMassUnit
	case "Mass->pounds":
		return PoundsMassUnit
	case "MassFlow->kg/s":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kgs":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilogrampersecond":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilopersecond":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kgpersecond":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilogramspersecond":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilospersecond":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kgspersecond":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilogram/second":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilo/second":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kg/second":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilograms/second":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kilos/second":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->kgs/second":
		return KilogramsPerSecondMassFlowUnit
	case "MassFlow->lb/s":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->lbs/s":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->lbs":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->lbss":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->poundpersecond":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->poundspersecond":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->pound/second":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->pounds/second":
		return PoundsPerSecondMassFlowUnit
	case "MassFlow->lb/min":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->lbs/min":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->lbmin":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->lbsmin":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->lb/m":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->lbs/m":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->lbm":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->lbsm":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->poundperminute":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->poundsperminute":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->pound/minute":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->pounds/minute":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->poundpermin":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->poundspermin":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->pound/min":
		return PoundsPerMinuteMassFlowUnit
	case "MassFlow->pounds/min":
		return PoundsPerMinuteMassFlowUnit
	case "ElectricPotential->volt":
		return VoltsElectricPotentialUnit
	case "ElectricPotential->volts":
		return VoltsElectricPotentialUnit
	case "ElectricPotential->v":
		return VoltsElectricPotentialUnit
	case "ElectricPotentialLoaded->volt":
		return VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialLoaded->volts":
		return VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialLoaded->v":
		return VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialUnloaded->volt":
		return VoltsElectricPotentialUnloadedUnit
	case "ElectricPotentialUnloaded->volts":
		return VoltsElectricPotentialUnloadedUnit
	case "ElectricPotentialUnloaded->v":
		return VoltsElectricPotentialUnloadedUnit
	case "Percentage->%":
		return PercentPercentageUnit
	case "Percentage->percent":
		return PercentPercentageUnit
	case "Percentage->percentage":
		return PercentPercentageUnit
	case "Fillage->%":
		return PercentFillageUnit
	case "Fillage->percent":
		return PercentFillageUnit
	case "Fillage->percentage":
		return PercentFillageUnit
	case "PumpFillage->%":
		return PercentPumpFillageUnit
	case "PumpFillage->percent":
		return PercentPumpFillageUnit
	case "PumpFillage->percentage":
		return PercentPumpFillageUnit
	case "Humidity->%":
		return PercentHumidityUnit
	case "Humidity->percent":
		return PercentHumidityUnit
	case "Humidity->percentage":
		return PercentHumidityUnit
	case "Alarm->%":
		return PercentAlarmUnit
	case "Alarm->percent":
		return PercentAlarmUnit
	case "Alarm->percentage":
		return PercentAlarmUnit
	case "Work->j":
		return JoulesWorkUnit
	case "Work->joule":
		return JoulesWorkUnit
	case "Work->joules":
		return JoulesWorkUnit
	case "Work->inlbf":
		return InchPoundsForceWorkUnit
	case "Work->inch-poundsforce":
		return InchPoundsForceWorkUnit
	case "Work->inch-poundforce":
		return InchPoundsForceWorkUnit
	case "Work->in-lbf":
		return InchPoundsForceWorkUnit
	case "Work->btuᵢₜ":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->btuit":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->btu":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->cubicfeetofnaturalgas":
		return CubicFeetOfNaturalGasWorkUnit
	case "Work->bboe":
		return BarrelsOfOilEquivalentWorkUnit
	case "Work->barrelsofoilequivalent":
		return BarrelsOfOilEquivalentWorkUnit
	case "Force->n":
		return NewtonsForceUnit
	case "Force->newton":
		return NewtonsForceUnit
	case "Force->newtons":
		return NewtonsForceUnit
	case "Force->lbf":
		return PoundsForceForceUnit
	case "Force->pounds-force":
		return PoundsForceForceUnit
	case "Force->poundsforce":
		return PoundsForceForceUnit
	case "Force->pound-force":
		return PoundsForceForceUnit
	case "Force->poundforce":
		return PoundsForceForceUnit
	case "Force->kgf":
		return KilogramsForceForceUnit
	case "Force->kilograms-force":
		return KilogramsForceForceUnit
	case "Force->kilogram-force":
		return KilogramsForceForceUnit
	case "Load->n":
		return NewtonsLoadUnit
	case "Load->newton":
		return NewtonsLoadUnit
	case "Load->newtons":
		return NewtonsLoadUnit
	case "Load->lbf":
		return PoundsForceLoadUnit
	case "Load->pounds-force":
		return PoundsForceLoadUnit
	case "Load->poundsforce":
		return PoundsForceLoadUnit
	case "Load->pound-force":
		return PoundsForceLoadUnit
	case "Load->poundforce":
		return PoundsForceLoadUnit
	case "Load->kgf":
		return KilogramsForceLoadUnit
	case "Load->kilograms-force":
		return KilogramsForceLoadUnit
	case "Load->kilogram-force":
		return KilogramsForceLoadUnit
	case "MaxLoad->n":
		return NewtonsMaxLoadUnit
	case "MaxLoad->newton":
		return NewtonsMaxLoadUnit
	case "MaxLoad->newtons":
		return NewtonsMaxLoadUnit
	case "MaxLoad->lbf":
		return PoundsForceMaxLoadUnit
	case "MaxLoad->pounds-force":
		return PoundsForceMaxLoadUnit
	case "MaxLoad->poundsforce":
		return PoundsForceMaxLoadUnit
	case "MaxLoad->pound-force":
		return PoundsForceMaxLoadUnit
	case "MaxLoad->poundforce":
		return PoundsForceMaxLoadUnit
	case "MaxLoad->kgf":
		return KilogramsForceMaxLoadUnit
	case "MaxLoad->kilograms-force":
		return KilogramsForceMaxLoadUnit
	case "MaxLoad->kilogram-force":
		return KilogramsForceMaxLoadUnit
	case "MinLoad->n":
		return NewtonsMinLoadUnit
	case "MinLoad->newton":
		return NewtonsMinLoadUnit
	case "MinLoad->newtons":
		return NewtonsMinLoadUnit
	case "MinLoad->lbf":
		return PoundsForceMinLoadUnit
	case "MinLoad->pounds-force":
		return PoundsForceMinLoadUnit
	case "MinLoad->poundsforce":
		return PoundsForceMinLoadUnit
	case "MinLoad->pound-force":
		return PoundsForceMinLoadUnit
	case "MinLoad->poundforce":
		return PoundsForceMinLoadUnit
	case "MinLoad->kgf":
		return KilogramsForceMinLoadUnit
	case "MinLoad->kilograms-force":
		return KilogramsForceMinLoadUnit
	case "MinLoad->kilogram-force":
		return KilogramsForceMinLoadUnit
	case "FluidLoad->n":
		return NewtonsFluidLoadUnit
	case "FluidLoad->newton":
		return NewtonsFluidLoadUnit
	case "FluidLoad->newtons":
		return NewtonsFluidLoadUnit
	case "FluidLoad->lbf":
		return PoundsForceFluidLoadUnit
	case "FluidLoad->pounds-force":
		return PoundsForceFluidLoadUnit
	case "FluidLoad->poundsforce":
		return PoundsForceFluidLoadUnit
	case "FluidLoad->pound-force":
		return PoundsForceFluidLoadUnit
	case "FluidLoad->poundforce":
		return PoundsForceFluidLoadUnit
	case "FluidLoad->kgf":
		return KilogramsForceFluidLoadUnit
	case "FluidLoad->kilograms-force":
		return KilogramsForceFluidLoadUnit
	case "FluidLoad->kilogram-force":
		return KilogramsForceFluidLoadUnit
	case "Length->m":
		return MetersLengthUnit
	case "Length->meter":
		return MetersLengthUnit
	case "Length->meters":
		return MetersLengthUnit
	case "Length->ft":
		return FeetLengthUnit
	case "Length->foot":
		return FeetLengthUnit
	case "Length->feet":
		return FeetLengthUnit
	case "Length->in":
		return InchesLengthUnit
	case "Length->inch":
		return InchesLengthUnit
	case "Length->inches":
		return InchesLengthUnit
	case "Stroke->m":
		return MetersStrokeUnit
	case "Stroke->meter":
		return MetersStrokeUnit
	case "Stroke->meters":
		return MetersStrokeUnit
	case "Stroke->ft":
		return FeetStrokeUnit
	case "Stroke->foot":
		return FeetStrokeUnit
	case "Stroke->feet":
		return FeetStrokeUnit
	case "Stroke->in":
		return InchesStrokeUnit
	case "Stroke->inch":
		return InchesStrokeUnit
	case "Stroke->inches":
		return InchesStrokeUnit
	case "GrossStroke->m":
		return MetersGrossStrokeUnit
	case "GrossStroke->meter":
		return MetersGrossStrokeUnit
	case "GrossStroke->meters":
		return MetersGrossStrokeUnit
	case "GrossStroke->ft":
		return FeetGrossStrokeUnit
	case "GrossStroke->foot":
		return FeetGrossStrokeUnit
	case "GrossStroke->feet":
		return FeetGrossStrokeUnit
	case "GrossStroke->in":
		return InchesGrossStrokeUnit
	case "GrossStroke->inch":
		return InchesGrossStrokeUnit
	case "GrossStroke->inches":
		return InchesGrossStrokeUnit
	case "NetStroke->m":
		return MetersNetStrokeUnit
	case "NetStroke->meter":
		return MetersNetStrokeUnit
	case "NetStroke->meters":
		return MetersNetStrokeUnit
	case "NetStroke->ft":
		return FeetNetStrokeUnit
	case "NetStroke->foot":
		return FeetNetStrokeUnit
	case "NetStroke->feet":
		return FeetNetStrokeUnit
	case "NetStroke->in":
		return InchesNetStrokeUnit
	case "NetStroke->inch":
		return InchesNetStrokeUnit
	case "NetStroke->inches":
		return InchesNetStrokeUnit
	case "StrokeRate->strokes/s":
		return StrokesPerSecondStrokeRateUnit
	case "StrokeRate->strokespersecond":
		return StrokesPerSecondStrokeRateUnit
	case "StrokeRate->s/s":
		return StrokesPerSecondStrokeRateUnit
	case "Number->number":
		return NumberNumberUnit
	case "Number->*":
		return NumberNumberUnit
	case "Overspeed->number":
		return NumberOverspeedUnit
	case "Overspeed->*":
		return NumberOverspeedUnit
	case "Underspeed->number":
		return NumberUnderspeedUnit
	case "Underspeed->*":
		return NumberUnderspeedUnit
	case "Totaliser->number":
		return NumberTotaliserUnit
	case "Totaliser->*":
		return NumberTotaliserUnit
	case "WMLFlowRate->number":
		return NumberWMLFlowRateUnit
	case "WMLFlowRate->*":
		return NumberWMLFlowRateUnit
	default:
		return NumberNumberUnit
	}
}

// GetTypeUnit returns the unit type and unit which matches input or (NumberUnitType, NumberNumberUnit).
// Opposite of AlakaTitle
func GetTypeUnit(input string) (UnitType, Unit) {
	switch input {
	case "Pressure_Pascals":
		return PressureUnitType, PascalsPressureUnit
	case "Pressure_Kilopascals":
		return PressureUnitType, KilopascalsPressureUnit
	case "Pressure_Megapascals":
		return PressureUnitType, MegapascalsPressureUnit
	case "Pressure_PoundsPerSquareInch":
		return PressureUnitType, PoundsPerSquareInchPressureUnit
	case "Pressure_InchesOfWater":
		return PressureUnitType, InchesOfWaterPressureUnit
	case "Temperature_DegreesCelsius":
		return TemperatureUnitType, DegreesCelsiusTemperatureUnit
	case "Temperature_DegreesFahrenheit":
		return TemperatureUnitType, DegreesFahrenheitTemperatureUnit
	case "Temperature_Kelvins":
		return TemperatureUnitType, KelvinsTemperatureUnit
	case "Flow_CubicMetersPerSecond":
		return FlowUnitType, CubicMetersPerSecondFlowUnit
	case "Flow_CubicFeetPerSecond":
		return FlowUnitType, CubicFeetPerSecondFlowUnit
	case "Flow_ThousandCubicFeetPerDay":
		return FlowUnitType, ThousandCubicFeetPerDayFlowUnit
	case "Flow_GallonsUSFluidPerSecond":
		return FlowUnitType, GallonsUSFluidPerSecondFlowUnit
	case "Flow_GallonsUSFluidPerMinute":
		return FlowUnitType, GallonsUSFluidPerMinuteFlowUnit
	case "Flow_BarrelsPerSecond":
		return FlowUnitType, BarrelsPerSecondFlowUnit
	case "Flow_BarrelsPerMinute":
		return FlowUnitType, BarrelsPerMinuteFlowUnit
	case "Volume_CubicMeters":
		return VolumeUnitType, CubicMetersVolumeUnit
	case "Volume_CubicFeet":
		return VolumeUnitType, CubicFeetVolumeUnit
	case "Volume_ThousandsOfCubicFeet":
		return VolumeUnitType, ThousandsOfCubicFeetVolumeUnit
	case "Volume_CubicDecimeter":
		return VolumeUnitType, CubicDecimeterVolumeUnit
	case "Volume_Liter":
		return VolumeUnitType, LiterVolumeUnit
	case "Volume_GallonUSFluid":
		return VolumeUnitType, GallonUSFluidVolumeUnit
	case "Volume_BarrelsOfOil":
		return VolumeUnitType, BarrelsOfOilVolumeUnit
	case "Mass_Kilograms":
		return MassUnitType, KilogramsMassUnit
	case "Mass_Pounds":
		return MassUnitType, PoundsMassUnit
	case "MassFlow_KilogramsPerSecond":
		return MassFlowUnitType, KilogramsPerSecondMassFlowUnit
	case "MassFlow_PoundsPerSecond":
		return MassFlowUnitType, PoundsPerSecondMassFlowUnit
	case "MassFlow_PoundsPerMinute":
		return MassFlowUnitType, PoundsPerMinuteMassFlowUnit
	case "ElectricPotential_Volts":
		return ElectricPotentialUnitType, VoltsElectricPotentialUnit
	case "ElectricPotentialLoaded_Volts":
		return ElectricPotentialLoadedUnitType, VoltsElectricPotentialLoadedUnit
	case "ElectricPotentialUnloaded_Volts":
		return ElectricPotentialUnloadedUnitType, VoltsElectricPotentialUnloadedUnit
	case "Percentage_Percent":
		return PercentageUnitType, PercentPercentageUnit
	case "Fillage_Percent":
		return FillageUnitType, PercentFillageUnit
	case "PumpFillage_Percent":
		return PumpFillageUnitType, PercentPumpFillageUnit
	case "Humidity_Percent":
		return HumidityUnitType, PercentHumidityUnit
	case "Alarm_Percent":
		return AlarmUnitType, PercentAlarmUnit
	case "Work_Joules":
		return WorkUnitType, JoulesWorkUnit
	case "Work_InchPoundsForce":
		return WorkUnitType, InchPoundsForceWorkUnit
	case "Work_CubicFeetOfNaturalGas":
		return WorkUnitType, CubicFeetOfNaturalGasWorkUnit
	case "Work_BarrelsOfOilEquivalent":
		return WorkUnitType, BarrelsOfOilEquivalentWorkUnit
	case "Force_Newtons":
		return ForceUnitType, NewtonsForceUnit
	case "Force_PoundsForce":
		return ForceUnitType, PoundsForceForceUnit
	case "Force_KilogramsForce":
		return ForceUnitType, KilogramsForceForceUnit
	case "Load_Newtons":
		return LoadUnitType, NewtonsLoadUnit
	case "Load_PoundsForce":
		return LoadUnitType, PoundsForceLoadUnit
	case "Load_KilogramsForce":
		return LoadUnitType, KilogramsForceLoadUnit
	case "MaxLoad_Newtons":
		return MaxLoadUnitType, NewtonsMaxLoadUnit
	case "MaxLoad_PoundsForce":
		return MaxLoadUnitType, PoundsForceMaxLoadUnit
	case "MaxLoad_KilogramsForce":
		return MaxLoadUnitType, KilogramsForceMaxLoadUnit
	case "MinLoad_Newtons":
		return MinLoadUnitType, NewtonsMinLoadUnit
	case "MinLoad_PoundsForce":
		return MinLoadUnitType, PoundsForceMinLoadUnit
	case "MinLoad_KilogramsForce":
		return MinLoadUnitType, KilogramsForceMinLoadUnit
	case "FluidLoad_Newtons":
		return FluidLoadUnitType, NewtonsFluidLoadUnit
	case "FluidLoad_PoundsForce":
		return FluidLoadUnitType, PoundsForceFluidLoadUnit
	case "FluidLoad_KilogramsForce":
		return FluidLoadUnitType, KilogramsForceFluidLoadUnit
	case "Length_Meters":
		return LengthUnitType, MetersLengthUnit
	case "Length_Feet":
		return LengthUnitType, FeetLengthUnit
	case "Length_Inches":
		return LengthUnitType, InchesLengthUnit
	case "Stroke_Meters":
		return StrokeUnitType, MetersStrokeUnit
	case "Stroke_Feet":
		return StrokeUnitType, FeetStrokeUnit
	case "Stroke_Inches":
		return StrokeUnitType, InchesStrokeUnit
	case "GrossStroke_Meters":
		return GrossStrokeUnitType, MetersGrossStrokeUnit
	case "GrossStroke_Feet":
		return GrossStrokeUnitType, FeetGrossStrokeUnit
	case "GrossStroke_Inches":
		return GrossStrokeUnitType, InchesGrossStrokeUnit
	case "NetStroke_Meters":
		return NetStrokeUnitType, MetersNetStrokeUnit
	case "NetStroke_Feet":
		return NetStrokeUnitType, FeetNetStrokeUnit
	case "NetStroke_Inches":
		return NetStrokeUnitType, InchesNetStrokeUnit
	case "StrokeRate_StrokesPerSecond":
		return StrokeRateUnitType, StrokesPerSecondStrokeRateUnit
	case "Number_Number":
		return NumberUnitType, NumberNumberUnit
	case "Overspeed_Number":
		return OverspeedUnitType, NumberOverspeedUnit
	case "Underspeed_Number":
		return UnderspeedUnitType, NumberUnderspeedUnit
	case "Totaliser_Number":
		return TotaliserUnitType, NumberTotaliserUnit
	case "WMLFlowRate_Number":
		return WMLFlowRateUnitType, NumberWMLFlowRateUnit
	default:
		return NumberUnitType, NumberNumberUnit
	}
}

// Pressure (UnitType)
// Contains 5 units:
//  - PascalsPressure             Pa => Pa                 = Pa
//  - KilopascalsPressure         Pa => Pa * 0.001         = kPa
//  - MegapascalsPressure         Pa => Pa * 0.000,001     = MPa
//  - PoundsPerSquareInchPressure Pa => Pa * 0.000,145,038 = psi
//  - InchesOfWaterPressure       Pa => Pa * 0.004,014,74  = inH₂O
// Base: PascalsPressure
type Pressure float64

// Title always returns "Pressure"
func (x Pressure) Title() string {
	return "Pressure"
}

// Name always returns "Pressure"
func (x Pressure) Name() string {
	return "Pressure"
}

// Base always returns PascalsPressureUnit
func (x Pressure) Base() Unit {
	return PascalsPressureUnit
}

// PressureUnits is effectively a constant
var PressureUnits = [...]Unit{PascalsPressureUnit, KilopascalsPressureUnit, MegapascalsPressureUnit, PoundsPerSquareInchPressureUnit, InchesOfWaterPressureUnit}

// Units always returns PressureUnits[:]
func (x Pressure) Units() []Unit {
	return PressureUnits[:]
}

// PressureUnitList is effectively a constant
var PressureUnitList = [...]string{"Pascals", "Kilopascals", "Megapascals", "Pounds per Square Inch", "Inches of Water"}

// UnitList always returns PressureUnitList[:]
func (x Pressure) UnitList() []string {
	return PressureUnitList[:]
}

// PressureMatchList is effectively a constant
var PressureMatchList = [...]string{"pressure"}

// MatchList always returns PressureMatchList[:]
func (x Pressure) MatchList() []string {
	return PressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Pressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var PressureUnitType Pressure = 0.0

// PascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa = Pa
// Unit.ToBase  : Pa => Pa = Pa
type PascalsPressure Pressure

// Title always returns "Pascals"
func (x PascalsPressure) Title() string {
	return "Pascals"
}

// Name always returns "Pascals"
func (x PascalsPressure) Name() string {
	return "Pascals"
}

// Symbol always returns "Pa"
func (x PascalsPressure) Symbol() string {
	return "Pa"
}

// FromBase converts Pa to Pa
func (x PascalsPressure) FromBase(Pa float64) float64 {
	return Pa
}

// ToBase converts Pa to Pa
func (x PascalsPressure) ToBase(Pa float64) float64 {
	return Pa
}

// PascalsPressureMatchList is effectively a constant
var PascalsPressureMatchList = [...]string{"pa", "pascal", "pascals"}

// MatchList always returns PascalsPressureMatchList[:]
func (x PascalsPressure) MatchList() []string {
	return PascalsPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PascalsPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x PascalsPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x PascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var PascalsPressureUnit PascalsPressure = 0.0

// KilopascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.001   = kPa
// Unit.ToBase  : kPa => kPa * 1,000 = Pa
type KilopascalsPressure Pressure

// Title always returns "Kilopascals"
func (x KilopascalsPressure) Title() string {
	return "Kilopascals"
}

// Name always returns "Kilopascals"
func (x KilopascalsPressure) Name() string {
	return "Kilopascals"
}

// Symbol always returns "kPa"
func (x KilopascalsPressure) Symbol() string {
	return "kPa"
}

// FromBase converts Pa to kPa
func (x KilopascalsPressure) FromBase(Pa float64) float64 {
	return Pa * 0.001
}

// ToBase converts kPa to Pa
func (x KilopascalsPressure) ToBase(kPa float64) float64 {
	return kPa * 1000
}

// KilopascalsPressureMatchList is effectively a constant
var KilopascalsPressureMatchList = [...]string{"kpa", "kilopascal", "kilopascals"}

// MatchList always returns KilopascalsPressureMatchList[:]
func (x KilopascalsPressure) MatchList() []string {
	return KilopascalsPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilopascalsPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x KilopascalsPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x KilopascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var KilopascalsPressureUnit KilopascalsPressure = 0.0

// MegapascalsPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,001   = MPa
// Unit.ToBase  : MPa => MPa * 1,000,000 = Pa
type MegapascalsPressure Pressure

// Title always returns "Megapascals"
func (x MegapascalsPressure) Title() string {
	return "Megapascals"
}

// Name always returns "Megapascals"
func (x MegapascalsPressure) Name() string {
	return "Megapascals"
}

// Symbol always returns "MPa"
func (x MegapascalsPressure) Symbol() string {
	return "MPa"
}

// FromBase converts Pa to MPa
func (x MegapascalsPressure) FromBase(Pa float64) float64 {
	return Pa * 0.000001
}

// ToBase converts MPa to Pa
func (x MegapascalsPressure) ToBase(MPa float64) float64 {
	return MPa * 1000000
}

// MegapascalsPressureMatchList is effectively a constant
var MegapascalsPressureMatchList = [...]string{"mpa", "megapascal", "megapascals"}

// MatchList always returns MegapascalsPressureMatchList[:]
func (x MegapascalsPressure) MatchList() []string {
	return MegapascalsPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MegapascalsPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x MegapascalsPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x MegapascalsPressure) Base() Unit {
	return PascalsPressureUnit
}

var MegapascalsPressureUnit MegapascalsPressure = 0.0

// PoundsPerSquareInchPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.000,145,038 = psi
// Unit.ToBase  : psi => psi * 6,894.76    = Pa
type PoundsPerSquareInchPressure Pressure

// Title always returns "PoundsPerSquareInch"
func (x PoundsPerSquareInchPressure) Title() string {
	return "PoundsPerSquareInch"
}

// Name always returns "Pounds per Square Inch"
func (x PoundsPerSquareInchPressure) Name() string {
	return "Pounds per Square Inch"
}

// Symbol always returns "psi"
func (x PoundsPerSquareInchPressure) Symbol() string {
	return "psi"
}

// FromBase converts Pa to psi
func (x PoundsPerSquareInchPressure) FromBase(Pa float64) float64 {
	return Pa * 0.000145038
}

// ToBase converts psi to Pa
func (x PoundsPerSquareInchPressure) ToBase(psi float64) float64 {
	return psi * 6894.76
}

// PoundsPerSquareInchPressureMatchList is effectively a constant
var PoundsPerSquareInchPressureMatchList = [...]string{"psi", "poundspersquareinch", "poundpersquareinch"}

// MatchList always returns PoundsPerSquareInchPressureMatchList[:]
func (x PoundsPerSquareInchPressure) MatchList() []string {
	return PoundsPerSquareInchPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsPerSquareInchPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x PoundsPerSquareInchPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x PoundsPerSquareInchPressure) Base() Unit {
	return PascalsPressureUnit
}

var PoundsPerSquareInchPressureUnit PoundsPerSquareInchPressure = 0.0

// InchesOfWaterPressure (Unit)
// UnitType     : Pressure
// UnitType.Base: PascalsPressure
// Unit.FromBase: Pa => Pa * 0.004,014,74  = inH₂O
// Unit.ToBase  : inH2O => inH2O * 249.082 = Pa
type InchesOfWaterPressure Pressure

// Title always returns "InchesOfWater"
func (x InchesOfWaterPressure) Title() string {
	return "InchesOfWater"
}

// Name always returns "Inches of Water"
func (x InchesOfWaterPressure) Name() string {
	return "Inches of Water"
}

// Symbol always returns "inH₂O"
func (x InchesOfWaterPressure) Symbol() string {
	return "inH₂O"
}

// FromBase converts Pa to inH₂O
func (x InchesOfWaterPressure) FromBase(Pa float64) float64 {
	return Pa * 0.00401474
}

// ToBase converts inH₂O to Pa
func (x InchesOfWaterPressure) ToBase(inH2O float64) float64 {
	return inH2O * 249.082
}

// InchesOfWaterPressureMatchList is effectively a constant
var InchesOfWaterPressureMatchList = [...]string{"inh₂o", "inh₂0", "inh2o", "inh20", "incheswater", "inchesofwater", "inchwater", "inchofwater"}

// MatchList always returns InchesOfWaterPressureMatchList[:]
func (x InchesOfWaterPressure) MatchList() []string {
	return InchesOfWaterPressureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesOfWaterPressure) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PressureUnitType
func (x InchesOfWaterPressure) TypeOf() UnitType {
	return PressureUnitType
}

// Base always returns PascalsPressureUnit
func (x InchesOfWaterPressure) Base() Unit {
	return PascalsPressureUnit
}

var InchesOfWaterPressureUnit InchesOfWaterPressure = 0.0

// Temperature (UnitType)
// Contains 3 units:
//  - DegreesCelsiusTemperature    C => C                  = °C
//  - DegreesFahrenheitTemperature C => (C * (9 / 5)) + 32 = °F
//  - KelvinsTemperature           C => C + 273.15         = K
// Base: DegreesCelsiusTemperature
type Temperature float64

// Title always returns "Temperature"
func (x Temperature) Title() string {
	return "Temperature"
}

// Name always returns "Temperature"
func (x Temperature) Name() string {
	return "Temperature"
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x Temperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

// TemperatureUnits is effectively a constant
var TemperatureUnits = [...]Unit{DegreesCelsiusTemperatureUnit, DegreesFahrenheitTemperatureUnit, KelvinsTemperatureUnit}

// Units always returns TemperatureUnits[:]
func (x Temperature) Units() []Unit {
	return TemperatureUnits[:]
}

// TemperatureUnitList is effectively a constant
var TemperatureUnitList = [...]string{"Degrees Celsius", "Degrees Fahrenheit", "Kelvins"}

// UnitList always returns TemperatureUnitList[:]
func (x Temperature) UnitList() []string {
	return TemperatureUnitList[:]
}

// TemperatureMatchList is effectively a constant
var TemperatureMatchList = [...]string{"temperature", "temp"}

// MatchList always returns TemperatureMatchList[:]
func (x Temperature) MatchList() []string {
	return TemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Temperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var TemperatureUnitType Temperature = 0.0

// DegreesCelsiusTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C = °C
// Unit.ToBase  : C => C = °C
type DegreesCelsiusTemperature Temperature

// Title always returns "DegreesCelsius"
func (x DegreesCelsiusTemperature) Title() string {
	return "DegreesCelsius"
}

// Name always returns "Degrees Celsius"
func (x DegreesCelsiusTemperature) Name() string {
	return "Degrees Celsius"
}

// Symbol always returns "°C"
func (x DegreesCelsiusTemperature) Symbol() string {
	return "°C"
}

// FromBase converts °C to °C
func (x DegreesCelsiusTemperature) FromBase(C float64) float64 {
	return C
}

// ToBase converts °C to °C
func (x DegreesCelsiusTemperature) ToBase(C float64) float64 {
	return C
}

// DegreesCelsiusTemperatureMatchList is effectively a constant
var DegreesCelsiusTemperatureMatchList = [...]string{"c", "°c", "celsius", "degreesc", "degreec", "degreescelsius", "degreecelsius"}

// MatchList always returns DegreesCelsiusTemperatureMatchList[:]
func (x DegreesCelsiusTemperature) MatchList() []string {
	return DegreesCelsiusTemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesCelsiusTemperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TemperatureUnitType
func (x DegreesCelsiusTemperature) TypeOf() UnitType {
	return TemperatureUnitType
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x DegreesCelsiusTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var DegreesCelsiusTemperatureUnit DegreesCelsiusTemperature = 0.0

// DegreesFahrenheitTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => (C * (9 / 5)) + 32 = °F
// Unit.ToBase  : F => (F - 32) * (5 / 9) = °C
type DegreesFahrenheitTemperature Temperature

// Title always returns "DegreesFahrenheit"
func (x DegreesFahrenheitTemperature) Title() string {
	return "DegreesFahrenheit"
}

// Name always returns "Degrees Fahrenheit"
func (x DegreesFahrenheitTemperature) Name() string {
	return "Degrees Fahrenheit"
}

// Symbol always returns "°F"
func (x DegreesFahrenheitTemperature) Symbol() string {
	return "°F"
}

// FromBase converts °C to °F
func (x DegreesFahrenheitTemperature) FromBase(C float64) float64 {
	return (C * (9 / 5)) + 32
}

// ToBase converts °F to °C
func (x DegreesFahrenheitTemperature) ToBase(F float64) float64 {
	return (F - 32) * (5 / 9)
}

// DegreesFahrenheitTemperatureMatchList is effectively a constant
var DegreesFahrenheitTemperatureMatchList = [...]string{"f", "°f", "fahrenheit", "degreesf", "degreef", "degreesfahrenheit", "degreefahrenheit"}

// MatchList always returns DegreesFahrenheitTemperatureMatchList[:]
func (x DegreesFahrenheitTemperature) MatchList() []string {
	return DegreesFahrenheitTemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesFahrenheitTemperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TemperatureUnitType
func (x DegreesFahrenheitTemperature) TypeOf() UnitType {
	return TemperatureUnitType
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x DegreesFahrenheitTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var DegreesFahrenheitTemperatureUnit DegreesFahrenheitTemperature = 0.0

// KelvinsTemperature (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsiusTemperature
// Unit.FromBase: C => C + 273.15 = K
// Unit.ToBase  : K => K - 273.15 = °C
type KelvinsTemperature Temperature

// Title always returns "Kelvins"
func (x KelvinsTemperature) Title() string {
	return "Kelvins"
}

// Name always returns "Kelvins"
func (x KelvinsTemperature) Name() string {
	return "Kelvins"
}

// Symbol always returns "K"
func (x KelvinsTemperature) Symbol() string {
	return "K"
}

// FromBase converts °C to K
func (x KelvinsTemperature) FromBase(C float64) float64 {
	return C + 273.15
}

// ToBase converts K to °C
func (x KelvinsTemperature) ToBase(K float64) float64 {
	return K - 273.15
}

// KelvinsTemperatureMatchList is effectively a constant
var KelvinsTemperatureMatchList = [...]string{"k", "°k", "kelvin", "kelvins", "degreesk", "degreek", "degreeskelvin", "degreekelvin"}

// MatchList always returns KelvinsTemperatureMatchList[:]
func (x KelvinsTemperature) MatchList() []string {
	return KelvinsTemperatureMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KelvinsTemperature) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TemperatureUnitType
func (x KelvinsTemperature) TypeOf() UnitType {
	return TemperatureUnitType
}

// Base always returns DegreesCelsiusTemperatureUnit
func (x KelvinsTemperature) Base() Unit {
	return DegreesCelsiusTemperatureUnit
}

var KelvinsTemperatureUnit KelvinsTemperature = 0.0

// Flow (UnitType)
// Contains 7 units:
//  - CubicMetersPerSecondFlow    m3s => m3s            = m³/s
//  - CubicFeetPerSecondFlow      m3s => m3s * 35.314,7 = ft³/s
//  - ThousandCubicFeetPerDayFlow m3s => m3s * 3,051.19 = MCFD
//  - GallonsUSFluidPerSecondFlow m3s => m3s * 264.172  = gal/s
//  - GallonsUSFluidPerMinuteFlow m3s => m3s * 15850.3  = gal/min
//  - BarrelsPerSecondFlow        m3s => m3s * 6.289,81 = bbl/s
//  - BarrelsPerMinuteFlow        m3s => m3s * 377.389  = bbl/min
// Base: CubicMetersPerSecondFlow
type Flow float64

// Title always returns "Flow"
func (x Flow) Title() string {
	return "Flow"
}

// Name always returns "Flow"
func (x Flow) Name() string {
	return "Flow"
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x Flow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

// FlowUnits is effectively a constant
var FlowUnits = [...]Unit{CubicMetersPerSecondFlowUnit, CubicFeetPerSecondFlowUnit, ThousandCubicFeetPerDayFlowUnit, GallonsUSFluidPerSecondFlowUnit, GallonsUSFluidPerMinuteFlowUnit, BarrelsPerSecondFlowUnit, BarrelsPerMinuteFlowUnit}

// Units always returns FlowUnits[:]
func (x Flow) Units() []Unit {
	return FlowUnits[:]
}

// FlowUnitList is effectively a constant
var FlowUnitList = [...]string{"Cubic Meters per Second", "Cubic Feet per Second", "Thousand Cubic Feet per Day", "Gallons (U.S. Fluid) per Second", "Gallons (U.S. Fluid) per Minute", "Barrels per Second", "Barrels per Minute"}

// UnitList always returns FlowUnitList[:]
func (x Flow) UnitList() []string {
	return FlowUnitList[:]
}

// FlowMatchList is effectively a constant
var FlowMatchList = [...]string{"flow", "flowrate", "flow_rate", "gasflow", "gasflowrate", "gas_flow", "gas_flow_rate"}

// MatchList always returns FlowMatchList[:]
func (x Flow) MatchList() []string {
	return FlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Flow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var FlowUnitType Flow = 0.0

// CubicMetersPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s = m³/s
// Unit.ToBase  : m3s => m3s = m³/s
type CubicMetersPerSecondFlow Flow

// Title always returns "CubicMetersPerSecond"
func (x CubicMetersPerSecondFlow) Title() string {
	return "CubicMetersPerSecond"
}

// Name always returns "Cubic Meters per Second"
func (x CubicMetersPerSecondFlow) Name() string {
	return "Cubic Meters per Second"
}

// Symbol always returns "m³/s"
func (x CubicMetersPerSecondFlow) Symbol() string {
	return "m³/s"
}

// FromBase converts m³/s to m³/s
func (x CubicMetersPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s
}

// ToBase converts m³/s to m³/s
func (x CubicMetersPerSecondFlow) ToBase(m3s float64) float64 {
	return m3s
}

// CubicMetersPerSecondFlowMatchList is effectively a constant
var CubicMetersPerSecondFlowMatchList = [...]string{"m³/s", "m³s", "m3/s", "m3s", "m^3/s", "m^3s", "cubicmeterspersecond", "cubicmeterpersecond", "cubicmeters/second", "cubicmeter/second"}

// MatchList always returns CubicMetersPerSecondFlowMatchList[:]
func (x CubicMetersPerSecondFlow) MatchList() []string {
	return CubicMetersPerSecondFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMetersPerSecondFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x CubicMetersPerSecondFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x CubicMetersPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var CubicMetersPerSecondFlowUnit CubicMetersPerSecondFlow = 0.0

// CubicFeetPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 35.314,7      = ft³/s
// Unit.ToBase  : ft3s => ft3s * 0.028,316,8 = m³/s
type CubicFeetPerSecondFlow Flow

// Title always returns "CubicFeetPerSecond"
func (x CubicFeetPerSecondFlow) Title() string {
	return "CubicFeetPerSecond"
}

// Name always returns "Cubic Feet per Second"
func (x CubicFeetPerSecondFlow) Name() string {
	return "Cubic Feet per Second"
}

// Symbol always returns "ft³/s"
func (x CubicFeetPerSecondFlow) Symbol() string {
	return "ft³/s"
}

// FromBase converts m³/s to ft³/s
func (x CubicFeetPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s * 35.3147
}

// ToBase converts ft³/s to m³/s
func (x CubicFeetPerSecondFlow) ToBase(ft3s float64) float64 {
	return ft3s * 0.0283168
}

// CubicFeetPerSecondFlowMatchList is effectively a constant
var CubicFeetPerSecondFlowMatchList = [...]string{"ft³/s", "ft³s", "ft3/s", "ft3s", "ft^3/s", "ft^3s", "f³/s", "f³s", "f3/s", "f3s", "f^3/s", "f^3s", "cubicfeetpersecond", "cubicfootpersecond", "cubicfeet/second", "cubicfoot/second"}

// MatchList always returns CubicFeetPerSecondFlowMatchList[:]
func (x CubicFeetPerSecondFlow) MatchList() []string {
	return CubicFeetPerSecondFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetPerSecondFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x CubicFeetPerSecondFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x CubicFeetPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var CubicFeetPerSecondFlowUnit CubicFeetPerSecondFlow = 0.0

// ThousandCubicFeetPerDayFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 3,051.19        = MCFD
// Unit.ToBase  : MCFD => MCFD * 0.000,327,741 = m³/s
type ThousandCubicFeetPerDayFlow Flow

// Title always returns "ThousandCubicFeetPerDay"
func (x ThousandCubicFeetPerDayFlow) Title() string {
	return "ThousandCubicFeetPerDay"
}

// Name always returns "Thousand Cubic Feet per Day"
func (x ThousandCubicFeetPerDayFlow) Name() string {
	return "Thousand Cubic Feet per Day"
}

// Symbol always returns "MCFD"
func (x ThousandCubicFeetPerDayFlow) Symbol() string {
	return "MCFD"
}

// FromBase converts m³/s to MCFD
func (x ThousandCubicFeetPerDayFlow) FromBase(m3s float64) float64 {
	return m3s * 3051.19
}

// ToBase converts MCFD to m³/s
func (x ThousandCubicFeetPerDayFlow) ToBase(MCFD float64) float64 {
	return MCFD * 0.000327741
}

// ThousandCubicFeetPerDayFlowMatchList is effectively a constant
var ThousandCubicFeetPerDayFlowMatchList = [...]string{"mcfd", "mcf/d", "mcftd", "mcft/d", "mft³/d", "mft³d", "mft3/d", "mft3d", "mft^3/d", "mft^3d", "mf³/d", "mf³d", "mf3/d", "mf3d", "mf^3/d", "mf^3d", "thousandcubicfeetperday", "thousandcubicfeet/day"}

// MatchList always returns ThousandCubicFeetPerDayFlowMatchList[:]
func (x ThousandCubicFeetPerDayFlow) MatchList() []string {
	return ThousandCubicFeetPerDayFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandCubicFeetPerDayFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x ThousandCubicFeetPerDayFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x ThousandCubicFeetPerDayFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var ThousandCubicFeetPerDayFlowUnit ThousandCubicFeetPerDayFlow = 0.0

// GallonsUSFluidPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 264.172        = gal/s
// Unit.ToBase  : gals => gals * 0.003,785,41 = m³/s
type GallonsUSFluidPerSecondFlow Flow

// Title always returns "GallonsUSFluidPerSecond"
func (x GallonsUSFluidPerSecondFlow) Title() string {
	return "GallonsUSFluidPerSecond"
}

// Name always returns "Gallons (U.S. Fluid) per Second"
func (x GallonsUSFluidPerSecondFlow) Name() string {
	return "Gallons (U.S. Fluid) per Second"
}

// Symbol always returns "gal/s"
func (x GallonsUSFluidPerSecondFlow) Symbol() string {
	return "gal/s"
}

// FromBase converts m³/s to gal/s
func (x GallonsUSFluidPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s * 264.172
}

// ToBase converts gal/s to m³/s
func (x GallonsUSFluidPerSecondFlow) ToBase(gals float64) float64 {
	return gals * 0.00378541
}

// GallonsUSFluidPerSecondFlowMatchList is effectively a constant
var GallonsUSFluidPerSecondFlowMatchList = [...]string{"gal/s", "gals/s", "gals", "galss", "gps", "gallonspersecond", "gallonpersecond", "gallons/second", "gallon/second"}

// MatchList always returns GallonsUSFluidPerSecondFlowMatchList[:]
func (x GallonsUSFluidPerSecondFlow) MatchList() []string {
	return GallonsUSFluidPerSecondFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x GallonsUSFluidPerSecondFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x GallonsUSFluidPerSecondFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x GallonsUSFluidPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var GallonsUSFluidPerSecondFlowUnit GallonsUSFluidPerSecondFlow = 0.0

// GallonsUSFluidPerMinuteFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 15850.3           = gal/min
// Unit.ToBase  : galm => galm * 0.000,063,090,2 = m³/s
type GallonsUSFluidPerMinuteFlow Flow

// Title always returns "GallonsUSFluidPerMinute"
func (x GallonsUSFluidPerMinuteFlow) Title() string {
	return "GallonsUSFluidPerMinute"
}

// Name always returns "Gallons (U.S. Fluid) per Minute"
func (x GallonsUSFluidPerMinuteFlow) Name() string {
	return "Gallons (U.S. Fluid) per Minute"
}

// Symbol always returns "gal/min"
func (x GallonsUSFluidPerMinuteFlow) Symbol() string {
	return "gal/min"
}

// FromBase converts m³/s to gal/min
func (x GallonsUSFluidPerMinuteFlow) FromBase(m3s float64) float64 {
	return m3s * 15850.3
}

// ToBase converts gal/min to m³/s
func (x GallonsUSFluidPerMinuteFlow) ToBase(galm float64) float64 {
	return galm * 0.0000630902
}

// GallonsUSFluidPerMinuteFlowMatchList is effectively a constant
var GallonsUSFluidPerMinuteFlowMatchList = [...]string{"gal/m", "gals/m", "galm", "galsm", "gpm", "gallonsperminute", "gallonperminute", "gallonspermin", "gallonpermin", "gallons/minute", "gallons/min", "gallon/minute", "gallon/min"}

// MatchList always returns GallonsUSFluidPerMinuteFlowMatchList[:]
func (x GallonsUSFluidPerMinuteFlow) MatchList() []string {
	return GallonsUSFluidPerMinuteFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x GallonsUSFluidPerMinuteFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x GallonsUSFluidPerMinuteFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x GallonsUSFluidPerMinuteFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var GallonsUSFluidPerMinuteFlowUnit GallonsUSFluidPerMinuteFlow = 0.0

// BarrelsPerSecondFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 6.289,81    = bbl/s
// Unit.ToBase  : bbls => bbls * 0.158,987 = m³/s
type BarrelsPerSecondFlow Flow

// Title always returns "BarrelsPerSecond"
func (x BarrelsPerSecondFlow) Title() string {
	return "BarrelsPerSecond"
}

// Name always returns "Barrels per Second"
func (x BarrelsPerSecondFlow) Name() string {
	return "Barrels per Second"
}

// Symbol always returns "bbl/s"
func (x BarrelsPerSecondFlow) Symbol() string {
	return "bbl/s"
}

// FromBase converts m³/s to bbl/s
func (x BarrelsPerSecondFlow) FromBase(m3s float64) float64 {
	return m3s * 6.28981
}

// ToBase converts bbl/s to m³/s
func (x BarrelsPerSecondFlow) ToBase(bbls float64) float64 {
	return bbls * 0.158987
}

// BarrelsPerSecondFlowMatchList is effectively a constant
var BarrelsPerSecondFlowMatchList = [...]string{"bbl/s", "bbl/second", "bbls", "barrelpersecond", "barrelspersecond", "barrels/second", "barrel/second"}

// MatchList always returns BarrelsPerSecondFlowMatchList[:]
func (x BarrelsPerSecondFlow) MatchList() []string {
	return BarrelsPerSecondFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x BarrelsPerSecondFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x BarrelsPerSecondFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x BarrelsPerSecondFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var BarrelsPerSecondFlowUnit BarrelsPerSecondFlow = 0.0

// BarrelsPerMinuteFlow (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecondFlow
// Unit.FromBase: m3s => m3s * 377.389        = bbl/min
// Unit.ToBase  : bblm => bblm * 0.002,649,79 = m³/s
type BarrelsPerMinuteFlow Flow

// Title always returns "BarrelsPerMinute"
func (x BarrelsPerMinuteFlow) Title() string {
	return "BarrelsPerMinute"
}

// Name always returns "Barrels per Minute"
func (x BarrelsPerMinuteFlow) Name() string {
	return "Barrels per Minute"
}

// Symbol always returns "bbl/min"
func (x BarrelsPerMinuteFlow) Symbol() string {
	return "bbl/min"
}

// FromBase converts m³/s to bbl/min
func (x BarrelsPerMinuteFlow) FromBase(m3s float64) float64 {
	return m3s * 377.389
}

// ToBase converts bbl/min to m³/s
func (x BarrelsPerMinuteFlow) ToBase(bblm float64) float64 {
	return bblm * 0.00264979
}

// BarrelsPerMinuteFlowMatchList is effectively a constant
var BarrelsPerMinuteFlowMatchList = [...]string{"bbl/min", "bbl/minute", "bbl/m", "bblm", "barrelspermin", "barrelsperminute", "barrelpermin", "barrelperminute", "barrels/min", "barrels/minute", "barrel/min", "barrel/minute"}

// MatchList always returns BarrelsPerMinuteFlowMatchList[:]
func (x BarrelsPerMinuteFlow) MatchList() []string {
	return BarrelsPerMinuteFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x BarrelsPerMinuteFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FlowUnitType
func (x BarrelsPerMinuteFlow) TypeOf() UnitType {
	return FlowUnitType
}

// Base always returns CubicMetersPerSecondFlowUnit
func (x BarrelsPerMinuteFlow) Base() Unit {
	return CubicMetersPerSecondFlowUnit
}

var BarrelsPerMinuteFlowUnit BarrelsPerMinuteFlow = 0.0

// Volume (UnitType)
// Contains 7 units:
//  - CubicMetersVolume          m3 => m3               = m³
//  - CubicFeetVolume            m3 => m3 * 35.314,7    = cu ft
//  - ThousandsOfCubicFeetVolume m3 => m3 * 0.035,314,7 = MCF
//  - CubicDecimeterVolume       m3 => m3 * 1,000       = dm³
//  - LiterVolume                m3 => m3 * 1,000       = L
//  - GallonUSFluidVolume        m3 => m3 * 264.172     = gal (US)
//  - BarrelsOfOilVolume         m3 => m3 * 6.289,81    = bbl
// Base: CubicMetersVolume
type Volume float64

// Title always returns "Volume"
func (x Volume) Title() string {
	return "Volume"
}

// Name always returns "Volume"
func (x Volume) Name() string {
	return "Volume"
}

// Base always returns CubicMetersVolumeUnit
func (x Volume) Base() Unit {
	return CubicMetersVolumeUnit
}

// VolumeUnits is effectively a constant
var VolumeUnits = [...]Unit{CubicMetersVolumeUnit, CubicFeetVolumeUnit, ThousandsOfCubicFeetVolumeUnit, CubicDecimeterVolumeUnit, LiterVolumeUnit, GallonUSFluidVolumeUnit, BarrelsOfOilVolumeUnit}

// Units always returns VolumeUnits[:]
func (x Volume) Units() []Unit {
	return VolumeUnits[:]
}

// VolumeUnitList is effectively a constant
var VolumeUnitList = [...]string{"Cubic Meters", "Cubic Feet", "Thousands of Cubic Feet", "Cubic Decimeter", "Liter", "Gallon (U.S. Fluid)", "Barrels of Oil"}

// UnitList always returns VolumeUnitList[:]
func (x Volume) UnitList() []string {
	return VolumeUnitList[:]
}

// VolumeMatchList is effectively a constant
var VolumeMatchList = [...]string{"volume"}

// MatchList always returns VolumeMatchList[:]
func (x Volume) MatchList() []string {
	return VolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Volume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var VolumeUnitType Volume = 0.0

// CubicMetersVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 = m³
// Unit.ToBase  : m3 => m3 = m³
type CubicMetersVolume Volume

// Title always returns "CubicMeters"
func (x CubicMetersVolume) Title() string {
	return "CubicMeters"
}

// Name always returns "Cubic Meters"
func (x CubicMetersVolume) Name() string {
	return "Cubic Meters"
}

// Symbol always returns "m³"
func (x CubicMetersVolume) Symbol() string {
	return "m³"
}

// FromBase converts m³ to m³
func (x CubicMetersVolume) FromBase(m3 float64) float64 {
	return m3
}

// ToBase converts m³ to m³
func (x CubicMetersVolume) ToBase(m3 float64) float64 {
	return m3
}

// CubicMetersVolumeMatchList is effectively a constant
var CubicMetersVolumeMatchList = [...]string{"m³", "m3", "cubicmeter", "cubicmeters"}

// MatchList always returns CubicMetersVolumeMatchList[:]
func (x CubicMetersVolume) MatchList() []string {
	return CubicMetersVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMetersVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x CubicMetersVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x CubicMetersVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var CubicMetersVolumeUnit CubicMetersVolume = 0.0

// CubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 35.314,7        = cu ft
// Unit.ToBase  : cuft => cuft * 0.028,316,8 = m³
type CubicFeetVolume Volume

// Title always returns "CubicFeet"
func (x CubicFeetVolume) Title() string {
	return "CubicFeet"
}

// Name always returns "Cubic Feet"
func (x CubicFeetVolume) Name() string {
	return "Cubic Feet"
}

// Symbol always returns "cu ft"
func (x CubicFeetVolume) Symbol() string {
	return "cu ft"
}

// FromBase converts m³ to cu ft
func (x CubicFeetVolume) FromBase(m3 float64) float64 {
	return m3 * 35.3147
}

// ToBase converts cu ft to m³
func (x CubicFeetVolume) ToBase(cuft float64) float64 {
	return cuft * 0.0283168
}

// CubicFeetVolumeMatchList is effectively a constant
var CubicFeetVolumeMatchList = [...]string{"cuft", "ft³", "f³", "cubicfoot", "cubicfeet"}

// MatchList always returns CubicFeetVolumeMatchList[:]
func (x CubicFeetVolume) MatchList() []string {
	return CubicFeetVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x CubicFeetVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x CubicFeetVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var CubicFeetVolumeUnit CubicFeetVolume = 0.0

// ThousandsOfCubicFeetVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 0.035,314,7 = MCF
// Unit.ToBase  : MCF => MCF * 28.316,8  = m³
type ThousandsOfCubicFeetVolume Volume

// Title always returns "ThousandsOfCubicFeet"
func (x ThousandsOfCubicFeetVolume) Title() string {
	return "ThousandsOfCubicFeet"
}

// Name always returns "Thousands of Cubic Feet"
func (x ThousandsOfCubicFeetVolume) Name() string {
	return "Thousands of Cubic Feet"
}

// Symbol always returns "MCF"
func (x ThousandsOfCubicFeetVolume) Symbol() string {
	return "MCF"
}

// FromBase converts m³ to MCF
func (x ThousandsOfCubicFeetVolume) FromBase(m3 float64) float64 {
	return m3 * 0.0353147
}

// ToBase converts MCF to m³
func (x ThousandsOfCubicFeetVolume) ToBase(MCF float64) float64 {
	return MCF * 28.3168
}

// ThousandsOfCubicFeetVolumeMatchList is effectively a constant
var ThousandsOfCubicFeetVolumeMatchList = [...]string{"mcf", "mft³", "mf³", "thousandcubicfeet", "thousandsofcubicfeet", "thousandscubicfeet"}

// MatchList always returns ThousandsOfCubicFeetVolumeMatchList[:]
func (x ThousandsOfCubicFeetVolume) MatchList() []string {
	return ThousandsOfCubicFeetVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandsOfCubicFeetVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x ThousandsOfCubicFeetVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x ThousandsOfCubicFeetVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var ThousandsOfCubicFeetVolumeUnit ThousandsOfCubicFeetVolume = 0.0

// CubicDecimeterVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 1,000   = dm³
// Unit.ToBase  : dm3 => dm3 * 0.001 = m³
type CubicDecimeterVolume Volume

// Title always returns "CubicDecimeter"
func (x CubicDecimeterVolume) Title() string {
	return "CubicDecimeter"
}

// Name always returns "Cubic Decimeter"
func (x CubicDecimeterVolume) Name() string {
	return "Cubic Decimeter"
}

// Symbol always returns "dm³"
func (x CubicDecimeterVolume) Symbol() string {
	return "dm³"
}

// FromBase converts m³ to dm³
func (x CubicDecimeterVolume) FromBase(m3 float64) float64 {
	return m3 * 1000
}

// ToBase converts dm³ to m³
func (x CubicDecimeterVolume) ToBase(dm3 float64) float64 {
	return dm3 * 0.001
}

// CubicDecimeterVolumeMatchList is effectively a constant
var CubicDecimeterVolumeMatchList = [...]string{"dm³", "dm3", "cubicdecimeter", "cubicdecimeters"}

// MatchList always returns CubicDecimeterVolumeMatchList[:]
func (x CubicDecimeterVolume) MatchList() []string {
	return CubicDecimeterVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicDecimeterVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x CubicDecimeterVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x CubicDecimeterVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var CubicDecimeterVolumeUnit CubicDecimeterVolume = 0.0

// LiterVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 1,000 = L
// Unit.ToBase  : L => L * 0.001   = m³
type LiterVolume Volume

// Title always returns "Liter"
func (x LiterVolume) Title() string {
	return "Liter"
}

// Name always returns "Liter"
func (x LiterVolume) Name() string {
	return "Liter"
}

// Symbol always returns "L"
func (x LiterVolume) Symbol() string {
	return "L"
}

// FromBase converts m³ to L
func (x LiterVolume) FromBase(m3 float64) float64 {
	return m3 * 1000
}

// ToBase converts L to m³
func (x LiterVolume) ToBase(L float64) float64 {
	return L * 0.001
}

// LiterVolumeMatchList is effectively a constant
var LiterVolumeMatchList = [...]string{"l", "liter", "liters", "litre", "litres"}

// MatchList always returns LiterVolumeMatchList[:]
func (x LiterVolume) MatchList() []string {
	return LiterVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x LiterVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x LiterVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x LiterVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var LiterVolumeUnit LiterVolume = 0.0

// GallonUSFluidVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 264.172        = gal (US)
// Unit.ToBase  : gal => gal * 0.003,785,41 = m³
type GallonUSFluidVolume Volume

// Title always returns "GallonUSFluid"
func (x GallonUSFluidVolume) Title() string {
	return "GallonUSFluid"
}

// Name always returns "Gallon (U.S. Fluid)"
func (x GallonUSFluidVolume) Name() string {
	return "Gallon (U.S. Fluid)"
}

// Symbol always returns "gal (US)"
func (x GallonUSFluidVolume) Symbol() string {
	return "gal (US)"
}

// FromBase converts m³ to gal (US)
func (x GallonUSFluidVolume) FromBase(m3 float64) float64 {
	return m3 * 264.172
}

// ToBase converts gal (US) to m³
func (x GallonUSFluidVolume) ToBase(gal float64) float64 {
	return gal * 0.00378541
}

// GallonUSFluidVolumeMatchList is effectively a constant
var GallonUSFluidVolumeMatchList = [...]string{"gal", "gallon", "gals", "gallons", "gal(us)", "gallon(us)", "gals(us)", "gallons(us)", "gal(u.s.)", "gallon(u.s.)", "gals(u.s.)", "gallons(u.s.)", "gal(usfluid)", "gallon(usfluid)", "gals(usfluid)", "gallons(usfluid)", "gal(u.s.fluid)", "gallon(u.s.fluid)", "gals(u.s.fluid)", "gallons(u.s.fluid)"}

// MatchList always returns GallonUSFluidVolumeMatchList[:]
func (x GallonUSFluidVolume) MatchList() []string {
	return GallonUSFluidVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x GallonUSFluidVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x GallonUSFluidVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x GallonUSFluidVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var GallonUSFluidVolumeUnit GallonUSFluidVolume = 0.0

// BarrelsOfOilVolume (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMetersVolume
// Unit.FromBase: m3 => m3 * 6.289,81    = bbl
// Unit.ToBase  : bbl => bbl * 0.158,987 = m³
type BarrelsOfOilVolume Volume

// Title always returns "BarrelsOfOil"
func (x BarrelsOfOilVolume) Title() string {
	return "BarrelsOfOil"
}

// Name always returns "Barrels of Oil"
func (x BarrelsOfOilVolume) Name() string {
	return "Barrels of Oil"
}

// Symbol always returns "bbl"
func (x BarrelsOfOilVolume) Symbol() string {
	return "bbl"
}

// FromBase converts m³ to bbl
func (x BarrelsOfOilVolume) FromBase(m3 float64) float64 {
	return m3 * 6.28981
}

// ToBase converts bbl to m³
func (x BarrelsOfOilVolume) ToBase(bbl float64) float64 {
	return bbl * 0.158987
}

// BarrelsOfOilVolumeMatchList is effectively a constant
var BarrelsOfOilVolumeMatchList = [...]string{"bbl", "bbls", "barrelsofoil", "barrelofoil"}

// MatchList always returns BarrelsOfOilVolumeMatchList[:]
func (x BarrelsOfOilVolume) MatchList() []string {
	return BarrelsOfOilVolumeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x BarrelsOfOilVolume) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns VolumeUnitType
func (x BarrelsOfOilVolume) TypeOf() UnitType {
	return VolumeUnitType
}

// Base always returns CubicMetersVolumeUnit
func (x BarrelsOfOilVolume) Base() Unit {
	return CubicMetersVolumeUnit
}

var BarrelsOfOilVolumeUnit BarrelsOfOilVolume = 0.0

// Mass (UnitType)
// Contains 2 units:
//  - KilogramsMass kg => kg            = kg
//  - PoundsMass    kg => kg * 2.204,62 = lb
// Base: KilogramsMass
type Mass float64

// Title always returns "Mass"
func (x Mass) Title() string {
	return "Mass"
}

// Name always returns "Mass"
func (x Mass) Name() string {
	return "Mass"
}

// Base always returns KilogramsMassUnit
func (x Mass) Base() Unit {
	return KilogramsMassUnit
}

// MassUnits is effectively a constant
var MassUnits = [...]Unit{KilogramsMassUnit, PoundsMassUnit}

// Units always returns MassUnits[:]
func (x Mass) Units() []Unit {
	return MassUnits[:]
}

// MassUnitList is effectively a constant
var MassUnitList = [...]string{"Kilograms", "Pounds"}

// UnitList always returns MassUnitList[:]
func (x Mass) UnitList() []string {
	return MassUnitList[:]
}

// MassMatchList is effectively a constant
var MassMatchList = [...]string{"mass"}

// MatchList always returns MassMatchList[:]
func (x Mass) MatchList() []string {
	return MassMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Mass) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var MassUnitType Mass = 0.0

// KilogramsMass (Unit)
// UnitType     : Mass
// UnitType.Base: KilogramsMass
// Unit.FromBase: kg => kg = kg
// Unit.ToBase  : kg => kg = kg
type KilogramsMass Mass

// Title always returns "Kilograms"
func (x KilogramsMass) Title() string {
	return "Kilograms"
}

// Name always returns "Kilograms"
func (x KilogramsMass) Name() string {
	return "Kilograms"
}

// Symbol always returns "kg"
func (x KilogramsMass) Symbol() string {
	return "kg"
}

// FromBase converts kg to kg
func (x KilogramsMass) FromBase(kg float64) float64 {
	return kg
}

// ToBase converts kg to kg
func (x KilogramsMass) ToBase(kg float64) float64 {
	return kg
}

// KilogramsMassMatchList is effectively a constant
var KilogramsMassMatchList = [...]string{"kg", "kilogram", "kilo", "kgs", "kilograms", "kilos"}

// MatchList always returns KilogramsMassMatchList[:]
func (x KilogramsMass) MatchList() []string {
	return KilogramsMassMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsMass) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MassUnitType
func (x KilogramsMass) TypeOf() UnitType {
	return MassUnitType
}

// Base always returns KilogramsMassUnit
func (x KilogramsMass) Base() Unit {
	return KilogramsMassUnit
}

var KilogramsMassUnit KilogramsMass = 0.0

// PoundsMass (Unit)
// UnitType     : Mass
// UnitType.Base: KilogramsMass
// Unit.FromBase: kg => kg * 2.204,62  = lb
// Unit.ToBase  : lb => lb * 0.453,592 = kg
type PoundsMass Mass

// Title always returns "Pounds"
func (x PoundsMass) Title() string {
	return "Pounds"
}

// Name always returns "Pounds"
func (x PoundsMass) Name() string {
	return "Pounds"
}

// Symbol always returns "lb"
func (x PoundsMass) Symbol() string {
	return "lb"
}

// FromBase converts kg to lb
func (x PoundsMass) FromBase(kg float64) float64 {
	return kg * 2.20462
}

// ToBase converts lb to kg
func (x PoundsMass) ToBase(lb float64) float64 {
	return lb * 0.453592
}

// PoundsMassMatchList is effectively a constant
var PoundsMassMatchList = [...]string{"lb", "lbs", "pound", "pounds"}

// MatchList always returns PoundsMassMatchList[:]
func (x PoundsMass) MatchList() []string {
	return PoundsMassMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsMass) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MassUnitType
func (x PoundsMass) TypeOf() UnitType {
	return MassUnitType
}

// Base always returns KilogramsMassUnit
func (x PoundsMass) Base() Unit {
	return KilogramsMassUnit
}

var PoundsMassUnit PoundsMass = 0.0

// MassFlow (UnitType)
// Contains 3 units:
//  - KilogramsPerSecondMassFlow kgs => kgs            = kg/s
//  - PoundsPerSecondMassFlow    kgs => kgs * 2.204,62 = lb/s
//  - PoundsPerMinuteMassFlow    kgs => kgs * 132.277  = lb/min
// Base: KilogramsPerSecondMassFlow
type MassFlow float64

// Title always returns "MassFlow"
func (x MassFlow) Title() string {
	return "MassFlow"
}

// Name always returns "Mass Flow"
func (x MassFlow) Name() string {
	return "Mass Flow"
}

// Base always returns KilogramsPerSecondMassFlowUnit
func (x MassFlow) Base() Unit {
	return KilogramsPerSecondMassFlowUnit
}

// MassFlowUnits is effectively a constant
var MassFlowUnits = [...]Unit{KilogramsPerSecondMassFlowUnit, PoundsPerSecondMassFlowUnit, PoundsPerMinuteMassFlowUnit}

// Units always returns MassFlowUnits[:]
func (x MassFlow) Units() []Unit {
	return MassFlowUnits[:]
}

// MassFlowUnitList is effectively a constant
var MassFlowUnitList = [...]string{"Kilograms per Second", "Pounds per Second", "Pounds per Minute"}

// UnitList always returns MassFlowUnitList[:]
func (x MassFlow) UnitList() []string {
	return MassFlowUnitList[:]
}

// MassFlowMatchList is effectively a constant
var MassFlowMatchList = [...]string{"massflow", "massflowrate", "flow(mass)", "flowrate(mass)"}

// MatchList always returns MassFlowMatchList[:]
func (x MassFlow) MatchList() []string {
	return MassFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MassFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var MassFlowUnitType MassFlow = 0.0

// KilogramsPerSecondMassFlow (Unit)
// UnitType     : MassFlow
// UnitType.Base: KilogramsPerSecondMassFlow
// Unit.FromBase: kgs => kgs = kg/s
// Unit.ToBase  : kgs => kgs = kg/s
type KilogramsPerSecondMassFlow MassFlow

// Title always returns "KilogramsPerSecond"
func (x KilogramsPerSecondMassFlow) Title() string {
	return "KilogramsPerSecond"
}

// Name always returns "Kilograms per Second"
func (x KilogramsPerSecondMassFlow) Name() string {
	return "Kilograms per Second"
}

// Symbol always returns "kg/s"
func (x KilogramsPerSecondMassFlow) Symbol() string {
	return "kg/s"
}

// FromBase converts kg/s to kg/s
func (x KilogramsPerSecondMassFlow) FromBase(kgs float64) float64 {
	return kgs
}

// ToBase converts kg/s to kg/s
func (x KilogramsPerSecondMassFlow) ToBase(kgs float64) float64 {
	return kgs
}

// KilogramsPerSecondMassFlowMatchList is effectively a constant
var KilogramsPerSecondMassFlowMatchList = [...]string{"kg/s", "kgs", "kilogrampersecond", "kilopersecond", "kgpersecond", "kilogramspersecond", "kilospersecond", "kgspersecond", "kilogram/second", "kilo/second", "kg/second", "kilograms/second", "kilos/second", "kgs/second"}

// MatchList always returns KilogramsPerSecondMassFlowMatchList[:]
func (x KilogramsPerSecondMassFlow) MatchList() []string {
	return KilogramsPerSecondMassFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsPerSecondMassFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MassFlowUnitType
func (x KilogramsPerSecondMassFlow) TypeOf() UnitType {
	return MassFlowUnitType
}

// Base always returns KilogramsPerSecondMassFlowUnit
func (x KilogramsPerSecondMassFlow) Base() Unit {
	return KilogramsPerSecondMassFlowUnit
}

var KilogramsPerSecondMassFlowUnit KilogramsPerSecondMassFlow = 0.0

// PoundsPerSecondMassFlow (Unit)
// UnitType     : MassFlow
// UnitType.Base: KilogramsPerSecondMassFlow
// Unit.FromBase: kgs => kgs * 2.204,62  = lb/s
// Unit.ToBase  : lbs => lbs * 0.453,592 = kg/s
type PoundsPerSecondMassFlow MassFlow

// Title always returns "PoundsPerSecond"
func (x PoundsPerSecondMassFlow) Title() string {
	return "PoundsPerSecond"
}

// Name always returns "Pounds per Second"
func (x PoundsPerSecondMassFlow) Name() string {
	return "Pounds per Second"
}

// Symbol always returns "lb/s"
func (x PoundsPerSecondMassFlow) Symbol() string {
	return "lb/s"
}

// FromBase converts kg/s to lb/s
func (x PoundsPerSecondMassFlow) FromBase(kgs float64) float64 {
	return kgs * 2.20462
}

// ToBase converts lb/s to kg/s
func (x PoundsPerSecondMassFlow) ToBase(lbs float64) float64 {
	return lbs * 0.453592
}

// PoundsPerSecondMassFlowMatchList is effectively a constant
var PoundsPerSecondMassFlowMatchList = [...]string{"lb/s", "lbs/s", "lbs", "lbss", "poundpersecond", "poundspersecond", "pound/second", "pounds/second"}

// MatchList always returns PoundsPerSecondMassFlowMatchList[:]
func (x PoundsPerSecondMassFlow) MatchList() []string {
	return PoundsPerSecondMassFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsPerSecondMassFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MassFlowUnitType
func (x PoundsPerSecondMassFlow) TypeOf() UnitType {
	return MassFlowUnitType
}

// Base always returns KilogramsPerSecondMassFlowUnit
func (x PoundsPerSecondMassFlow) Base() Unit {
	return KilogramsPerSecondMassFlowUnit
}

var PoundsPerSecondMassFlowUnit PoundsPerSecondMassFlow = 0.0

// PoundsPerMinuteMassFlow (Unit)
// UnitType     : MassFlow
// UnitType.Base: KilogramsPerSecondMassFlow
// Unit.FromBase: kgs => kgs * 132.277          = lb/min
// Unit.ToBase  : lbmin => lbmin * 0.007,559,87 = kg/s
type PoundsPerMinuteMassFlow MassFlow

// Title always returns "PoundsPerMinute"
func (x PoundsPerMinuteMassFlow) Title() string {
	return "PoundsPerMinute"
}

// Name always returns "Pounds per Minute"
func (x PoundsPerMinuteMassFlow) Name() string {
	return "Pounds per Minute"
}

// Symbol always returns "lb/min"
func (x PoundsPerMinuteMassFlow) Symbol() string {
	return "lb/min"
}

// FromBase converts kg/s to lb/min
func (x PoundsPerMinuteMassFlow) FromBase(kgs float64) float64 {
	return kgs * 132.277
}

// ToBase converts lb/min to kg/s
func (x PoundsPerMinuteMassFlow) ToBase(lbmin float64) float64 {
	return lbmin * 0.00755987
}

// PoundsPerMinuteMassFlowMatchList is effectively a constant
var PoundsPerMinuteMassFlowMatchList = [...]string{"lb/min", "lbs/min", "lbmin", "lbsmin", "lb/m", "lbs/m", "lbm", "lbsm", "poundperminute", "poundsperminute", "pound/minute", "pounds/minute", "poundpermin", "poundspermin", "pound/min", "pounds/min"}

// MatchList always returns PoundsPerMinuteMassFlowMatchList[:]
func (x PoundsPerMinuteMassFlow) MatchList() []string {
	return PoundsPerMinuteMassFlowMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsPerMinuteMassFlow) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MassFlowUnitType
func (x PoundsPerMinuteMassFlow) TypeOf() UnitType {
	return MassFlowUnitType
}

// Base always returns KilogramsPerSecondMassFlowUnit
func (x PoundsPerMinuteMassFlow) Base() Unit {
	return KilogramsPerSecondMassFlowUnit
}

var PoundsPerMinuteMassFlowUnit PoundsPerMinuteMassFlow = 0.0

// ElectricPotential (UnitType)
// Contains 1 units:
//  - VoltsElectricPotential V => V = V
// Base: VoltsElectricPotential
type ElectricPotential float64

// Title always returns "ElectricPotential"
func (x ElectricPotential) Title() string {
	return "ElectricPotential"
}

// Name always returns "Electric Potential"
func (x ElectricPotential) Name() string {
	return "Electric Potential"
}

// Base always returns VoltsElectricPotentialUnit
func (x ElectricPotential) Base() Unit {
	return VoltsElectricPotentialUnit
}

// ElectricPotentialUnits is effectively a constant
var ElectricPotentialUnits = [...]Unit{VoltsElectricPotentialUnit}

// Units always returns ElectricPotentialUnits[:]
func (x ElectricPotential) Units() []Unit {
	return ElectricPotentialUnits[:]
}

// ElectricPotentialUnitList is effectively a constant
var ElectricPotentialUnitList = [...]string{"Volts"}

// UnitList always returns ElectricPotentialUnitList[:]
func (x ElectricPotential) UnitList() []string {
	return ElectricPotentialUnitList[:]
}

// ElectricPotentialMatchList is effectively a constant
var ElectricPotentialMatchList = [...]string{"electricpotential", "voltage"}

// MatchList always returns ElectricPotentialMatchList[:]
func (x ElectricPotential) MatchList() []string {
	return ElectricPotentialMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotential) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ElectricPotentialUnitType ElectricPotential = 0.0

// VoltsElectricPotential (Unit)
// UnitType     : ElectricPotential
// UnitType.Base: VoltsElectricPotential
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type VoltsElectricPotential ElectricPotential

// Title always returns "Volts"
func (x VoltsElectricPotential) Title() string {
	return "Volts"
}

// Name always returns "Volts"
func (x VoltsElectricPotential) Name() string {
	return "Volts"
}

// Symbol always returns "V"
func (x VoltsElectricPotential) Symbol() string {
	return "V"
}

// FromBase converts V to V
func (x VoltsElectricPotential) FromBase(V float64) float64 {
	return V
}

// ToBase converts V to V
func (x VoltsElectricPotential) ToBase(V float64) float64 {
	return V
}

// VoltsElectricPotentialMatchList is effectively a constant
var VoltsElectricPotentialMatchList = [...]string{"volt", "volts", "v"}

// MatchList always returns VoltsElectricPotentialMatchList[:]
func (x VoltsElectricPotential) MatchList() []string {
	return VoltsElectricPotentialMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x VoltsElectricPotential) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ElectricPotentialUnitType
func (x VoltsElectricPotential) TypeOf() UnitType {
	return ElectricPotentialUnitType
}

// Base always returns VoltsElectricPotentialUnit
func (x VoltsElectricPotential) Base() Unit {
	return VoltsElectricPotentialUnit
}

var VoltsElectricPotentialUnit VoltsElectricPotential = 0.0

// ElectricPotentialLoaded (UnitType)
// Contains 1 units:
//  - VoltsElectricPotentialLoaded V => V = V
// Base: VoltsElectricPotentialLoaded
type ElectricPotentialLoaded float64

// Title always returns "ElectricPotentialLoaded"
func (x ElectricPotentialLoaded) Title() string {
	return "ElectricPotentialLoaded"
}

// Name always returns "Electric Potential Loaded"
func (x ElectricPotentialLoaded) Name() string {
	return "Electric Potential Loaded"
}

// Base always returns VoltsElectricPotentialLoadedUnit
func (x ElectricPotentialLoaded) Base() Unit {
	return VoltsElectricPotentialLoadedUnit
}

// ElectricPotentialLoadedUnits is effectively a constant
var ElectricPotentialLoadedUnits = [...]Unit{VoltsElectricPotentialLoadedUnit}

// Units always returns ElectricPotentialLoadedUnits[:]
func (x ElectricPotentialLoaded) Units() []Unit {
	return ElectricPotentialLoadedUnits[:]
}

// ElectricPotentialLoadedUnitList is effectively a constant
var ElectricPotentialLoadedUnitList = [...]string{"Volts"}

// UnitList always returns ElectricPotentialLoadedUnitList[:]
func (x ElectricPotentialLoaded) UnitList() []string {
	return ElectricPotentialLoadedUnitList[:]
}

// ElectricPotentialLoadedMatchList is effectively a constant
var ElectricPotentialLoadedMatchList = [...]string{"electricpotentialloaded", "voltageloaded"}

// MatchList always returns ElectricPotentialLoadedMatchList[:]
func (x ElectricPotentialLoaded) MatchList() []string {
	return ElectricPotentialLoadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotentialLoaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ElectricPotentialLoadedUnitType ElectricPotentialLoaded = 0.0

// VoltsElectricPotentialLoaded (Unit)
// UnitType     : ElectricPotentialLoaded
// UnitType.Base: VoltsElectricPotentialLoaded
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type VoltsElectricPotentialLoaded ElectricPotentialLoaded

// Title always returns "Volts"
func (x VoltsElectricPotentialLoaded) Title() string {
	return "Volts"
}

// Name always returns "Volts"
func (x VoltsElectricPotentialLoaded) Name() string {
	return "Volts"
}

// Symbol always returns "V"
func (x VoltsElectricPotentialLoaded) Symbol() string {
	return "V"
}

// FromBase converts V to V
func (x VoltsElectricPotentialLoaded) FromBase(V float64) float64 {
	return V
}

// ToBase converts V to V
func (x VoltsElectricPotentialLoaded) ToBase(V float64) float64 {
	return V
}

// VoltsElectricPotentialLoadedMatchList is effectively a constant
var VoltsElectricPotentialLoadedMatchList = [...]string{"volt", "volts", "v"}

// MatchList always returns VoltsElectricPotentialLoadedMatchList[:]
func (x VoltsElectricPotentialLoaded) MatchList() []string {
	return VoltsElectricPotentialLoadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x VoltsElectricPotentialLoaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ElectricPotentialLoadedUnitType
func (x VoltsElectricPotentialLoaded) TypeOf() UnitType {
	return ElectricPotentialLoadedUnitType
}

// Base always returns VoltsElectricPotentialLoadedUnit
func (x VoltsElectricPotentialLoaded) Base() Unit {
	return VoltsElectricPotentialLoadedUnit
}

var VoltsElectricPotentialLoadedUnit VoltsElectricPotentialLoaded = 0.0

// ElectricPotentialUnloaded (UnitType)
// Contains 1 units:
//  - VoltsElectricPotentialUnloaded V => V = V
// Base: VoltsElectricPotentialUnloaded
type ElectricPotentialUnloaded float64

// Title always returns "ElectricPotentialUnloaded"
func (x ElectricPotentialUnloaded) Title() string {
	return "ElectricPotentialUnloaded"
}

// Name always returns "Electric Potential Unloaded"
func (x ElectricPotentialUnloaded) Name() string {
	return "Electric Potential Unloaded"
}

// Base always returns VoltsElectricPotentialUnloadedUnit
func (x ElectricPotentialUnloaded) Base() Unit {
	return VoltsElectricPotentialUnloadedUnit
}

// ElectricPotentialUnloadedUnits is effectively a constant
var ElectricPotentialUnloadedUnits = [...]Unit{VoltsElectricPotentialUnloadedUnit}

// Units always returns ElectricPotentialUnloadedUnits[:]
func (x ElectricPotentialUnloaded) Units() []Unit {
	return ElectricPotentialUnloadedUnits[:]
}

// ElectricPotentialUnloadedUnitList is effectively a constant
var ElectricPotentialUnloadedUnitList = [...]string{"Volts"}

// UnitList always returns ElectricPotentialUnloadedUnitList[:]
func (x ElectricPotentialUnloaded) UnitList() []string {
	return ElectricPotentialUnloadedUnitList[:]
}

// ElectricPotentialUnloadedMatchList is effectively a constant
var ElectricPotentialUnloadedMatchList = [...]string{"electricpotentialunloaded", "voltageunloaded"}

// MatchList always returns ElectricPotentialUnloadedMatchList[:]
func (x ElectricPotentialUnloaded) MatchList() []string {
	return ElectricPotentialUnloadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotentialUnloaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ElectricPotentialUnloadedUnitType ElectricPotentialUnloaded = 0.0

// VoltsElectricPotentialUnloaded (Unit)
// UnitType     : ElectricPotentialUnloaded
// UnitType.Base: VoltsElectricPotentialUnloaded
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type VoltsElectricPotentialUnloaded ElectricPotentialUnloaded

// Title always returns "Volts"
func (x VoltsElectricPotentialUnloaded) Title() string {
	return "Volts"
}

// Name always returns "Volts"
func (x VoltsElectricPotentialUnloaded) Name() string {
	return "Volts"
}

// Symbol always returns "V"
func (x VoltsElectricPotentialUnloaded) Symbol() string {
	return "V"
}

// FromBase converts V to V
func (x VoltsElectricPotentialUnloaded) FromBase(V float64) float64 {
	return V
}

// ToBase converts V to V
func (x VoltsElectricPotentialUnloaded) ToBase(V float64) float64 {
	return V
}

// VoltsElectricPotentialUnloadedMatchList is effectively a constant
var VoltsElectricPotentialUnloadedMatchList = [...]string{"volt", "volts", "v"}

// MatchList always returns VoltsElectricPotentialUnloadedMatchList[:]
func (x VoltsElectricPotentialUnloaded) MatchList() []string {
	return VoltsElectricPotentialUnloadedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x VoltsElectricPotentialUnloaded) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ElectricPotentialUnloadedUnitType
func (x VoltsElectricPotentialUnloaded) TypeOf() UnitType {
	return ElectricPotentialUnloadedUnitType
}

// Base always returns VoltsElectricPotentialUnloadedUnit
func (x VoltsElectricPotentialUnloaded) Base() Unit {
	return VoltsElectricPotentialUnloadedUnit
}

var VoltsElectricPotentialUnloadedUnit VoltsElectricPotentialUnloaded = 0.0

// Percentage (UnitType)
// Contains 1 units:
//  - PercentPercentage p => p = %
// Base: PercentPercentage
type Percentage float64

// Title always returns "Percentage"
func (x Percentage) Title() string {
	return "Percentage"
}

// Name always returns "Percentage"
func (x Percentage) Name() string {
	return "Percentage"
}

// Base always returns PercentPercentageUnit
func (x Percentage) Base() Unit {
	return PercentPercentageUnit
}

// PercentageUnits is effectively a constant
var PercentageUnits = [...]Unit{PercentPercentageUnit}

// Units always returns PercentageUnits[:]
func (x Percentage) Units() []Unit {
	return PercentageUnits[:]
}

// PercentageUnitList is effectively a constant
var PercentageUnitList = [...]string{"Percent"}

// UnitList always returns PercentageUnitList[:]
func (x Percentage) UnitList() []string {
	return PercentageUnitList[:]
}

// PercentageMatchList is effectively a constant
var PercentageMatchList = [...]string{"percentage"}

// MatchList always returns PercentageMatchList[:]
func (x Percentage) MatchList() []string {
	return PercentageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Percentage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var PercentageUnitType Percentage = 0.0

// PercentPercentage (Unit)
// UnitType     : Percentage
// UnitType.Base: PercentPercentage
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentPercentage Percentage

// Title always returns "Percent"
func (x PercentPercentage) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentPercentage) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentPercentage) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentPercentage) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentPercentage) ToBase(p float64) float64 {
	return p
}

// PercentPercentageMatchList is effectively a constant
var PercentPercentageMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentPercentageMatchList[:]
func (x PercentPercentage) MatchList() []string {
	return PercentPercentageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentPercentage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PercentageUnitType
func (x PercentPercentage) TypeOf() UnitType {
	return PercentageUnitType
}

// Base always returns PercentPercentageUnit
func (x PercentPercentage) Base() Unit {
	return PercentPercentageUnit
}

var PercentPercentageUnit PercentPercentage = 0.0

// Fillage (UnitType)
// Contains 1 units:
//  - PercentFillage p => p = %
// Base: PercentFillage
type Fillage float64

// Title always returns "Fillage"
func (x Fillage) Title() string {
	return "Fillage"
}

// Name always returns "Fillage"
func (x Fillage) Name() string {
	return "Fillage"
}

// Base always returns PercentFillageUnit
func (x Fillage) Base() Unit {
	return PercentFillageUnit
}

// FillageUnits is effectively a constant
var FillageUnits = [...]Unit{PercentFillageUnit}

// Units always returns FillageUnits[:]
func (x Fillage) Units() []Unit {
	return FillageUnits[:]
}

// FillageUnitList is effectively a constant
var FillageUnitList = [...]string{"Percent"}

// UnitList always returns FillageUnitList[:]
func (x Fillage) UnitList() []string {
	return FillageUnitList[:]
}

// FillageMatchList is effectively a constant
var FillageMatchList = [...]string{"fillage"}

// MatchList always returns FillageMatchList[:]
func (x Fillage) MatchList() []string {
	return FillageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Fillage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var FillageUnitType Fillage = 0.0

// PercentFillage (Unit)
// UnitType     : Fillage
// UnitType.Base: PercentFillage
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentFillage Fillage

// Title always returns "Percent"
func (x PercentFillage) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentFillage) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentFillage) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentFillage) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentFillage) ToBase(p float64) float64 {
	return p
}

// PercentFillageMatchList is effectively a constant
var PercentFillageMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentFillageMatchList[:]
func (x PercentFillage) MatchList() []string {
	return PercentFillageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentFillage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FillageUnitType
func (x PercentFillage) TypeOf() UnitType {
	return FillageUnitType
}

// Base always returns PercentFillageUnit
func (x PercentFillage) Base() Unit {
	return PercentFillageUnit
}

var PercentFillageUnit PercentFillage = 0.0

// PumpFillage (UnitType)
// Contains 1 units:
//  - PercentPumpFillage p => p = %
// Base: PercentPumpFillage
type PumpFillage float64

// Title always returns "PumpFillage"
func (x PumpFillage) Title() string {
	return "PumpFillage"
}

// Name always returns "Pump Fillage"
func (x PumpFillage) Name() string {
	return "Pump Fillage"
}

// Base always returns PercentPumpFillageUnit
func (x PumpFillage) Base() Unit {
	return PercentPumpFillageUnit
}

// PumpFillageUnits is effectively a constant
var PumpFillageUnits = [...]Unit{PercentPumpFillageUnit}

// Units always returns PumpFillageUnits[:]
func (x PumpFillage) Units() []Unit {
	return PumpFillageUnits[:]
}

// PumpFillageUnitList is effectively a constant
var PumpFillageUnitList = [...]string{"Percent"}

// UnitList always returns PumpFillageUnitList[:]
func (x PumpFillage) UnitList() []string {
	return PumpFillageUnitList[:]
}

// PumpFillageMatchList is effectively a constant
var PumpFillageMatchList = [...]string{"pumpfillage"}

// MatchList always returns PumpFillageMatchList[:]
func (x PumpFillage) MatchList() []string {
	return PumpFillageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PumpFillage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var PumpFillageUnitType PumpFillage = 0.0

// PercentPumpFillage (Unit)
// UnitType     : PumpFillage
// UnitType.Base: PercentPumpFillage
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentPumpFillage PumpFillage

// Title always returns "Percent"
func (x PercentPumpFillage) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentPumpFillage) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentPumpFillage) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentPumpFillage) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentPumpFillage) ToBase(p float64) float64 {
	return p
}

// PercentPumpFillageMatchList is effectively a constant
var PercentPumpFillageMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentPumpFillageMatchList[:]
func (x PercentPumpFillage) MatchList() []string {
	return PercentPumpFillageMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentPumpFillage) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns PumpFillageUnitType
func (x PercentPumpFillage) TypeOf() UnitType {
	return PumpFillageUnitType
}

// Base always returns PercentPumpFillageUnit
func (x PercentPumpFillage) Base() Unit {
	return PercentPumpFillageUnit
}

var PercentPumpFillageUnit PercentPumpFillage = 0.0

// Humidity (UnitType)
// Contains 1 units:
//  - PercentHumidity p => p = %
// Base: PercentHumidity
type Humidity float64

// Title always returns "Humidity"
func (x Humidity) Title() string {
	return "Humidity"
}

// Name always returns "Humidity"
func (x Humidity) Name() string {
	return "Humidity"
}

// Base always returns PercentHumidityUnit
func (x Humidity) Base() Unit {
	return PercentHumidityUnit
}

// HumidityUnits is effectively a constant
var HumidityUnits = [...]Unit{PercentHumidityUnit}

// Units always returns HumidityUnits[:]
func (x Humidity) Units() []Unit {
	return HumidityUnits[:]
}

// HumidityUnitList is effectively a constant
var HumidityUnitList = [...]string{"Percent"}

// UnitList always returns HumidityUnitList[:]
func (x Humidity) UnitList() []string {
	return HumidityUnitList[:]
}

// HumidityMatchList is effectively a constant
var HumidityMatchList = [...]string{"humidity"}

// MatchList always returns HumidityMatchList[:]
func (x Humidity) MatchList() []string {
	return HumidityMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Humidity) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var HumidityUnitType Humidity = 0.0

// PercentHumidity (Unit)
// UnitType     : Humidity
// UnitType.Base: PercentHumidity
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentHumidity Humidity

// Title always returns "Percent"
func (x PercentHumidity) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentHumidity) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentHumidity) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentHumidity) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentHumidity) ToBase(p float64) float64 {
	return p
}

// PercentHumidityMatchList is effectively a constant
var PercentHumidityMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentHumidityMatchList[:]
func (x PercentHumidity) MatchList() []string {
	return PercentHumidityMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentHumidity) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns HumidityUnitType
func (x PercentHumidity) TypeOf() UnitType {
	return HumidityUnitType
}

// Base always returns PercentHumidityUnit
func (x PercentHumidity) Base() Unit {
	return PercentHumidityUnit
}

var PercentHumidityUnit PercentHumidity = 0.0

// Alarm (UnitType)
// Contains 1 units:
//  - PercentAlarm p => p = %
// Base: PercentAlarm
type Alarm float64

// Title always returns "Alarm"
func (x Alarm) Title() string {
	return "Alarm"
}

// Name always returns "Alarm"
func (x Alarm) Name() string {
	return "Alarm"
}

// Base always returns PercentAlarmUnit
func (x Alarm) Base() Unit {
	return PercentAlarmUnit
}

// AlarmUnits is effectively a constant
var AlarmUnits = [...]Unit{PercentAlarmUnit}

// Units always returns AlarmUnits[:]
func (x Alarm) Units() []Unit {
	return AlarmUnits[:]
}

// AlarmUnitList is effectively a constant
var AlarmUnitList = [...]string{"Percent"}

// UnitList always returns AlarmUnitList[:]
func (x Alarm) UnitList() []string {
	return AlarmUnitList[:]
}

// AlarmMatchList is effectively a constant
var AlarmMatchList = [...]string{"alarm"}

// MatchList always returns AlarmMatchList[:]
func (x Alarm) MatchList() []string {
	return AlarmMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Alarm) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var AlarmUnitType Alarm = 0.0

// PercentAlarm (Unit)
// UnitType     : Alarm
// UnitType.Base: PercentAlarm
// Unit.FromBase: p => p = %
// Unit.ToBase  : p => p = %
type PercentAlarm Alarm

// Title always returns "Percent"
func (x PercentAlarm) Title() string {
	return "Percent"
}

// Name always returns "Percent"
func (x PercentAlarm) Name() string {
	return "Percent"
}

// Symbol always returns "%"
func (x PercentAlarm) Symbol() string {
	return "%"
}

// FromBase converts % to %
func (x PercentAlarm) FromBase(p float64) float64 {
	return p
}

// ToBase converts % to %
func (x PercentAlarm) ToBase(p float64) float64 {
	return p
}

// PercentAlarmMatchList is effectively a constant
var PercentAlarmMatchList = [...]string{"%", "percent", "percentage"}

// MatchList always returns PercentAlarmMatchList[:]
func (x PercentAlarm) MatchList() []string {
	return PercentAlarmMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PercentAlarm) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns AlarmUnitType
func (x PercentAlarm) TypeOf() UnitType {
	return AlarmUnitType
}

// Base always returns PercentAlarmUnit
func (x PercentAlarm) Base() Unit {
	return PercentAlarmUnit
}

var PercentAlarmUnit PercentAlarm = 0.0

// Work (UnitType)
// Contains 4 units:
//  - JoulesWork                 J => J                         = J
//  - InchPoundsForceWork        J => J * 8.850,74              = in lbf
//  - CubicFeetOfNaturalGasWork  J => J * 0.000,000,947,817     = BTUᵢₜ
//  - BarrelsOfOilEquivalentWork J => J * 0.000,000,000,163,399 = bboe
// Base: JoulesWork
type Work float64

// Title always returns "Work"
func (x Work) Title() string {
	return "Work"
}

// Name always returns "Work"
func (x Work) Name() string {
	return "Work"
}

// Base always returns JoulesWorkUnit
func (x Work) Base() Unit {
	return JoulesWorkUnit
}

// WorkUnits is effectively a constant
var WorkUnits = [...]Unit{JoulesWorkUnit, InchPoundsForceWorkUnit, CubicFeetOfNaturalGasWorkUnit, BarrelsOfOilEquivalentWorkUnit}

// Units always returns WorkUnits[:]
func (x Work) Units() []Unit {
	return WorkUnits[:]
}

// WorkUnitList is effectively a constant
var WorkUnitList = [...]string{"Joules", "Inch-pounds Force", "Cubic Feet of Natural Gas", "Barrels of Oil Equivalent"}

// UnitList always returns WorkUnitList[:]
func (x Work) UnitList() []string {
	return WorkUnitList[:]
}

// WorkMatchList is effectively a constant
var WorkMatchList = [...]string{"work"}

// MatchList always returns WorkMatchList[:]
func (x Work) MatchList() []string {
	return WorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Work) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var WorkUnitType Work = 0.0

// JoulesWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J = J
// Unit.ToBase  : J => J = J
type JoulesWork Work

// Title always returns "Joules"
func (x JoulesWork) Title() string {
	return "Joules"
}

// Name always returns "Joules"
func (x JoulesWork) Name() string {
	return "Joules"
}

// Symbol always returns "J"
func (x JoulesWork) Symbol() string {
	return "J"
}

// FromBase converts J to J
func (x JoulesWork) FromBase(J float64) float64 {
	return J
}

// ToBase converts J to J
func (x JoulesWork) ToBase(J float64) float64 {
	return J
}

// JoulesWorkMatchList is effectively a constant
var JoulesWorkMatchList = [...]string{"j", "joule", "joules"}

// MatchList always returns JoulesWorkMatchList[:]
func (x JoulesWork) MatchList() []string {
	return JoulesWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x JoulesWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x JoulesWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x JoulesWork) Base() Unit {
	return JoulesWorkUnit
}

var JoulesWorkUnit JoulesWork = 0.0

// InchPoundsForceWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 8.850,74          = in lbf
// Unit.ToBase  : inlbf => inlbf * 0.112,985 = J
type InchPoundsForceWork Work

// Title always returns "InchPoundsForce"
func (x InchPoundsForceWork) Title() string {
	return "InchPoundsForce"
}

// Name always returns "Inch-pounds Force"
func (x InchPoundsForceWork) Name() string {
	return "Inch-pounds Force"
}

// Symbol always returns "in lbf"
func (x InchPoundsForceWork) Symbol() string {
	return "in lbf"
}

// FromBase converts J to in lbf
func (x InchPoundsForceWork) FromBase(J float64) float64 {
	return J * 8.85074
}

// ToBase converts in lbf to J
func (x InchPoundsForceWork) ToBase(inlbf float64) float64 {
	return inlbf * 0.112985
}

// InchPoundsForceWorkMatchList is effectively a constant
var InchPoundsForceWorkMatchList = [...]string{"inlbf", "inch-poundsforce", "inch-poundforce", "in-lbf"}

// MatchList always returns InchPoundsForceWorkMatchList[:]
func (x InchPoundsForceWork) MatchList() []string {
	return InchPoundsForceWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchPoundsForceWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x InchPoundsForceWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x InchPoundsForceWork) Base() Unit {
	return JoulesWorkUnit
}

var InchPoundsForceWorkUnit InchPoundsForceWork = 0.0

// CubicFeetOfNaturalGasWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,947,817 = BTUᵢₜ
// Unit.ToBase  : btu => btu * 1,055,060     = J
type CubicFeetOfNaturalGasWork Work

// Title always returns "CubicFeetOfNaturalGas"
func (x CubicFeetOfNaturalGasWork) Title() string {
	return "CubicFeetOfNaturalGas"
}

// Name always returns "Cubic Feet of Natural Gas"
func (x CubicFeetOfNaturalGasWork) Name() string {
	return "Cubic Feet of Natural Gas"
}

// Symbol always returns "BTUᵢₜ"
func (x CubicFeetOfNaturalGasWork) Symbol() string {
	return "BTUᵢₜ"
}

// FromBase converts J to BTUᵢₜ
func (x CubicFeetOfNaturalGasWork) FromBase(J float64) float64 {
	return J * 0.000000947817
}

// ToBase converts BTUᵢₜ to J
func (x CubicFeetOfNaturalGasWork) ToBase(btu float64) float64 {
	return btu * 1055060
}

// CubicFeetOfNaturalGasWorkMatchList is effectively a constant
var CubicFeetOfNaturalGasWorkMatchList = [...]string{"btuᵢₜ", "btuit", "btu", "cubicfeetofnaturalgas"}

// MatchList always returns CubicFeetOfNaturalGasWorkMatchList[:]
func (x CubicFeetOfNaturalGasWork) MatchList() []string {
	return CubicFeetOfNaturalGasWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetOfNaturalGasWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x CubicFeetOfNaturalGasWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x CubicFeetOfNaturalGasWork) Base() Unit {
	return JoulesWorkUnit
}

var CubicFeetOfNaturalGasWorkUnit CubicFeetOfNaturalGasWork = 0.0

// BarrelsOfOilEquivalentWork (Unit)
// UnitType     : Work
// UnitType.Base: JoulesWork
// Unit.FromBase: J => J * 0.000,000,000,163,399 = bboe
// Unit.ToBase  : bboe => bboe * 6,120,000,000   = J
type BarrelsOfOilEquivalentWork Work

// Title always returns "BarrelsOfOilEquivalent"
func (x BarrelsOfOilEquivalentWork) Title() string {
	return "BarrelsOfOilEquivalent"
}

// Name always returns "Barrels of Oil Equivalent"
func (x BarrelsOfOilEquivalentWork) Name() string {
	return "Barrels of Oil Equivalent"
}

// Symbol always returns "bboe"
func (x BarrelsOfOilEquivalentWork) Symbol() string {
	return "bboe"
}

// FromBase converts J to bboe
func (x BarrelsOfOilEquivalentWork) FromBase(J float64) float64 {
	return J * 0.000000000163399
}

// ToBase converts bboe to J
func (x BarrelsOfOilEquivalentWork) ToBase(bboe float64) float64 {
	return bboe * 6120000000
}

// BarrelsOfOilEquivalentWorkMatchList is effectively a constant
var BarrelsOfOilEquivalentWorkMatchList = [...]string{"bboe", "barrelsofoilequivalent"}

// MatchList always returns BarrelsOfOilEquivalentWorkMatchList[:]
func (x BarrelsOfOilEquivalentWork) MatchList() []string {
	return BarrelsOfOilEquivalentWorkMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x BarrelsOfOilEquivalentWork) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WorkUnitType
func (x BarrelsOfOilEquivalentWork) TypeOf() UnitType {
	return WorkUnitType
}

// Base always returns JoulesWorkUnit
func (x BarrelsOfOilEquivalentWork) Base() Unit {
	return JoulesWorkUnit
}

var BarrelsOfOilEquivalentWorkUnit BarrelsOfOilEquivalentWork = 0.0

// Force (UnitType)
// Contains 3 units:
//  - NewtonsForce        N => N             = N
//  - PoundsForceForce    N => N * 0.224,809 = lbf
//  - KilogramsForceForce N => N * 0.101,972 = kgf
// Base: NewtonsForce
type Force float64

// Title always returns "Force"
func (x Force) Title() string {
	return "Force"
}

// Name always returns "Force"
func (x Force) Name() string {
	return "Force"
}

// Base always returns NewtonsForceUnit
func (x Force) Base() Unit {
	return NewtonsForceUnit
}

// ForceUnits is effectively a constant
var ForceUnits = [...]Unit{NewtonsForceUnit, PoundsForceForceUnit, KilogramsForceForceUnit}

// Units always returns ForceUnits[:]
func (x Force) Units() []Unit {
	return ForceUnits[:]
}

// ForceUnitList is effectively a constant
var ForceUnitList = [...]string{"Newtons", "Pounds-force", "Kilograms-force"}

// UnitList always returns ForceUnitList[:]
func (x Force) UnitList() []string {
	return ForceUnitList[:]
}

// ForceMatchList is effectively a constant
var ForceMatchList = [...]string{"force"}

// MatchList always returns ForceMatchList[:]
func (x Force) MatchList() []string {
	return ForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Force) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var ForceUnitType Force = 0.0

// NewtonsForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type NewtonsForce Force

// Title always returns "Newtons"
func (x NewtonsForce) Title() string {
	return "Newtons"
}

// Name always returns "Newtons"
func (x NewtonsForce) Name() string {
	return "Newtons"
}

// Symbol always returns "N"
func (x NewtonsForce) Symbol() string {
	return "N"
}

// FromBase converts N to N
func (x NewtonsForce) FromBase(N float64) float64 {
	return N
}

// ToBase converts N to N
func (x NewtonsForce) ToBase(N float64) float64 {
	return N
}

// NewtonsForceMatchList is effectively a constant
var NewtonsForceMatchList = [...]string{"n", "newton", "newtons"}

// MatchList always returns NewtonsForceMatchList[:]
func (x NewtonsForce) MatchList() []string {
	return NewtonsForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NewtonsForce) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ForceUnitType
func (x NewtonsForce) TypeOf() UnitType {
	return ForceUnitType
}

// Base always returns NewtonsForceUnit
func (x NewtonsForce) Base() Unit {
	return NewtonsForceUnit
}

var NewtonsForceUnit NewtonsForce = 0.0

// PoundsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForceForce Force

// Title always returns "PoundsForce"
func (x PoundsForceForce) Title() string {
	return "PoundsForce"
}

// Name always returns "Pounds-force"
func (x PoundsForceForce) Name() string {
	return "Pounds-force"
}

// Symbol always returns "lbf"
func (x PoundsForceForce) Symbol() string {
	return "lbf"
}

// FromBase converts N to lbf
func (x PoundsForceForce) FromBase(N float64) float64 {
	return N * 0.224809
}

// ToBase converts lbf to N
func (x PoundsForceForce) ToBase(lbf float64) float64 {
	return lbf * 4.44822
}

// PoundsForceForceMatchList is effectively a constant
var PoundsForceForceMatchList = [...]string{"lbf", "pounds-force", "poundsforce", "pound-force", "poundforce"}

// MatchList always returns PoundsForceForceMatchList[:]
func (x PoundsForceForce) MatchList() []string {
	return PoundsForceForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForceForce) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ForceUnitType
func (x PoundsForceForce) TypeOf() UnitType {
	return ForceUnitType
}

// Base always returns NewtonsForceUnit
func (x PoundsForceForce) Base() Unit {
	return NewtonsForceUnit
}

var PoundsForceForceUnit PoundsForceForce = 0.0

// KilogramsForceForce (Unit)
// UnitType     : Force
// UnitType.Base: NewtonsForce
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForceForce Force

// Title always returns "KilogramsForce"
func (x KilogramsForceForce) Title() string {
	return "KilogramsForce"
}

// Name always returns "Kilograms-force"
func (x KilogramsForceForce) Name() string {
	return "Kilograms-force"
}

// Symbol always returns "kgf"
func (x KilogramsForceForce) Symbol() string {
	return "kgf"
}

// FromBase converts N to kgf
func (x KilogramsForceForce) FromBase(N float64) float64 {
	return N * 0.101972
}

// ToBase converts kgf to N
func (x KilogramsForceForce) ToBase(kgf float64) float64 {
	return kgf * 9.80665
}

// KilogramsForceForceMatchList is effectively a constant
var KilogramsForceForceMatchList = [...]string{"kgf", "kilograms-force", "kilogram-force"}

// MatchList always returns KilogramsForceForceMatchList[:]
func (x KilogramsForceForce) MatchList() []string {
	return KilogramsForceForceMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForceForce) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns ForceUnitType
func (x KilogramsForceForce) TypeOf() UnitType {
	return ForceUnitType
}

// Base always returns NewtonsForceUnit
func (x KilogramsForceForce) Base() Unit {
	return NewtonsForceUnit
}

var KilogramsForceForceUnit KilogramsForceForce = 0.0

// Load (UnitType)
// Contains 3 units:
//  - NewtonsLoad        N => N             = N
//  - PoundsForceLoad    N => N * 0.224,809 = lbf
//  - KilogramsForceLoad N => N * 0.101,972 = kgf
// Base: NewtonsLoad
type Load float64

// Title always returns "Load"
func (x Load) Title() string {
	return "Load"
}

// Name always returns "Load"
func (x Load) Name() string {
	return "Load"
}

// Base always returns NewtonsLoadUnit
func (x Load) Base() Unit {
	return NewtonsLoadUnit
}

// LoadUnits is effectively a constant
var LoadUnits = [...]Unit{NewtonsLoadUnit, PoundsForceLoadUnit, KilogramsForceLoadUnit}

// Units always returns LoadUnits[:]
func (x Load) Units() []Unit {
	return LoadUnits[:]
}

// LoadUnitList is effectively a constant
var LoadUnitList = [...]string{"Newtons", "Pounds-force", "Kilograms-force"}

// UnitList always returns LoadUnitList[:]
func (x Load) UnitList() []string {
	return LoadUnitList[:]
}

// LoadMatchList is effectively a constant
var LoadMatchList = [...]string{"load"}

// MatchList always returns LoadMatchList[:]
func (x Load) MatchList() []string {
	return LoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Load) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var LoadUnitType Load = 0.0

// NewtonsLoad (Unit)
// UnitType     : Load
// UnitType.Base: NewtonsLoad
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type NewtonsLoad Load

// Title always returns "Newtons"
func (x NewtonsLoad) Title() string {
	return "Newtons"
}

// Name always returns "Newtons"
func (x NewtonsLoad) Name() string {
	return "Newtons"
}

// Symbol always returns "N"
func (x NewtonsLoad) Symbol() string {
	return "N"
}

// FromBase converts N to N
func (x NewtonsLoad) FromBase(N float64) float64 {
	return N
}

// ToBase converts N to N
func (x NewtonsLoad) ToBase(N float64) float64 {
	return N
}

// NewtonsLoadMatchList is effectively a constant
var NewtonsLoadMatchList = [...]string{"n", "newton", "newtons"}

// MatchList always returns NewtonsLoadMatchList[:]
func (x NewtonsLoad) MatchList() []string {
	return NewtonsLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NewtonsLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LoadUnitType
func (x NewtonsLoad) TypeOf() UnitType {
	return LoadUnitType
}

// Base always returns NewtonsLoadUnit
func (x NewtonsLoad) Base() Unit {
	return NewtonsLoadUnit
}

var NewtonsLoadUnit NewtonsLoad = 0.0

// PoundsForceLoad (Unit)
// UnitType     : Load
// UnitType.Base: NewtonsLoad
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForceLoad Load

// Title always returns "PoundsForce"
func (x PoundsForceLoad) Title() string {
	return "PoundsForce"
}

// Name always returns "Pounds-force"
func (x PoundsForceLoad) Name() string {
	return "Pounds-force"
}

// Symbol always returns "lbf"
func (x PoundsForceLoad) Symbol() string {
	return "lbf"
}

// FromBase converts N to lbf
func (x PoundsForceLoad) FromBase(N float64) float64 {
	return N * 0.224809
}

// ToBase converts lbf to N
func (x PoundsForceLoad) ToBase(lbf float64) float64 {
	return lbf * 4.44822
}

// PoundsForceLoadMatchList is effectively a constant
var PoundsForceLoadMatchList = [...]string{"lbf", "pounds-force", "poundsforce", "pound-force", "poundforce"}

// MatchList always returns PoundsForceLoadMatchList[:]
func (x PoundsForceLoad) MatchList() []string {
	return PoundsForceLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForceLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LoadUnitType
func (x PoundsForceLoad) TypeOf() UnitType {
	return LoadUnitType
}

// Base always returns NewtonsLoadUnit
func (x PoundsForceLoad) Base() Unit {
	return NewtonsLoadUnit
}

var PoundsForceLoadUnit PoundsForceLoad = 0.0

// KilogramsForceLoad (Unit)
// UnitType     : Load
// UnitType.Base: NewtonsLoad
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForceLoad Load

// Title always returns "KilogramsForce"
func (x KilogramsForceLoad) Title() string {
	return "KilogramsForce"
}

// Name always returns "Kilograms-force"
func (x KilogramsForceLoad) Name() string {
	return "Kilograms-force"
}

// Symbol always returns "kgf"
func (x KilogramsForceLoad) Symbol() string {
	return "kgf"
}

// FromBase converts N to kgf
func (x KilogramsForceLoad) FromBase(N float64) float64 {
	return N * 0.101972
}

// ToBase converts kgf to N
func (x KilogramsForceLoad) ToBase(kgf float64) float64 {
	return kgf * 9.80665
}

// KilogramsForceLoadMatchList is effectively a constant
var KilogramsForceLoadMatchList = [...]string{"kgf", "kilograms-force", "kilogram-force"}

// MatchList always returns KilogramsForceLoadMatchList[:]
func (x KilogramsForceLoad) MatchList() []string {
	return KilogramsForceLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForceLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LoadUnitType
func (x KilogramsForceLoad) TypeOf() UnitType {
	return LoadUnitType
}

// Base always returns NewtonsLoadUnit
func (x KilogramsForceLoad) Base() Unit {
	return NewtonsLoadUnit
}

var KilogramsForceLoadUnit KilogramsForceLoad = 0.0

// MaxLoad (UnitType)
// Contains 3 units:
//  - NewtonsMaxLoad        N => N             = N
//  - PoundsForceMaxLoad    N => N * 0.224,809 = lbf
//  - KilogramsForceMaxLoad N => N * 0.101,972 = kgf
// Base: NewtonsMaxLoad
type MaxLoad float64

// Title always returns "MaxLoad"
func (x MaxLoad) Title() string {
	return "MaxLoad"
}

// Name always returns "Max Load"
func (x MaxLoad) Name() string {
	return "Max Load"
}

// Base always returns NewtonsMaxLoadUnit
func (x MaxLoad) Base() Unit {
	return NewtonsMaxLoadUnit
}

// MaxLoadUnits is effectively a constant
var MaxLoadUnits = [...]Unit{NewtonsMaxLoadUnit, PoundsForceMaxLoadUnit, KilogramsForceMaxLoadUnit}

// Units always returns MaxLoadUnits[:]
func (x MaxLoad) Units() []Unit {
	return MaxLoadUnits[:]
}

// MaxLoadUnitList is effectively a constant
var MaxLoadUnitList = [...]string{"Newtons", "Pounds-force", "Kilograms-force"}

// UnitList always returns MaxLoadUnitList[:]
func (x MaxLoad) UnitList() []string {
	return MaxLoadUnitList[:]
}

// MaxLoadMatchList is effectively a constant
var MaxLoadMatchList = [...]string{"maxload"}

// MatchList always returns MaxLoadMatchList[:]
func (x MaxLoad) MatchList() []string {
	return MaxLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MaxLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var MaxLoadUnitType MaxLoad = 0.0

// NewtonsMaxLoad (Unit)
// UnitType     : MaxLoad
// UnitType.Base: NewtonsMaxLoad
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type NewtonsMaxLoad MaxLoad

// Title always returns "Newtons"
func (x NewtonsMaxLoad) Title() string {
	return "Newtons"
}

// Name always returns "Newtons"
func (x NewtonsMaxLoad) Name() string {
	return "Newtons"
}

// Symbol always returns "N"
func (x NewtonsMaxLoad) Symbol() string {
	return "N"
}

// FromBase converts N to N
func (x NewtonsMaxLoad) FromBase(N float64) float64 {
	return N
}

// ToBase converts N to N
func (x NewtonsMaxLoad) ToBase(N float64) float64 {
	return N
}

// NewtonsMaxLoadMatchList is effectively a constant
var NewtonsMaxLoadMatchList = [...]string{"n", "newton", "newtons"}

// MatchList always returns NewtonsMaxLoadMatchList[:]
func (x NewtonsMaxLoad) MatchList() []string {
	return NewtonsMaxLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NewtonsMaxLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MaxLoadUnitType
func (x NewtonsMaxLoad) TypeOf() UnitType {
	return MaxLoadUnitType
}

// Base always returns NewtonsMaxLoadUnit
func (x NewtonsMaxLoad) Base() Unit {
	return NewtonsMaxLoadUnit
}

var NewtonsMaxLoadUnit NewtonsMaxLoad = 0.0

// PoundsForceMaxLoad (Unit)
// UnitType     : MaxLoad
// UnitType.Base: NewtonsMaxLoad
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForceMaxLoad MaxLoad

// Title always returns "PoundsForce"
func (x PoundsForceMaxLoad) Title() string {
	return "PoundsForce"
}

// Name always returns "Pounds-force"
func (x PoundsForceMaxLoad) Name() string {
	return "Pounds-force"
}

// Symbol always returns "lbf"
func (x PoundsForceMaxLoad) Symbol() string {
	return "lbf"
}

// FromBase converts N to lbf
func (x PoundsForceMaxLoad) FromBase(N float64) float64 {
	return N * 0.224809
}

// ToBase converts lbf to N
func (x PoundsForceMaxLoad) ToBase(lbf float64) float64 {
	return lbf * 4.44822
}

// PoundsForceMaxLoadMatchList is effectively a constant
var PoundsForceMaxLoadMatchList = [...]string{"lbf", "pounds-force", "poundsforce", "pound-force", "poundforce"}

// MatchList always returns PoundsForceMaxLoadMatchList[:]
func (x PoundsForceMaxLoad) MatchList() []string {
	return PoundsForceMaxLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForceMaxLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MaxLoadUnitType
func (x PoundsForceMaxLoad) TypeOf() UnitType {
	return MaxLoadUnitType
}

// Base always returns NewtonsMaxLoadUnit
func (x PoundsForceMaxLoad) Base() Unit {
	return NewtonsMaxLoadUnit
}

var PoundsForceMaxLoadUnit PoundsForceMaxLoad = 0.0

// KilogramsForceMaxLoad (Unit)
// UnitType     : MaxLoad
// UnitType.Base: NewtonsMaxLoad
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForceMaxLoad MaxLoad

// Title always returns "KilogramsForce"
func (x KilogramsForceMaxLoad) Title() string {
	return "KilogramsForce"
}

// Name always returns "Kilograms-force"
func (x KilogramsForceMaxLoad) Name() string {
	return "Kilograms-force"
}

// Symbol always returns "kgf"
func (x KilogramsForceMaxLoad) Symbol() string {
	return "kgf"
}

// FromBase converts N to kgf
func (x KilogramsForceMaxLoad) FromBase(N float64) float64 {
	return N * 0.101972
}

// ToBase converts kgf to N
func (x KilogramsForceMaxLoad) ToBase(kgf float64) float64 {
	return kgf * 9.80665
}

// KilogramsForceMaxLoadMatchList is effectively a constant
var KilogramsForceMaxLoadMatchList = [...]string{"kgf", "kilograms-force", "kilogram-force"}

// MatchList always returns KilogramsForceMaxLoadMatchList[:]
func (x KilogramsForceMaxLoad) MatchList() []string {
	return KilogramsForceMaxLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForceMaxLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MaxLoadUnitType
func (x KilogramsForceMaxLoad) TypeOf() UnitType {
	return MaxLoadUnitType
}

// Base always returns NewtonsMaxLoadUnit
func (x KilogramsForceMaxLoad) Base() Unit {
	return NewtonsMaxLoadUnit
}

var KilogramsForceMaxLoadUnit KilogramsForceMaxLoad = 0.0

// MinLoad (UnitType)
// Contains 3 units:
//  - NewtonsMinLoad        N => N             = N
//  - PoundsForceMinLoad    N => N * 0.224,809 = lbf
//  - KilogramsForceMinLoad N => N * 0.101,972 = kgf
// Base: NewtonsMinLoad
type MinLoad float64

// Title always returns "MinLoad"
func (x MinLoad) Title() string {
	return "MinLoad"
}

// Name always returns "Min Load"
func (x MinLoad) Name() string {
	return "Min Load"
}

// Base always returns NewtonsMinLoadUnit
func (x MinLoad) Base() Unit {
	return NewtonsMinLoadUnit
}

// MinLoadUnits is effectively a constant
var MinLoadUnits = [...]Unit{NewtonsMinLoadUnit, PoundsForceMinLoadUnit, KilogramsForceMinLoadUnit}

// Units always returns MinLoadUnits[:]
func (x MinLoad) Units() []Unit {
	return MinLoadUnits[:]
}

// MinLoadUnitList is effectively a constant
var MinLoadUnitList = [...]string{"Newtons", "Pounds-force", "Kilograms-force"}

// UnitList always returns MinLoadUnitList[:]
func (x MinLoad) UnitList() []string {
	return MinLoadUnitList[:]
}

// MinLoadMatchList is effectively a constant
var MinLoadMatchList = [...]string{"minload"}

// MatchList always returns MinLoadMatchList[:]
func (x MinLoad) MatchList() []string {
	return MinLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MinLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var MinLoadUnitType MinLoad = 0.0

// NewtonsMinLoad (Unit)
// UnitType     : MinLoad
// UnitType.Base: NewtonsMinLoad
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type NewtonsMinLoad MinLoad

// Title always returns "Newtons"
func (x NewtonsMinLoad) Title() string {
	return "Newtons"
}

// Name always returns "Newtons"
func (x NewtonsMinLoad) Name() string {
	return "Newtons"
}

// Symbol always returns "N"
func (x NewtonsMinLoad) Symbol() string {
	return "N"
}

// FromBase converts N to N
func (x NewtonsMinLoad) FromBase(N float64) float64 {
	return N
}

// ToBase converts N to N
func (x NewtonsMinLoad) ToBase(N float64) float64 {
	return N
}

// NewtonsMinLoadMatchList is effectively a constant
var NewtonsMinLoadMatchList = [...]string{"n", "newton", "newtons"}

// MatchList always returns NewtonsMinLoadMatchList[:]
func (x NewtonsMinLoad) MatchList() []string {
	return NewtonsMinLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NewtonsMinLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MinLoadUnitType
func (x NewtonsMinLoad) TypeOf() UnitType {
	return MinLoadUnitType
}

// Base always returns NewtonsMinLoadUnit
func (x NewtonsMinLoad) Base() Unit {
	return NewtonsMinLoadUnit
}

var NewtonsMinLoadUnit NewtonsMinLoad = 0.0

// PoundsForceMinLoad (Unit)
// UnitType     : MinLoad
// UnitType.Base: NewtonsMinLoad
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForceMinLoad MinLoad

// Title always returns "PoundsForce"
func (x PoundsForceMinLoad) Title() string {
	return "PoundsForce"
}

// Name always returns "Pounds-force"
func (x PoundsForceMinLoad) Name() string {
	return "Pounds-force"
}

// Symbol always returns "lbf"
func (x PoundsForceMinLoad) Symbol() string {
	return "lbf"
}

// FromBase converts N to lbf
func (x PoundsForceMinLoad) FromBase(N float64) float64 {
	return N * 0.224809
}

// ToBase converts lbf to N
func (x PoundsForceMinLoad) ToBase(lbf float64) float64 {
	return lbf * 4.44822
}

// PoundsForceMinLoadMatchList is effectively a constant
var PoundsForceMinLoadMatchList = [...]string{"lbf", "pounds-force", "poundsforce", "pound-force", "poundforce"}

// MatchList always returns PoundsForceMinLoadMatchList[:]
func (x PoundsForceMinLoad) MatchList() []string {
	return PoundsForceMinLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForceMinLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MinLoadUnitType
func (x PoundsForceMinLoad) TypeOf() UnitType {
	return MinLoadUnitType
}

// Base always returns NewtonsMinLoadUnit
func (x PoundsForceMinLoad) Base() Unit {
	return NewtonsMinLoadUnit
}

var PoundsForceMinLoadUnit PoundsForceMinLoad = 0.0

// KilogramsForceMinLoad (Unit)
// UnitType     : MinLoad
// UnitType.Base: NewtonsMinLoad
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForceMinLoad MinLoad

// Title always returns "KilogramsForce"
func (x KilogramsForceMinLoad) Title() string {
	return "KilogramsForce"
}

// Name always returns "Kilograms-force"
func (x KilogramsForceMinLoad) Name() string {
	return "Kilograms-force"
}

// Symbol always returns "kgf"
func (x KilogramsForceMinLoad) Symbol() string {
	return "kgf"
}

// FromBase converts N to kgf
func (x KilogramsForceMinLoad) FromBase(N float64) float64 {
	return N * 0.101972
}

// ToBase converts kgf to N
func (x KilogramsForceMinLoad) ToBase(kgf float64) float64 {
	return kgf * 9.80665
}

// KilogramsForceMinLoadMatchList is effectively a constant
var KilogramsForceMinLoadMatchList = [...]string{"kgf", "kilograms-force", "kilogram-force"}

// MatchList always returns KilogramsForceMinLoadMatchList[:]
func (x KilogramsForceMinLoad) MatchList() []string {
	return KilogramsForceMinLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForceMinLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns MinLoadUnitType
func (x KilogramsForceMinLoad) TypeOf() UnitType {
	return MinLoadUnitType
}

// Base always returns NewtonsMinLoadUnit
func (x KilogramsForceMinLoad) Base() Unit {
	return NewtonsMinLoadUnit
}

var KilogramsForceMinLoadUnit KilogramsForceMinLoad = 0.0

// FluidLoad (UnitType)
// Contains 3 units:
//  - NewtonsFluidLoad        N => N             = N
//  - PoundsForceFluidLoad    N => N * 0.224,809 = lbf
//  - KilogramsForceFluidLoad N => N * 0.101,972 = kgf
// Base: NewtonsFluidLoad
type FluidLoad float64

// Title always returns "FluidLoad"
func (x FluidLoad) Title() string {
	return "FluidLoad"
}

// Name always returns "Fluid Load"
func (x FluidLoad) Name() string {
	return "Fluid Load"
}

// Base always returns NewtonsFluidLoadUnit
func (x FluidLoad) Base() Unit {
	return NewtonsFluidLoadUnit
}

// FluidLoadUnits is effectively a constant
var FluidLoadUnits = [...]Unit{NewtonsFluidLoadUnit, PoundsForceFluidLoadUnit, KilogramsForceFluidLoadUnit}

// Units always returns FluidLoadUnits[:]
func (x FluidLoad) Units() []Unit {
	return FluidLoadUnits[:]
}

// FluidLoadUnitList is effectively a constant
var FluidLoadUnitList = [...]string{"Newtons", "Pounds-force", "Kilograms-force"}

// UnitList always returns FluidLoadUnitList[:]
func (x FluidLoad) UnitList() []string {
	return FluidLoadUnitList[:]
}

// FluidLoadMatchList is effectively a constant
var FluidLoadMatchList = [...]string{"fluidload"}

// MatchList always returns FluidLoadMatchList[:]
func (x FluidLoad) MatchList() []string {
	return FluidLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x FluidLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var FluidLoadUnitType FluidLoad = 0.0

// NewtonsFluidLoad (Unit)
// UnitType     : FluidLoad
// UnitType.Base: NewtonsFluidLoad
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type NewtonsFluidLoad FluidLoad

// Title always returns "Newtons"
func (x NewtonsFluidLoad) Title() string {
	return "Newtons"
}

// Name always returns "Newtons"
func (x NewtonsFluidLoad) Name() string {
	return "Newtons"
}

// Symbol always returns "N"
func (x NewtonsFluidLoad) Symbol() string {
	return "N"
}

// FromBase converts N to N
func (x NewtonsFluidLoad) FromBase(N float64) float64 {
	return N
}

// ToBase converts N to N
func (x NewtonsFluidLoad) ToBase(N float64) float64 {
	return N
}

// NewtonsFluidLoadMatchList is effectively a constant
var NewtonsFluidLoadMatchList = [...]string{"n", "newton", "newtons"}

// MatchList always returns NewtonsFluidLoadMatchList[:]
func (x NewtonsFluidLoad) MatchList() []string {
	return NewtonsFluidLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NewtonsFluidLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FluidLoadUnitType
func (x NewtonsFluidLoad) TypeOf() UnitType {
	return FluidLoadUnitType
}

// Base always returns NewtonsFluidLoadUnit
func (x NewtonsFluidLoad) Base() Unit {
	return NewtonsFluidLoadUnit
}

var NewtonsFluidLoadUnit NewtonsFluidLoad = 0.0

// PoundsForceFluidLoad (Unit)
// UnitType     : FluidLoad
// UnitType.Base: NewtonsFluidLoad
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForceFluidLoad FluidLoad

// Title always returns "PoundsForce"
func (x PoundsForceFluidLoad) Title() string {
	return "PoundsForce"
}

// Name always returns "Pounds-force"
func (x PoundsForceFluidLoad) Name() string {
	return "Pounds-force"
}

// Symbol always returns "lbf"
func (x PoundsForceFluidLoad) Symbol() string {
	return "lbf"
}

// FromBase converts N to lbf
func (x PoundsForceFluidLoad) FromBase(N float64) float64 {
	return N * 0.224809
}

// ToBase converts lbf to N
func (x PoundsForceFluidLoad) ToBase(lbf float64) float64 {
	return lbf * 4.44822
}

// PoundsForceFluidLoadMatchList is effectively a constant
var PoundsForceFluidLoadMatchList = [...]string{"lbf", "pounds-force", "poundsforce", "pound-force", "poundforce"}

// MatchList always returns PoundsForceFluidLoadMatchList[:]
func (x PoundsForceFluidLoad) MatchList() []string {
	return PoundsForceFluidLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForceFluidLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FluidLoadUnitType
func (x PoundsForceFluidLoad) TypeOf() UnitType {
	return FluidLoadUnitType
}

// Base always returns NewtonsFluidLoadUnit
func (x PoundsForceFluidLoad) Base() Unit {
	return NewtonsFluidLoadUnit
}

var PoundsForceFluidLoadUnit PoundsForceFluidLoad = 0.0

// KilogramsForceFluidLoad (Unit)
// UnitType     : FluidLoad
// UnitType.Base: NewtonsFluidLoad
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForceFluidLoad FluidLoad

// Title always returns "KilogramsForce"
func (x KilogramsForceFluidLoad) Title() string {
	return "KilogramsForce"
}

// Name always returns "Kilograms-force"
func (x KilogramsForceFluidLoad) Name() string {
	return "Kilograms-force"
}

// Symbol always returns "kgf"
func (x KilogramsForceFluidLoad) Symbol() string {
	return "kgf"
}

// FromBase converts N to kgf
func (x KilogramsForceFluidLoad) FromBase(N float64) float64 {
	return N * 0.101972
}

// ToBase converts kgf to N
func (x KilogramsForceFluidLoad) ToBase(kgf float64) float64 {
	return kgf * 9.80665
}

// KilogramsForceFluidLoadMatchList is effectively a constant
var KilogramsForceFluidLoadMatchList = [...]string{"kgf", "kilograms-force", "kilogram-force"}

// MatchList always returns KilogramsForceFluidLoadMatchList[:]
func (x KilogramsForceFluidLoad) MatchList() []string {
	return KilogramsForceFluidLoadMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForceFluidLoad) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns FluidLoadUnitType
func (x KilogramsForceFluidLoad) TypeOf() UnitType {
	return FluidLoadUnitType
}

// Base always returns NewtonsFluidLoadUnit
func (x KilogramsForceFluidLoad) Base() Unit {
	return NewtonsFluidLoadUnit
}

var KilogramsForceFluidLoadUnit KilogramsForceFluidLoad = 0.0

// Length (UnitType)
// Contains 3 units:
//  - MetersLength m => m            = m
//  - FeetLength   m => m * 3.280,84 = ft
//  - InchesLength m => m * 39.370,1 = in
// Base: MetersLength
type Length float64

// Title always returns "Length"
func (x Length) Title() string {
	return "Length"
}

// Name always returns "Length"
func (x Length) Name() string {
	return "Length"
}

// Base always returns MetersLengthUnit
func (x Length) Base() Unit {
	return MetersLengthUnit
}

// LengthUnits is effectively a constant
var LengthUnits = [...]Unit{MetersLengthUnit, FeetLengthUnit, InchesLengthUnit}

// Units always returns LengthUnits[:]
func (x Length) Units() []Unit {
	return LengthUnits[:]
}

// LengthUnitList is effectively a constant
var LengthUnitList = [...]string{"Meters", "Feet", "Inches"}

// UnitList always returns LengthUnitList[:]
func (x Length) UnitList() []string {
	return LengthUnitList[:]
}

// LengthMatchList is effectively a constant
var LengthMatchList = [...]string{"l", "length"}

// MatchList always returns LengthMatchList[:]
func (x Length) MatchList() []string {
	return LengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Length) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var LengthUnitType Length = 0.0

// MetersLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m
type MetersLength Length

// Title always returns "Meters"
func (x MetersLength) Title() string {
	return "Meters"
}

// Name always returns "Meters"
func (x MetersLength) Name() string {
	return "Meters"
}

// Symbol always returns "m"
func (x MetersLength) Symbol() string {
	return "m"
}

// FromBase converts m to m
func (x MetersLength) FromBase(m float64) float64 {
	return m
}

// ToBase converts m to m
func (x MetersLength) ToBase(m float64) float64 {
	return m
}

// MetersLengthMatchList is effectively a constant
var MetersLengthMatchList = [...]string{"m", "meter", "meters"}

// MatchList always returns MetersLengthMatchList[:]
func (x MetersLength) MatchList() []string {
	return MetersLengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MetersLength) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LengthUnitType
func (x MetersLength) TypeOf() UnitType {
	return LengthUnitType
}

// Base always returns MetersLengthUnit
func (x MetersLength) Base() Unit {
	return MetersLengthUnit
}

var MetersLengthUnit MetersLength = 0.0

// FeetLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m
type FeetLength Length

// Title always returns "Feet"
func (x FeetLength) Title() string {
	return "Feet"
}

// Name always returns "Feet"
func (x FeetLength) Name() string {
	return "Feet"
}

// Symbol always returns "ft"
func (x FeetLength) Symbol() string {
	return "ft"
}

// FromBase converts m to ft
func (x FeetLength) FromBase(m float64) float64 {
	return m * 3.28084
}

// ToBase converts ft to m
func (x FeetLength) ToBase(ft float64) float64 {
	return ft * 0.304800
}

// FeetLengthMatchList is effectively a constant
var FeetLengthMatchList = [...]string{"ft", "foot", "feet"}

// MatchList always returns FeetLengthMatchList[:]
func (x FeetLength) MatchList() []string {
	return FeetLengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x FeetLength) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LengthUnitType
func (x FeetLength) TypeOf() UnitType {
	return LengthUnitType
}

// Base always returns MetersLengthUnit
func (x FeetLength) Base() Unit {
	return MetersLengthUnit
}

var FeetLengthUnit FeetLength = 0.0

// InchesLength (Unit)
// UnitType     : Length
// UnitType.Base: MetersLength
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m
type InchesLength Length

// Title always returns "Inches"
func (x InchesLength) Title() string {
	return "Inches"
}

// Name always returns "Inches"
func (x InchesLength) Name() string {
	return "Inches"
}

// Symbol always returns "in"
func (x InchesLength) Symbol() string {
	return "in"
}

// FromBase converts m to in
func (x InchesLength) FromBase(m float64) float64 {
	return m * 39.3701
}

// ToBase converts in to m
func (x InchesLength) ToBase(in float64) float64 {
	return in * 0.0254000
}

// InchesLengthMatchList is effectively a constant
var InchesLengthMatchList = [...]string{"in", "inch", "inches"}

// MatchList always returns InchesLengthMatchList[:]
func (x InchesLength) MatchList() []string {
	return InchesLengthMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesLength) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns LengthUnitType
func (x InchesLength) TypeOf() UnitType {
	return LengthUnitType
}

// Base always returns MetersLengthUnit
func (x InchesLength) Base() Unit {
	return MetersLengthUnit
}

var InchesLengthUnit InchesLength = 0.0

// Stroke (UnitType)
// Contains 3 units:
//  - MetersStroke m => m            = m
//  - FeetStroke   m => m * 3.280,84 = ft
//  - InchesStroke m => m * 39.370,1 = in
// Base: MetersStroke
type Stroke float64

// Title always returns "Stroke"
func (x Stroke) Title() string {
	return "Stroke"
}

// Name always returns "Stroke"
func (x Stroke) Name() string {
	return "Stroke"
}

// Base always returns MetersStrokeUnit
func (x Stroke) Base() Unit {
	return MetersStrokeUnit
}

// StrokeUnits is effectively a constant
var StrokeUnits = [...]Unit{MetersStrokeUnit, FeetStrokeUnit, InchesStrokeUnit}

// Units always returns StrokeUnits[:]
func (x Stroke) Units() []Unit {
	return StrokeUnits[:]
}

// StrokeUnitList is effectively a constant
var StrokeUnitList = [...]string{"Meters", "Feet", "Inches"}

// UnitList always returns StrokeUnitList[:]
func (x Stroke) UnitList() []string {
	return StrokeUnitList[:]
}

// StrokeMatchList is effectively a constant
var StrokeMatchList = [...]string{"stroke"}

// MatchList always returns StrokeMatchList[:]
func (x Stroke) MatchList() []string {
	return StrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Stroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var StrokeUnitType Stroke = 0.0

// MetersStroke (Unit)
// UnitType     : Stroke
// UnitType.Base: MetersStroke
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m
type MetersStroke Stroke

// Title always returns "Meters"
func (x MetersStroke) Title() string {
	return "Meters"
}

// Name always returns "Meters"
func (x MetersStroke) Name() string {
	return "Meters"
}

// Symbol always returns "m"
func (x MetersStroke) Symbol() string {
	return "m"
}

// FromBase converts m to m
func (x MetersStroke) FromBase(m float64) float64 {
	return m
}

// ToBase converts m to m
func (x MetersStroke) ToBase(m float64) float64 {
	return m
}

// MetersStrokeMatchList is effectively a constant
var MetersStrokeMatchList = [...]string{"m", "meter", "meters"}

// MatchList always returns MetersStrokeMatchList[:]
func (x MetersStroke) MatchList() []string {
	return MetersStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MetersStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns StrokeUnitType
func (x MetersStroke) TypeOf() UnitType {
	return StrokeUnitType
}

// Base always returns MetersStrokeUnit
func (x MetersStroke) Base() Unit {
	return MetersStrokeUnit
}

var MetersStrokeUnit MetersStroke = 0.0

// FeetStroke (Unit)
// UnitType     : Stroke
// UnitType.Base: MetersStroke
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m
type FeetStroke Stroke

// Title always returns "Feet"
func (x FeetStroke) Title() string {
	return "Feet"
}

// Name always returns "Feet"
func (x FeetStroke) Name() string {
	return "Feet"
}

// Symbol always returns "ft"
func (x FeetStroke) Symbol() string {
	return "ft"
}

// FromBase converts m to ft
func (x FeetStroke) FromBase(m float64) float64 {
	return m * 3.28084
}

// ToBase converts ft to m
func (x FeetStroke) ToBase(ft float64) float64 {
	return ft * 0.304800
}

// FeetStrokeMatchList is effectively a constant
var FeetStrokeMatchList = [...]string{"ft", "foot", "feet"}

// MatchList always returns FeetStrokeMatchList[:]
func (x FeetStroke) MatchList() []string {
	return FeetStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x FeetStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns StrokeUnitType
func (x FeetStroke) TypeOf() UnitType {
	return StrokeUnitType
}

// Base always returns MetersStrokeUnit
func (x FeetStroke) Base() Unit {
	return MetersStrokeUnit
}

var FeetStrokeUnit FeetStroke = 0.0

// InchesStroke (Unit)
// UnitType     : Stroke
// UnitType.Base: MetersStroke
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m
type InchesStroke Stroke

// Title always returns "Inches"
func (x InchesStroke) Title() string {
	return "Inches"
}

// Name always returns "Inches"
func (x InchesStroke) Name() string {
	return "Inches"
}

// Symbol always returns "in"
func (x InchesStroke) Symbol() string {
	return "in"
}

// FromBase converts m to in
func (x InchesStroke) FromBase(m float64) float64 {
	return m * 39.3701
}

// ToBase converts in to m
func (x InchesStroke) ToBase(in float64) float64 {
	return in * 0.0254000
}

// InchesStrokeMatchList is effectively a constant
var InchesStrokeMatchList = [...]string{"in", "inch", "inches"}

// MatchList always returns InchesStrokeMatchList[:]
func (x InchesStroke) MatchList() []string {
	return InchesStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns StrokeUnitType
func (x InchesStroke) TypeOf() UnitType {
	return StrokeUnitType
}

// Base always returns MetersStrokeUnit
func (x InchesStroke) Base() Unit {
	return MetersStrokeUnit
}

var InchesStrokeUnit InchesStroke = 0.0

// GrossStroke (UnitType)
// Contains 3 units:
//  - MetersGrossStroke m => m            = m
//  - FeetGrossStroke   m => m * 3.280,84 = ft
//  - InchesGrossStroke m => m * 39.370,1 = in
// Base: MetersGrossStroke
type GrossStroke float64

// Title always returns "GrossStroke"
func (x GrossStroke) Title() string {
	return "GrossStroke"
}

// Name always returns "Gross Stroke"
func (x GrossStroke) Name() string {
	return "Gross Stroke"
}

// Base always returns MetersGrossStrokeUnit
func (x GrossStroke) Base() Unit {
	return MetersGrossStrokeUnit
}

// GrossStrokeUnits is effectively a constant
var GrossStrokeUnits = [...]Unit{MetersGrossStrokeUnit, FeetGrossStrokeUnit, InchesGrossStrokeUnit}

// Units always returns GrossStrokeUnits[:]
func (x GrossStroke) Units() []Unit {
	return GrossStrokeUnits[:]
}

// GrossStrokeUnitList is effectively a constant
var GrossStrokeUnitList = [...]string{"Meters", "Feet", "Inches"}

// UnitList always returns GrossStrokeUnitList[:]
func (x GrossStroke) UnitList() []string {
	return GrossStrokeUnitList[:]
}

// GrossStrokeMatchList is effectively a constant
var GrossStrokeMatchList = [...]string{"grossstroke"}

// MatchList always returns GrossStrokeMatchList[:]
func (x GrossStroke) MatchList() []string {
	return GrossStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x GrossStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var GrossStrokeUnitType GrossStroke = 0.0

// MetersGrossStroke (Unit)
// UnitType     : GrossStroke
// UnitType.Base: MetersGrossStroke
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m
type MetersGrossStroke GrossStroke

// Title always returns "Meters"
func (x MetersGrossStroke) Title() string {
	return "Meters"
}

// Name always returns "Meters"
func (x MetersGrossStroke) Name() string {
	return "Meters"
}

// Symbol always returns "m"
func (x MetersGrossStroke) Symbol() string {
	return "m"
}

// FromBase converts m to m
func (x MetersGrossStroke) FromBase(m float64) float64 {
	return m
}

// ToBase converts m to m
func (x MetersGrossStroke) ToBase(m float64) float64 {
	return m
}

// MetersGrossStrokeMatchList is effectively a constant
var MetersGrossStrokeMatchList = [...]string{"m", "meter", "meters"}

// MatchList always returns MetersGrossStrokeMatchList[:]
func (x MetersGrossStroke) MatchList() []string {
	return MetersGrossStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MetersGrossStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns GrossStrokeUnitType
func (x MetersGrossStroke) TypeOf() UnitType {
	return GrossStrokeUnitType
}

// Base always returns MetersGrossStrokeUnit
func (x MetersGrossStroke) Base() Unit {
	return MetersGrossStrokeUnit
}

var MetersGrossStrokeUnit MetersGrossStroke = 0.0

// FeetGrossStroke (Unit)
// UnitType     : GrossStroke
// UnitType.Base: MetersGrossStroke
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m
type FeetGrossStroke GrossStroke

// Title always returns "Feet"
func (x FeetGrossStroke) Title() string {
	return "Feet"
}

// Name always returns "Feet"
func (x FeetGrossStroke) Name() string {
	return "Feet"
}

// Symbol always returns "ft"
func (x FeetGrossStroke) Symbol() string {
	return "ft"
}

// FromBase converts m to ft
func (x FeetGrossStroke) FromBase(m float64) float64 {
	return m * 3.28084
}

// ToBase converts ft to m
func (x FeetGrossStroke) ToBase(ft float64) float64 {
	return ft * 0.304800
}

// FeetGrossStrokeMatchList is effectively a constant
var FeetGrossStrokeMatchList = [...]string{"ft", "foot", "feet"}

// MatchList always returns FeetGrossStrokeMatchList[:]
func (x FeetGrossStroke) MatchList() []string {
	return FeetGrossStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x FeetGrossStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns GrossStrokeUnitType
func (x FeetGrossStroke) TypeOf() UnitType {
	return GrossStrokeUnitType
}

// Base always returns MetersGrossStrokeUnit
func (x FeetGrossStroke) Base() Unit {
	return MetersGrossStrokeUnit
}

var FeetGrossStrokeUnit FeetGrossStroke = 0.0

// InchesGrossStroke (Unit)
// UnitType     : GrossStroke
// UnitType.Base: MetersGrossStroke
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m
type InchesGrossStroke GrossStroke

// Title always returns "Inches"
func (x InchesGrossStroke) Title() string {
	return "Inches"
}

// Name always returns "Inches"
func (x InchesGrossStroke) Name() string {
	return "Inches"
}

// Symbol always returns "in"
func (x InchesGrossStroke) Symbol() string {
	return "in"
}

// FromBase converts m to in
func (x InchesGrossStroke) FromBase(m float64) float64 {
	return m * 39.3701
}

// ToBase converts in to m
func (x InchesGrossStroke) ToBase(in float64) float64 {
	return in * 0.0254000
}

// InchesGrossStrokeMatchList is effectively a constant
var InchesGrossStrokeMatchList = [...]string{"in", "inch", "inches"}

// MatchList always returns InchesGrossStrokeMatchList[:]
func (x InchesGrossStroke) MatchList() []string {
	return InchesGrossStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesGrossStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns GrossStrokeUnitType
func (x InchesGrossStroke) TypeOf() UnitType {
	return GrossStrokeUnitType
}

// Base always returns MetersGrossStrokeUnit
func (x InchesGrossStroke) Base() Unit {
	return MetersGrossStrokeUnit
}

var InchesGrossStrokeUnit InchesGrossStroke = 0.0

// NetStroke (UnitType)
// Contains 3 units:
//  - MetersNetStroke m => m            = m
//  - FeetNetStroke   m => m * 3.280,84 = ft
//  - InchesNetStroke m => m * 39.370,1 = in
// Base: MetersNetStroke
type NetStroke float64

// Title always returns "NetStroke"
func (x NetStroke) Title() string {
	return "NetStroke"
}

// Name always returns "Net Stroke"
func (x NetStroke) Name() string {
	return "Net Stroke"
}

// Base always returns MetersNetStrokeUnit
func (x NetStroke) Base() Unit {
	return MetersNetStrokeUnit
}

// NetStrokeUnits is effectively a constant
var NetStrokeUnits = [...]Unit{MetersNetStrokeUnit, FeetNetStrokeUnit, InchesNetStrokeUnit}

// Units always returns NetStrokeUnits[:]
func (x NetStroke) Units() []Unit {
	return NetStrokeUnits[:]
}

// NetStrokeUnitList is effectively a constant
var NetStrokeUnitList = [...]string{"Meters", "Feet", "Inches"}

// UnitList always returns NetStrokeUnitList[:]
func (x NetStroke) UnitList() []string {
	return NetStrokeUnitList[:]
}

// NetStrokeMatchList is effectively a constant
var NetStrokeMatchList = [...]string{"netstroke"}

// MatchList always returns NetStrokeMatchList[:]
func (x NetStroke) MatchList() []string {
	return NetStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NetStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var NetStrokeUnitType NetStroke = 0.0

// MetersNetStroke (Unit)
// UnitType     : NetStroke
// UnitType.Base: MetersNetStroke
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m
type MetersNetStroke NetStroke

// Title always returns "Meters"
func (x MetersNetStroke) Title() string {
	return "Meters"
}

// Name always returns "Meters"
func (x MetersNetStroke) Name() string {
	return "Meters"
}

// Symbol always returns "m"
func (x MetersNetStroke) Symbol() string {
	return "m"
}

// FromBase converts m to m
func (x MetersNetStroke) FromBase(m float64) float64 {
	return m
}

// ToBase converts m to m
func (x MetersNetStroke) ToBase(m float64) float64 {
	return m
}

// MetersNetStrokeMatchList is effectively a constant
var MetersNetStrokeMatchList = [...]string{"m", "meter", "meters"}

// MatchList always returns MetersNetStrokeMatchList[:]
func (x MetersNetStroke) MatchList() []string {
	return MetersNetStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x MetersNetStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns NetStrokeUnitType
func (x MetersNetStroke) TypeOf() UnitType {
	return NetStrokeUnitType
}

// Base always returns MetersNetStrokeUnit
func (x MetersNetStroke) Base() Unit {
	return MetersNetStrokeUnit
}

var MetersNetStrokeUnit MetersNetStroke = 0.0

// FeetNetStroke (Unit)
// UnitType     : NetStroke
// UnitType.Base: MetersNetStroke
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m
type FeetNetStroke NetStroke

// Title always returns "Feet"
func (x FeetNetStroke) Title() string {
	return "Feet"
}

// Name always returns "Feet"
func (x FeetNetStroke) Name() string {
	return "Feet"
}

// Symbol always returns "ft"
func (x FeetNetStroke) Symbol() string {
	return "ft"
}

// FromBase converts m to ft
func (x FeetNetStroke) FromBase(m float64) float64 {
	return m * 3.28084
}

// ToBase converts ft to m
func (x FeetNetStroke) ToBase(ft float64) float64 {
	return ft * 0.304800
}

// FeetNetStrokeMatchList is effectively a constant
var FeetNetStrokeMatchList = [...]string{"ft", "foot", "feet"}

// MatchList always returns FeetNetStrokeMatchList[:]
func (x FeetNetStroke) MatchList() []string {
	return FeetNetStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x FeetNetStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns NetStrokeUnitType
func (x FeetNetStroke) TypeOf() UnitType {
	return NetStrokeUnitType
}

// Base always returns MetersNetStrokeUnit
func (x FeetNetStroke) Base() Unit {
	return MetersNetStrokeUnit
}

var FeetNetStrokeUnit FeetNetStroke = 0.0

// InchesNetStroke (Unit)
// UnitType     : NetStroke
// UnitType.Base: MetersNetStroke
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m
type InchesNetStroke NetStroke

// Title always returns "Inches"
func (x InchesNetStroke) Title() string {
	return "Inches"
}

// Name always returns "Inches"
func (x InchesNetStroke) Name() string {
	return "Inches"
}

// Symbol always returns "in"
func (x InchesNetStroke) Symbol() string {
	return "in"
}

// FromBase converts m to in
func (x InchesNetStroke) FromBase(m float64) float64 {
	return m * 39.3701
}

// ToBase converts in to m
func (x InchesNetStroke) ToBase(in float64) float64 {
	return in * 0.0254000
}

// InchesNetStrokeMatchList is effectively a constant
var InchesNetStrokeMatchList = [...]string{"in", "inch", "inches"}

// MatchList always returns InchesNetStrokeMatchList[:]
func (x InchesNetStroke) MatchList() []string {
	return InchesNetStrokeMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesNetStroke) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns NetStrokeUnitType
func (x InchesNetStroke) TypeOf() UnitType {
	return NetStrokeUnitType
}

// Base always returns MetersNetStrokeUnit
func (x InchesNetStroke) Base() Unit {
	return MetersNetStrokeUnit
}

var InchesNetStrokeUnit InchesNetStroke = 0.0

// StrokeRate (UnitType)
// Contains 1 units:
//  - StrokesPerSecondStrokeRate ss => ss = strokes/s
// Base: StrokesPerSecondStrokeRate
type StrokeRate float64

// Title always returns "StrokeRate"
func (x StrokeRate) Title() string {
	return "StrokeRate"
}

// Name always returns "Stroke Rate"
func (x StrokeRate) Name() string {
	return "Stroke Rate"
}

// Base always returns StrokesPerSecondStrokeRateUnit
func (x StrokeRate) Base() Unit {
	return StrokesPerSecondStrokeRateUnit
}

// StrokeRateUnits is effectively a constant
var StrokeRateUnits = [...]Unit{StrokesPerSecondStrokeRateUnit}

// Units always returns StrokeRateUnits[:]
func (x StrokeRate) Units() []Unit {
	return StrokeRateUnits[:]
}

// StrokeRateUnitList is effectively a constant
var StrokeRateUnitList = [...]string{"Strokes per Second"}

// UnitList always returns StrokeRateUnitList[:]
func (x StrokeRate) UnitList() []string {
	return StrokeRateUnitList[:]
}

// StrokeRateMatchList is effectively a constant
var StrokeRateMatchList = [...]string{"strokerate", "stroke-rate"}

// MatchList always returns StrokeRateMatchList[:]
func (x StrokeRate) MatchList() []string {
	return StrokeRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokeRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var StrokeRateUnitType StrokeRate = 0.0

// StrokesPerSecondStrokeRate (Unit)
// UnitType     : StrokeRate
// UnitType.Base: StrokesPerSecondStrokeRate
// Unit.FromBase: ss => ss = strokes/s
// Unit.ToBase  : ss => ss = strokes/s
type StrokesPerSecondStrokeRate StrokeRate

// Title always returns "StrokesPerSecond"
func (x StrokesPerSecondStrokeRate) Title() string {
	return "StrokesPerSecond"
}

// Name always returns "Strokes per Second"
func (x StrokesPerSecondStrokeRate) Name() string {
	return "Strokes per Second"
}

// Symbol always returns "strokes/s"
func (x StrokesPerSecondStrokeRate) Symbol() string {
	return "strokes/s"
}

// FromBase converts strokes/s to strokes/s
func (x StrokesPerSecondStrokeRate) FromBase(ss float64) float64 {
	return ss
}

// ToBase converts strokes/s to strokes/s
func (x StrokesPerSecondStrokeRate) ToBase(ss float64) float64 {
	return ss
}

// StrokesPerSecondStrokeRateMatchList is effectively a constant
var StrokesPerSecondStrokeRateMatchList = [...]string{"strokes/s", "strokespersecond", "s/s"}

// MatchList always returns StrokesPerSecondStrokeRateMatchList[:]
func (x StrokesPerSecondStrokeRate) MatchList() []string {
	return StrokesPerSecondStrokeRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokesPerSecondStrokeRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns StrokeRateUnitType
func (x StrokesPerSecondStrokeRate) TypeOf() UnitType {
	return StrokeRateUnitType
}

// Base always returns StrokesPerSecondStrokeRateUnit
func (x StrokesPerSecondStrokeRate) Base() Unit {
	return StrokesPerSecondStrokeRateUnit
}

var StrokesPerSecondStrokeRateUnit StrokesPerSecondStrokeRate = 0.0

// Number (UnitType)
// Contains 1 units:
//  - NumberNumber n => n =
// Base: NumberNumber
type Number float64

// Title always returns "Number"
func (x Number) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x Number) Name() string {
	return "Number"
}

// Base always returns NumberNumberUnit
func (x Number) Base() Unit {
	return NumberNumberUnit
}

// NumberUnits is effectively a constant
var NumberUnits = [...]Unit{NumberNumberUnit}

// Units always returns NumberUnits[:]
func (x Number) Units() []Unit {
	return NumberUnits[:]
}

// NumberUnitList is effectively a constant
var NumberUnitList = [...]string{"Number"}

// UnitList always returns NumberUnitList[:]
func (x Number) UnitList() []string {
	return NumberUnitList[:]
}

// NumberMatchList is effectively a constant
var NumberMatchList = [...]string{"*"}

// MatchList always returns NumberMatchList[:]
func (x Number) MatchList() []string {
	return NumberMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Number) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var NumberUnitType Number = 0.0

// NumberNumber (Unit)
// UnitType     : Number
// UnitType.Base: NumberNumber
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberNumber Number

// Title always returns "Number"
func (x NumberNumber) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberNumber) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberNumber) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberNumber) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberNumber) ToBase(n float64) float64 {
	return n
}

// NumberNumberMatchList is effectively a constant
var NumberNumberMatchList = [...]string{"number", "*"}

// MatchList always returns NumberNumberMatchList[:]
func (x NumberNumber) MatchList() []string {
	return NumberNumberMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberNumber) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns NumberUnitType
func (x NumberNumber) TypeOf() UnitType {
	return NumberUnitType
}

// Base always returns NumberNumberUnit
func (x NumberNumber) Base() Unit {
	return NumberNumberUnit
}

var NumberNumberUnit NumberNumber = 0.0

// Overspeed (UnitType)
// Contains 1 units:
//  - NumberOverspeed n => n =
// Base: NumberOverspeed
type Overspeed float64

// Title always returns "Overspeed"
func (x Overspeed) Title() string {
	return "Overspeed"
}

// Name always returns "Overspeed"
func (x Overspeed) Name() string {
	return "Overspeed"
}

// Base always returns NumberOverspeedUnit
func (x Overspeed) Base() Unit {
	return NumberOverspeedUnit
}

// OverspeedUnits is effectively a constant
var OverspeedUnits = [...]Unit{NumberOverspeedUnit}

// Units always returns OverspeedUnits[:]
func (x Overspeed) Units() []Unit {
	return OverspeedUnits[:]
}

// OverspeedUnitList is effectively a constant
var OverspeedUnitList = [...]string{"Number"}

// UnitList always returns OverspeedUnitList[:]
func (x Overspeed) UnitList() []string {
	return OverspeedUnitList[:]
}

// OverspeedMatchList is effectively a constant
var OverspeedMatchList = [...]string{"overspeed"}

// MatchList always returns OverspeedMatchList[:]
func (x Overspeed) MatchList() []string {
	return OverspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Overspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var OverspeedUnitType Overspeed = 0.0

// NumberOverspeed (Unit)
// UnitType     : Overspeed
// UnitType.Base: NumberOverspeed
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberOverspeed Overspeed

// Title always returns "Number"
func (x NumberOverspeed) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberOverspeed) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberOverspeed) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberOverspeed) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberOverspeed) ToBase(n float64) float64 {
	return n
}

// NumberOverspeedMatchList is effectively a constant
var NumberOverspeedMatchList = [...]string{"number", "*"}

// MatchList always returns NumberOverspeedMatchList[:]
func (x NumberOverspeed) MatchList() []string {
	return NumberOverspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberOverspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns OverspeedUnitType
func (x NumberOverspeed) TypeOf() UnitType {
	return OverspeedUnitType
}

// Base always returns NumberOverspeedUnit
func (x NumberOverspeed) Base() Unit {
	return NumberOverspeedUnit
}

var NumberOverspeedUnit NumberOverspeed = 0.0

// Underspeed (UnitType)
// Contains 1 units:
//  - NumberUnderspeed n => n =
// Base: NumberUnderspeed
type Underspeed float64

// Title always returns "Underspeed"
func (x Underspeed) Title() string {
	return "Underspeed"
}

// Name always returns "Underspeed"
func (x Underspeed) Name() string {
	return "Underspeed"
}

// Base always returns NumberUnderspeedUnit
func (x Underspeed) Base() Unit {
	return NumberUnderspeedUnit
}

// UnderspeedUnits is effectively a constant
var UnderspeedUnits = [...]Unit{NumberUnderspeedUnit}

// Units always returns UnderspeedUnits[:]
func (x Underspeed) Units() []Unit {
	return UnderspeedUnits[:]
}

// UnderspeedUnitList is effectively a constant
var UnderspeedUnitList = [...]string{"Number"}

// UnitList always returns UnderspeedUnitList[:]
func (x Underspeed) UnitList() []string {
	return UnderspeedUnitList[:]
}

// UnderspeedMatchList is effectively a constant
var UnderspeedMatchList = [...]string{"underspeed"}

// MatchList always returns UnderspeedMatchList[:]
func (x Underspeed) MatchList() []string {
	return UnderspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Underspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var UnderspeedUnitType Underspeed = 0.0

// NumberUnderspeed (Unit)
// UnitType     : Underspeed
// UnitType.Base: NumberUnderspeed
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberUnderspeed Underspeed

// Title always returns "Number"
func (x NumberUnderspeed) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberUnderspeed) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberUnderspeed) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberUnderspeed) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberUnderspeed) ToBase(n float64) float64 {
	return n
}

// NumberUnderspeedMatchList is effectively a constant
var NumberUnderspeedMatchList = [...]string{"number", "*"}

// MatchList always returns NumberUnderspeedMatchList[:]
func (x NumberUnderspeed) MatchList() []string {
	return NumberUnderspeedMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberUnderspeed) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns UnderspeedUnitType
func (x NumberUnderspeed) TypeOf() UnitType {
	return UnderspeedUnitType
}

// Base always returns NumberUnderspeedUnit
func (x NumberUnderspeed) Base() Unit {
	return NumberUnderspeedUnit
}

var NumberUnderspeedUnit NumberUnderspeed = 0.0

// Totaliser (UnitType)
// Contains 1 units:
//  - NumberTotaliser n => n =
// Base: NumberTotaliser
type Totaliser float64

// Title always returns "Totaliser"
func (x Totaliser) Title() string {
	return "Totaliser"
}

// Name always returns "Totaliser"
func (x Totaliser) Name() string {
	return "Totaliser"
}

// Base always returns NumberTotaliserUnit
func (x Totaliser) Base() Unit {
	return NumberTotaliserUnit
}

// TotaliserUnits is effectively a constant
var TotaliserUnits = [...]Unit{NumberTotaliserUnit}

// Units always returns TotaliserUnits[:]
func (x Totaliser) Units() []Unit {
	return TotaliserUnits[:]
}

// TotaliserUnitList is effectively a constant
var TotaliserUnitList = [...]string{"Number"}

// UnitList always returns TotaliserUnitList[:]
func (x Totaliser) UnitList() []string {
	return TotaliserUnitList[:]
}

// TotaliserMatchList is effectively a constant
var TotaliserMatchList = [...]string{"totaliser"}

// MatchList always returns TotaliserMatchList[:]
func (x Totaliser) MatchList() []string {
	return TotaliserMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Totaliser) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var TotaliserUnitType Totaliser = 0.0

// NumberTotaliser (Unit)
// UnitType     : Totaliser
// UnitType.Base: NumberTotaliser
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberTotaliser Totaliser

// Title always returns "Number"
func (x NumberTotaliser) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberTotaliser) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberTotaliser) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberTotaliser) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberTotaliser) ToBase(n float64) float64 {
	return n
}

// NumberTotaliserMatchList is effectively a constant
var NumberTotaliserMatchList = [...]string{"number", "*"}

// MatchList always returns NumberTotaliserMatchList[:]
func (x NumberTotaliser) MatchList() []string {
	return NumberTotaliserMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberTotaliser) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns TotaliserUnitType
func (x NumberTotaliser) TypeOf() UnitType {
	return TotaliserUnitType
}

// Base always returns NumberTotaliserUnit
func (x NumberTotaliser) Base() Unit {
	return NumberTotaliserUnit
}

var NumberTotaliserUnit NumberTotaliser = 0.0

// WMLFlowRate (UnitType)
// Contains 1 units:
//  - NumberWMLFlowRate n => n =
// Base: NumberWMLFlowRate
type WMLFlowRate float64

// Title always returns "WMLFlowRate"
func (x WMLFlowRate) Title() string {
	return "WMLFlowRate"
}

// Name always returns "WML Flow Rate"
func (x WMLFlowRate) Name() string {
	return "WML Flow Rate"
}

// Base always returns NumberWMLFlowRateUnit
func (x WMLFlowRate) Base() Unit {
	return NumberWMLFlowRateUnit
}

// WMLFlowRateUnits is effectively a constant
var WMLFlowRateUnits = [...]Unit{NumberWMLFlowRateUnit}

// Units always returns WMLFlowRateUnits[:]
func (x WMLFlowRate) Units() []Unit {
	return WMLFlowRateUnits[:]
}

// WMLFlowRateUnitList is effectively a constant
var WMLFlowRateUnitList = [...]string{"Number"}

// UnitList always returns WMLFlowRateUnitList[:]
func (x WMLFlowRate) UnitList() []string {
	return WMLFlowRateUnitList[:]
}

// WMLFlowRateMatchList is effectively a constant
var WMLFlowRateMatchList = [...]string{"wmlflowrate"}

// MatchList always returns WMLFlowRateMatchList[:]
func (x WMLFlowRate) MatchList() []string {
	return WMLFlowRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x WMLFlowRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

var WMLFlowRateUnitType WMLFlowRate = 0.0

// NumberWMLFlowRate (Unit)
// UnitType     : WMLFlowRate
// UnitType.Base: NumberWMLFlowRate
// Unit.FromBase: n => n =
// Unit.ToBase  : n => n =
type NumberWMLFlowRate WMLFlowRate

// Title always returns "Number"
func (x NumberWMLFlowRate) Title() string {
	return "Number"
}

// Name always returns "Number"
func (x NumberWMLFlowRate) Name() string {
	return "Number"
}

// Symbol always returns ""
func (x NumberWMLFlowRate) Symbol() string {
	return ""
}

// FromBase converts  to
func (x NumberWMLFlowRate) FromBase(n float64) float64 {
	return n
}

// ToBase converts  to
func (x NumberWMLFlowRate) ToBase(n float64) float64 {
	return n
}

// NumberWMLFlowRateMatchList is effectively a constant
var NumberWMLFlowRateMatchList = [...]string{"number", "*"}

// MatchList always returns NumberWMLFlowRateMatchList[:]
func (x NumberWMLFlowRate) MatchList() []string {
	return NumberWMLFlowRateMatchList[:]
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x NumberWMLFlowRate) Matches(check string) bool {
	check = SanitizeString(check)
	for _, m := range x.MatchList() {
		if m == check || m == "*" {
			return true
		}
	}
	return false
}

// TypeOf always returns WMLFlowRateUnitType
func (x NumberWMLFlowRate) TypeOf() UnitType {
	return WMLFlowRateUnitType
}

// Base always returns NumberWMLFlowRateUnit
func (x NumberWMLFlowRate) Base() Unit {
	return NumberWMLFlowRateUnit
}

var NumberWMLFlowRateUnit NumberWMLFlowRate = 0.0
