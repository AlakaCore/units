package units

// File autogenerated on 2022-02-09 18:34:23.287280438 -0600 CST m=+0.000702845.
// Do not edit directly

// Unit represents a scalar type of unit which can be converted to and from a base 
type Unit interface {
	Name() string
	Symbol() string
	FromBase(float64) float64
	ToBase(float64) float64
	MatchList() []string
	Matches(string) bool
	TypeOf() UnitType
	Base() Unit
}

// UnitType represents a collection of related units
type UnitType interface {
	Name() string
	Base() Unit
	Units() []Unit
	UnitList() []string
	MatchList() []string
	Matches(string) bool
}

var UnitMap = make(map[string]Unit)
var TypeMap = make(map[string]UnitType)

// Pressure (UnitType)
// Contains 5 units:
//  - Pascals             Pa => Pa                 = Pa
//  - Kilopascals         Pa => Pa * 0.001         = kPa
//  - Megapascals         Pa => Pa * 0.000,001     = MPa
//  - PoundsPerSquareInch Pa => Pa * 0.000,145,038 = psi
//  - InchesOfWater       Pa => Pa * 0.004,014,74  = inH₂O
// Base: Pascals
type Pressure struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Pressure) Name() string {
    return x.name
}

// Base gets the base field
func (x Pressure) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Pressure) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Pressure) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Pressure) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Pressure) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var PressureUnitType = Pressure{
	name: "Pressure",
	base: PascalsUnit,
	matches: []string{"pressure"},
	units: []Unit{PascalsUnit,KilopascalsUnit,MegapascalsUnit,PoundsPerSquareInchUnit,InchesOfWaterUnit},
}

// Pascals (Unit)
// UnitType     : Pressure
// UnitType.Base: Pascals
// Unit.FromBase: Pa => Pa = Pa
// Unit.ToBase  : Pa => Pa = Pa
type Pascals struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x Pascals) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Pascals) Symbol() string {
    return x.symbol
}

// FromBase converts Pa to Pa
func (x Pascals) FromBase(Pa float64) float64 {
    return Pa
}

// ToBase converts Pa to Pa
func (x Pascals) ToBase(Pa float64) float64 {
    return Pa
}

// MatchList gets the matches field
func (x Pascals) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Pascals) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Pascals) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Pascals) Base() Unit {
    return PascalsUnit
}

var PascalsUnit = Pascals {
	name:     "Pascals",
	symbol:   "Pa",
	fromBase: "Pa => Pa",
	toBase:   "Pa => Pa",
	matches:  []string{"pa","pascal","pascals"},
	typeOf:   PressureUnitType,
}

// Kilopascals (Unit)
// UnitType     : Pressure
// UnitType.Base: Pascals
// Unit.FromBase: Pa => Pa * 0.001   = kPa
// Unit.ToBase  : kPa => kPa * 1,000 = Pa
type Kilopascals struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x Kilopascals) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Kilopascals) Symbol() string {
    return x.symbol
}

// FromBase converts Pa to kPa
func (x Kilopascals) FromBase(Pa float64) float64 {
    return Pa * 0.001
}

// ToBase converts Pa to kPa
func (x Kilopascals) ToBase(kPa float64) float64 {
    return kPa * 1000
}

// MatchList gets the matches field
func (x Kilopascals) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Kilopascals) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Kilopascals) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Kilopascals) Base() Unit {
    return PascalsUnit
}

var KilopascalsUnit = Kilopascals {
	name:     "Kilopascals",
	symbol:   "kPa",
	fromBase: "Pa => Pa * 0.001",
	toBase:   "kPa => kPa * 1,000",
	matches:  []string{"kpa","kilopascal","kilopascals"},
	typeOf:   PressureUnitType,
}

// Megapascals (Unit)
// UnitType     : Pressure
// UnitType.Base: Pascals
// Unit.FromBase: Pa => Pa * 0.000,001   = MPa
// Unit.ToBase  : MPa => MPa * 1,000,000 = Pa
type Megapascals struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x Megapascals) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Megapascals) Symbol() string {
    return x.symbol
}

// FromBase converts Pa to MPa
func (x Megapascals) FromBase(Pa float64) float64 {
    return Pa * 0.000001
}

// ToBase converts Pa to MPa
func (x Megapascals) ToBase(MPa float64) float64 {
    return MPa * 1000000
}

// MatchList gets the matches field
func (x Megapascals) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Megapascals) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Megapascals) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Megapascals) Base() Unit {
    return PascalsUnit
}

var MegapascalsUnit = Megapascals {
	name:     "Megapascals",
	symbol:   "MPa",
	fromBase: "Pa => Pa * 0.000,001",
	toBase:   "MPa => MPa * 1,000,000",
	matches:  []string{"mpa","megapascal","megapascals"},
	typeOf:   PressureUnitType,
}

// PoundsPerSquareInch (Unit)
// UnitType     : Pressure
// UnitType.Base: Pascals
// Unit.FromBase: Pa => Pa * 0.000,145,038 = psi
// Unit.ToBase  : psi => psi * 6,894.76    = Pa
type PoundsPerSquareInch struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x PoundsPerSquareInch) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x PoundsPerSquareInch) Symbol() string {
    return x.symbol
}

// FromBase converts Pa to psi
func (x PoundsPerSquareInch) FromBase(Pa float64) float64 {
    return Pa * 0.000145038
}

// ToBase converts Pa to psi
func (x PoundsPerSquareInch) ToBase(psi float64) float64 {
    return psi * 6894.76
}

// MatchList gets the matches field
func (x PoundsPerSquareInch) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsPerSquareInch) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x PoundsPerSquareInch) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x PoundsPerSquareInch) Base() Unit {
    return PascalsUnit
}

var PoundsPerSquareInchUnit = PoundsPerSquareInch {
	name:     "Pounds per Square Inch",
	symbol:   "psi",
	fromBase: "Pa => Pa * 0.000,145,038",
	toBase:   "psi => psi * 6,894.76",
	matches:  []string{"psi","poundspersquareinch","poundpersquareinch"},
	typeOf:   PressureUnitType,
}

// InchesOfWater (Unit)
// UnitType     : Pressure
// UnitType.Base: Pascals
// Unit.FromBase: Pa => Pa * 0.004,014,74  = inH₂O
// Unit.ToBase  : inH2O => inH2O * 249.082 = Pa
type InchesOfWater struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Pressure
}

// Name gets the name field
func (x InchesOfWater) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x InchesOfWater) Symbol() string {
    return x.symbol
}

// FromBase converts Pa to inH₂O
func (x InchesOfWater) FromBase(Pa float64) float64 {
    return Pa * 0.00401474
}

// ToBase converts Pa to inH₂O
func (x InchesOfWater) ToBase(inH2O float64) float64 {
    return inH2O * 249.082
}

// MatchList gets the matches field
func (x InchesOfWater) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchesOfWater) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x InchesOfWater) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x InchesOfWater) Base() Unit {
    return PascalsUnit
}

var InchesOfWaterUnit = InchesOfWater {
	name:     "Inches of Water",
	symbol:   "inH₂O",
	fromBase: "Pa => Pa * 0.004,014,74",
	toBase:   "inH2O => inH2O * 249.082",
	matches:  []string{"inh₂o","inh₂0","inh2o","inh20","incheswater","inchesofwater","inchwater","inchofwater"},
	typeOf:   PressureUnitType,
}

// Temperature (UnitType)
// Contains 3 units:
//  - DegreesCelsius    C => C                  = °C
//  - DegreesFahrenheit C => (C * (9 / 5)) + 32 = °F
//  - Kelvins           C => C + 273.15         = K
// Base: DegreesCelsius
type Temperature struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Temperature) Name() string {
    return x.name
}

// Base gets the base field
func (x Temperature) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Temperature) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Temperature) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Temperature) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Temperature) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var TemperatureUnitType = Temperature{
	name: "Temperature",
	base: DegreesCelsiusUnit,
	matches: []string{"temperature","temp"},
	units: []Unit{DegreesCelsiusUnit,DegreesFahrenheitUnit,KelvinsUnit},
}

// DegreesCelsius (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsius
// Unit.FromBase: C => C = °C
// Unit.ToBase  : C => C = °C
type DegreesCelsius struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Temperature
}

// Name gets the name field
func (x DegreesCelsius) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x DegreesCelsius) Symbol() string {
    return x.symbol
}

// FromBase converts °C to °C
func (x DegreesCelsius) FromBase(C float64) float64 {
    return C
}

// ToBase converts °C to °C
func (x DegreesCelsius) ToBase(C float64) float64 {
    return C
}

// MatchList gets the matches field
func (x DegreesCelsius) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesCelsius) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x DegreesCelsius) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x DegreesCelsius) Base() Unit {
    return DegreesCelsiusUnit
}

var DegreesCelsiusUnit = DegreesCelsius {
	name:     "Degrees Celsius",
	symbol:   "°C",
	fromBase: "C => C",
	toBase:   "C => C",
	matches:  []string{"c","°c","celsius","degreesc","degreec","degreescelsius","degreecelsius"},
	typeOf:   TemperatureUnitType,
}

// DegreesFahrenheit (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsius
// Unit.FromBase: C => (C * (9 / 5)) + 32 = °F
// Unit.ToBase  : F => (F - 32) * (5 / 9) = °C
type DegreesFahrenheit struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Temperature
}

// Name gets the name field
func (x DegreesFahrenheit) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x DegreesFahrenheit) Symbol() string {
    return x.symbol
}

// FromBase converts °C to °F
func (x DegreesFahrenheit) FromBase(C float64) float64 {
    return (C * (9 / 5)) + 32
}

// ToBase converts °C to °F
func (x DegreesFahrenheit) ToBase(F float64) float64 {
    return (F - 32) * (5 / 9)
}

// MatchList gets the matches field
func (x DegreesFahrenheit) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x DegreesFahrenheit) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x DegreesFahrenheit) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x DegreesFahrenheit) Base() Unit {
    return DegreesCelsiusUnit
}

var DegreesFahrenheitUnit = DegreesFahrenheit {
	name:     "Degrees Fahrenheit",
	symbol:   "°F",
	fromBase: "C => (C * (9 / 5)) + 32",
	toBase:   "F => (F - 32) * (5 / 9)",
	matches:  []string{"f","°f","fahrenheit","degreesf","degreef","degreesfahrenheit","degreefahrenheit"},
	typeOf:   TemperatureUnitType,
}

// Kelvins (Unit)
// UnitType     : Temperature
// UnitType.Base: DegreesCelsius
// Unit.FromBase: C => C + 273.15 = K
// Unit.ToBase  : K => K - 273.15 = °C
type Kelvins struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Temperature
}

// Name gets the name field
func (x Kelvins) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Kelvins) Symbol() string {
    return x.symbol
}

// FromBase converts °C to K
func (x Kelvins) FromBase(C float64) float64 {
    return C + 273.15
}

// ToBase converts °C to K
func (x Kelvins) ToBase(K float64) float64 {
    return K - 273.15
}

// MatchList gets the matches field
func (x Kelvins) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Kelvins) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Kelvins) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Kelvins) Base() Unit {
    return DegreesCelsiusUnit
}

var KelvinsUnit = Kelvins {
	name:     "Kelvins",
	symbol:   "K",
	fromBase: "C => C + 273.15",
	toBase:   "K => K - 273.15",
	matches:  []string{"k","°k","kelvin","kelvins","degreesk","degreek","degreeskelvin","degreekelvin"},
	typeOf:   TemperatureUnitType,
}

// Flow (UnitType)
// Contains 3 units:
//  - CubicMetersPerSecond    m3s => m3s            = m³/s
//  - CubicFeetPerSecond      m3s => m3s * 35.314,7 = ft³/s
//  - ThousandCubicFeetPerDay m3s => m3s * 3,051.19 = MCFD
// Base: CubicMetersPerSecond
type Flow struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Flow) Name() string {
    return x.name
}

// Base gets the base field
func (x Flow) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Flow) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Flow) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Flow) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Flow) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var FlowUnitType = Flow{
	name: "Flow",
	base: CubicMetersPerSecondUnit,
	matches: []string{"flow","flowrate","flow_rate","gasflow","gasflowrate","gas_flow","gas_flow_rate"},
	units: []Unit{CubicMetersPerSecondUnit,CubicFeetPerSecondUnit,ThousandCubicFeetPerDayUnit},
}

// CubicMetersPerSecond (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecond
// Unit.FromBase: m3s => m3s = m³/s
// Unit.ToBase  : m3s => m3s = m³/s
type CubicMetersPerSecond struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Flow
}

// Name gets the name field
func (x CubicMetersPerSecond) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x CubicMetersPerSecond) Symbol() string {
    return x.symbol
}

// FromBase converts m³/s to m³/s
func (x CubicMetersPerSecond) FromBase(m3s float64) float64 {
    return m3s
}

// ToBase converts m³/s to m³/s
func (x CubicMetersPerSecond) ToBase(m3s float64) float64 {
    return m3s
}

// MatchList gets the matches field
func (x CubicMetersPerSecond) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMetersPerSecond) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x CubicMetersPerSecond) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x CubicMetersPerSecond) Base() Unit {
    return CubicMetersPerSecondUnit
}

var CubicMetersPerSecondUnit = CubicMetersPerSecond {
	name:     "Cubic Meters per Second",
	symbol:   "m³/s",
	fromBase: "m3s => m3s",
	toBase:   "m3s => m3s",
	matches:  []string{"m³/s","m³s","m3/s","m3s","m^3/s","m^3s","cubicmeterspersecond","cubicmeterpersecond","cubicmeters/second","cubicmeter/second"},
	typeOf:   FlowUnitType,
}

// CubicFeetPerSecond (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecond
// Unit.FromBase: m3s => m3s * 35.314,7      = ft³/s
// Unit.ToBase  : ft3s => ft3s * 0.028,316,8 = m³/s
type CubicFeetPerSecond struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Flow
}

// Name gets the name field
func (x CubicFeetPerSecond) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x CubicFeetPerSecond) Symbol() string {
    return x.symbol
}

// FromBase converts m³/s to ft³/s
func (x CubicFeetPerSecond) FromBase(m3s float64) float64 {
    return m3s * 35.3147
}

// ToBase converts m³/s to ft³/s
func (x CubicFeetPerSecond) ToBase(ft3s float64) float64 {
    return ft3s * 0.0283168
}

// MatchList gets the matches field
func (x CubicFeetPerSecond) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetPerSecond) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x CubicFeetPerSecond) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x CubicFeetPerSecond) Base() Unit {
    return CubicMetersPerSecondUnit
}

var CubicFeetPerSecondUnit = CubicFeetPerSecond {
	name:     "CubicFeetPerSecond",
	symbol:   "ft³/s",
	fromBase: "m3s => m3s * 35.314,7",
	toBase:   "ft3s => ft3s * 0.028,316,8",
	matches:  []string{"ft³/s","ft³s","ft3/s","ft3s","ft^3/s","ft^3s","f³/s","f³s","f3/s","f3s","f^3/s","f^3s","cubicfeetpersecond","cubicfootpersecond","cubicfeet/second","cubicfoot/second"},
	typeOf:   FlowUnitType,
}

// ThousandCubicFeetPerDay (Unit)
// UnitType     : Flow
// UnitType.Base: CubicMetersPerSecond
// Unit.FromBase: m3s => m3s * 3,051.19        = MCFD
// Unit.ToBase  : MCFD => MCFD * 0.000,327,741 = m³/s
type ThousandCubicFeetPerDay struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Flow
}

// Name gets the name field
func (x ThousandCubicFeetPerDay) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x ThousandCubicFeetPerDay) Symbol() string {
    return x.symbol
}

// FromBase converts m³/s to MCFD
func (x ThousandCubicFeetPerDay) FromBase(m3s float64) float64 {
    return m3s * 3051.19
}

// ToBase converts m³/s to MCFD
func (x ThousandCubicFeetPerDay) ToBase(MCFD float64) float64 {
    return MCFD * 0.000327741
}

// MatchList gets the matches field
func (x ThousandCubicFeetPerDay) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandCubicFeetPerDay) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x ThousandCubicFeetPerDay) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x ThousandCubicFeetPerDay) Base() Unit {
    return CubicMetersPerSecondUnit
}

var ThousandCubicFeetPerDayUnit = ThousandCubicFeetPerDay {
	name:     "Thousand Cubic Feet per Day",
	symbol:   "MCFD",
	fromBase: "m3s => m3s * 3,051.19",
	toBase:   "MCFD => MCFD * 0.000,327,741",
	matches:  []string{"mcfd","mcf/d","mcftd","mcft/d","mft³/d","mft³d","mft3/d","mft3d","mft^3/d","mft^3d","mf³/d","mf³d","mf3/d","mf3d","mf^3/d","mf^3d","thousandcubicfeetperday","thousandcubicfeet/day"},
	typeOf:   FlowUnitType,
}

// Volume (UnitType)
// Contains 3 units:
//  - CubicMeters          m3 => m3               = m³
//  - CubicFeet            m3 => m3 * 35.314,7    = cu ft
//  - ThousandsOfCubicFeet m3 => m3 * 0.035,314,7 = MCF
// Base: CubicMeters
type Volume struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Volume) Name() string {
    return x.name
}

// Base gets the base field
func (x Volume) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Volume) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Volume) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Volume) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Volume) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var VolumeUnitType = Volume{
	name: "Volume",
	base: CubicMetersUnit,
	matches: []string{"volume"},
	units: []Unit{CubicMetersUnit,CubicFeetUnit,ThousandsOfCubicFeetUnit},
}

// CubicMeters (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMeters
// Unit.FromBase: m3 => m3 = m³
// Unit.ToBase  : m3 => m3 = m³
type CubicMeters struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Volume
}

// Name gets the name field
func (x CubicMeters) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x CubicMeters) Symbol() string {
    return x.symbol
}

// FromBase converts m³ to m³
func (x CubicMeters) FromBase(m3 float64) float64 {
    return m3
}

// ToBase converts m³ to m³
func (x CubicMeters) ToBase(m3 float64) float64 {
    return m3
}

// MatchList gets the matches field
func (x CubicMeters) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicMeters) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x CubicMeters) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x CubicMeters) Base() Unit {
    return CubicMetersUnit
}

var CubicMetersUnit = CubicMeters {
	name:     "Cubic Meters",
	symbol:   "m³",
	fromBase: "m3 => m3",
	toBase:   "m3 => m3",
	matches:  []string{"m³","m3","cubicmeter","cubicmeters"},
	typeOf:   VolumeUnitType,
}

// CubicFeet (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMeters
// Unit.FromBase: m3 => m3 * 35.314,7        = cu ft
// Unit.ToBase  : cuft => cuft * 0.028,316,8 = m³
type CubicFeet struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Volume
}

// Name gets the name field
func (x CubicFeet) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x CubicFeet) Symbol() string {
    return x.symbol
}

// FromBase converts m³ to cu ft
func (x CubicFeet) FromBase(m3 float64) float64 {
    return m3 * 35.3147
}

// ToBase converts m³ to cu ft
func (x CubicFeet) ToBase(cuft float64) float64 {
    return cuft * 0.0283168
}

// MatchList gets the matches field
func (x CubicFeet) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeet) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x CubicFeet) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x CubicFeet) Base() Unit {
    return CubicMetersUnit
}

var CubicFeetUnit = CubicFeet {
	name:     "Cubic Feet",
	symbol:   "cu ft",
	fromBase: "m3 => m3 * 35.314,7",
	toBase:   "cuft => cuft * 0.028,316,8",
	matches:  []string{"cuft","ft³","f³","cubicfoot","cubicfeet"},
	typeOf:   VolumeUnitType,
}

// ThousandsOfCubicFeet (Unit)
// UnitType     : Volume
// UnitType.Base: CubicMeters
// Unit.FromBase: m3 => m3 * 0.035,314,7 = MCF
// Unit.ToBase  : MCF => MCF * 28.316,8  = m³
type ThousandsOfCubicFeet struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Volume
}

// Name gets the name field
func (x ThousandsOfCubicFeet) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x ThousandsOfCubicFeet) Symbol() string {
    return x.symbol
}

// FromBase converts m³ to MCF
func (x ThousandsOfCubicFeet) FromBase(m3 float64) float64 {
    return m3 * 0.0353147
}

// ToBase converts m³ to MCF
func (x ThousandsOfCubicFeet) ToBase(MCF float64) float64 {
    return MCF * 28.3168
}

// MatchList gets the matches field
func (x ThousandsOfCubicFeet) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ThousandsOfCubicFeet) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x ThousandsOfCubicFeet) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x ThousandsOfCubicFeet) Base() Unit {
    return CubicMetersUnit
}

var ThousandsOfCubicFeetUnit = ThousandsOfCubicFeet {
	name:     "Thousands of Cubic Feet",
	symbol:   "MCF",
	fromBase: "m3 => m3 * 0.035,314,7",
	toBase:   "MCF => MCF * 28.316,8",
	matches:  []string{"mcf","mft³","mf³","thousandcubicfeet","thousandsofcubicfeet","thousandscubicfeet"},
	typeOf:   VolumeUnitType,
}

// ElectricPotential (UnitType)
// Contains 1 units:
//  - Volts V => V = V
// Base: Volts
type ElectricPotential struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x ElectricPotential) Name() string {
    return x.name
}

// Base gets the base field
func (x ElectricPotential) Base() Unit {
    return x.base
}

// Units gets the units field
func (x ElectricPotential) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x ElectricPotential) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x ElectricPotential) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x ElectricPotential) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var ElectricPotentialUnitType = ElectricPotential{
	name: "Electric Potential",
	base: VoltsUnit,
	matches: []string{"electricpotential","voltage"},
	units: []Unit{VoltsUnit},
}

// Volts (Unit)
// UnitType     : ElectricPotential
// UnitType.Base: Volts
// Unit.FromBase: V => V = V
// Unit.ToBase  : V => V = V
type Volts struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   ElectricPotential
}

// Name gets the name field
func (x Volts) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Volts) Symbol() string {
    return x.symbol
}

// FromBase converts V to V
func (x Volts) FromBase(V float64) float64 {
    return V
}

// ToBase converts V to V
func (x Volts) ToBase(V float64) float64 {
    return V
}

// MatchList gets the matches field
func (x Volts) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Volts) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Volts) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Volts) Base() Unit {
    return VoltsUnit
}

var VoltsUnit = Volts {
	name:     "Volts",
	symbol:   "V",
	fromBase: "V => V",
	toBase:   "V => V",
	matches:  []string{"volt","volts","v"},
	typeOf:   ElectricPotentialUnitType,
}

// Humidity (UnitType)
// Contains 1 units:
//  - Percent p => p = %!
(MISSING)// Base: Percent
type Humidity struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Humidity) Name() string {
    return x.name
}

// Base gets the base field
func (x Humidity) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Humidity) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Humidity) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Humidity) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Humidity) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var HumidityUnitType = Humidity{
	name: "Humidity",
	base: PercentUnit,
	matches: []string{"humidity"},
	units: []Unit{PercentUnit},
}

// Percent (Unit)
// UnitType     : Humidity
// UnitType.Base: Percent
// Unit.FromBase: p => p = %!!(MISSING)
(MISSING)// Unit.ToBase  : p => p = %!!(MISSING)
(MISSING)type Percent struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Humidity
}

// Name gets the name field
func (x Percent) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Percent) Symbol() string {
    return x.symbol
}

// FromBase converts %!!(MISSING)!(MISSING)t(MISSING)o %!!(MISSING)!(MISSING)
(MISSING)func (x Percent) FromBase(p float64) float64 {
    return p
}

// ToBase converts %!!(MISSING)!(MISSING)t(MISSING)o %!!(MISSING)!(MISSING)
(MISSING)func (x Percent) ToBase(p float64) float64 {
    return p
}

// MatchList gets the matches field
func (x Percent) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Percent) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Percent) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Percent) Base() Unit {
    return PercentUnit
}

var PercentUnit = Percent {
	name:     "Percent",
	symbol:   "%!!(MISSING)"(MISSING),
	fromBase: "p => p",
	toBase:   "p => p",
	matches:  []string{"%!!(MISSING)"(MISSING),"percent","percentage"},
	typeOf:   HumidityUnitType,
}

// Percentage (UnitType)
// Contains 1 units:
//  - Percent p => p = %!
(MISSING)// Base: Percent
type Percentage struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Percentage) Name() string {
    return x.name
}

// Base gets the base field
func (x Percentage) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Percentage) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Percentage) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Percentage) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Percentage) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var PercentageUnitType = Percentage{
	name: "Percentage",
	base: PercentUnit,
	matches: []string{"percentage"},
	units: []Unit{PercentUnit},
}

// Percent (Unit)
// UnitType     : Percentage
// UnitType.Base: Percent
// Unit.FromBase: p => p = %!!(MISSING)
(MISSING)// Unit.ToBase  : p => p = %!!(MISSING)
(MISSING)type Percent struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Percentage
}

// Name gets the name field
func (x Percent) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Percent) Symbol() string {
    return x.symbol
}

// FromBase converts %!!(MISSING)!(MISSING)t(MISSING)o %!!(MISSING)!(MISSING)
(MISSING)func (x Percent) FromBase(p float64) float64 {
    return p
}

// ToBase converts %!!(MISSING)!(MISSING)t(MISSING)o %!!(MISSING)!(MISSING)
(MISSING)func (x Percent) ToBase(p float64) float64 {
    return p
}

// MatchList gets the matches field
func (x Percent) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Percent) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Percent) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Percent) Base() Unit {
    return PercentUnit
}

var PercentUnit = Percent {
	name:     "Percent",
	symbol:   "%!!(MISSING)"(MISSING),
	fromBase: "p => p",
	toBase:   "p => p",
	matches:  []string{"%!!(MISSING)"(MISSING),"percent","percentage"},
	typeOf:   PercentageUnitType,
}

// Alarm (UnitType)
// Contains 1 units:
//  - Percent p => p = \%!
(MISSING)// Base: Percent
type Alarm struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Alarm) Name() string {
    return x.name
}

// Base gets the base field
func (x Alarm) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Alarm) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Alarm) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Alarm) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Alarm) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var AlarmUnitType = Alarm{
	name: "Alarm",
	base: PercentUnit,
	matches: []string{"alarm"},
	units: []Unit{PercentUnit},
}

// Percent (Unit)
// UnitType     : Alarm
// UnitType.Base: Percent
// Unit.FromBase: p => p = \%!!(MISSING)
(MISSING)// Unit.ToBase  : p => p = \%!!(MISSING)
(MISSING)type Percent struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Alarm
}

// Name gets the name field
func (x Percent) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Percent) Symbol() string {
    return x.symbol
}

// FromBase converts \%!!(MISSING)!(MISSING)t(MISSING)o \%!!(MISSING)!(MISSING)
(MISSING)func (x Percent) FromBase(p float64) float64 {
    return p
}

// ToBase converts \%!!(MISSING)!(MISSING)t(MISSING)o \%!!(MISSING)!(MISSING)
(MISSING)func (x Percent) ToBase(p float64) float64 {
    return p
}

// MatchList gets the matches field
func (x Percent) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Percent) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Percent) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Percent) Base() Unit {
    return PercentUnit
}

var PercentUnit = Percent {
	name:     "Percent",
	symbol:   "\%!!(MISSING)"(MISSING),
	fromBase: "p => p",
	toBase:   "p => p",
	matches:  []string{"\%!!(MISSING)"(MISSING),"percent","percentage"},
	typeOf:   AlarmUnitType,
}

// Work (UnitType)
// Contains 4 units:
//  - Joules                 J => J                         = J
//  - InchPoundsForce        J => J * 8.850,74              = in lbf
//  - CubicFeetOfNaturalGas  J => J * 0.000,000,947,817     = BTUᵢₜ
//  - BarrelsOfOilEquivalent J => J * 0.000,000,000,163,399 = bboe
// Base: Joules
type Work struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Work) Name() string {
    return x.name
}

// Base gets the base field
func (x Work) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Work) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Work) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Work) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Work) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var WorkUnitType = Work{
	name: "Work",
	base: JoulesUnit,
	matches: []string{"work"},
	units: []Unit{JoulesUnit,InchPoundsForceUnit,CubicFeetOfNaturalGasUnit,BarrelsOfOilEquivalentUnit},
}

// Joules (Unit)
// UnitType     : Work
// UnitType.Base: Joules
// Unit.FromBase: J => J = J
// Unit.ToBase  : J => J = J
type Joules struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x Joules) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Joules) Symbol() string {
    return x.symbol
}

// FromBase converts J to J
func (x Joules) FromBase(J float64) float64 {
    return J
}

// ToBase converts J to J
func (x Joules) ToBase(J float64) float64 {
    return J
}

// MatchList gets the matches field
func (x Joules) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Joules) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Joules) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Joules) Base() Unit {
    return JoulesUnit
}

var JoulesUnit = Joules {
	name:     "Joules",
	symbol:   "J",
	fromBase: "J => J",
	toBase:   "J => J",
	matches:  []string{"j","joule","joules"},
	typeOf:   WorkUnitType,
}

// InchPoundsForce (Unit)
// UnitType     : Work
// UnitType.Base: Joules
// Unit.FromBase: J => J * 8.850,74          = in lbf
// Unit.ToBase  : inlbf => inlbf * 0.112,985 = J
type InchPoundsForce struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x InchPoundsForce) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x InchPoundsForce) Symbol() string {
    return x.symbol
}

// FromBase converts J to in lbf
func (x InchPoundsForce) FromBase(J float64) float64 {
    return J * 8.85074
}

// ToBase converts J to in lbf
func (x InchPoundsForce) ToBase(inlbf float64) float64 {
    return inlbf * 0.112985
}

// MatchList gets the matches field
func (x InchPoundsForce) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x InchPoundsForce) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x InchPoundsForce) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x InchPoundsForce) Base() Unit {
    return JoulesUnit
}

var InchPoundsForceUnit = InchPoundsForce {
	name:     "Inch-pounds Force",
	symbol:   "in lbf",
	fromBase: "J => J * 8.850,74",
	toBase:   "inlbf => inlbf * 0.112,985",
	matches:  []string{"inlbf","inch-poundsforce","inch-poundforce","in-lbf"},
	typeOf:   WorkUnitType,
}

// CubicFeetOfNaturalGas (Unit)
// UnitType     : Work
// UnitType.Base: Joules
// Unit.FromBase: J => J * 0.000,000,947,817 = BTUᵢₜ
// Unit.ToBase  : btu => btu * 1,055,060     = J
type CubicFeetOfNaturalGas struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x CubicFeetOfNaturalGas) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x CubicFeetOfNaturalGas) Symbol() string {
    return x.symbol
}

// FromBase converts J to BTUᵢₜ
func (x CubicFeetOfNaturalGas) FromBase(J float64) float64 {
    return J * 0.000000947817
}

// ToBase converts J to BTUᵢₜ
func (x CubicFeetOfNaturalGas) ToBase(btu float64) float64 {
    return btu * 1055060
}

// MatchList gets the matches field
func (x CubicFeetOfNaturalGas) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x CubicFeetOfNaturalGas) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x CubicFeetOfNaturalGas) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x CubicFeetOfNaturalGas) Base() Unit {
    return JoulesUnit
}

var CubicFeetOfNaturalGasUnit = CubicFeetOfNaturalGas {
	name:     "Cubic Feet of Natural Gas",
	symbol:   "BTUᵢₜ",
	fromBase: "J => J * 0.000,000,947,817",
	toBase:   "btu => btu * 1,055,060",
	matches:  []string{"btuᵢₜ","btuit","btu","cubicfeetofnaturalgas"},
	typeOf:   WorkUnitType,
}

// BarrelsOfOilEquivalent (Unit)
// UnitType     : Work
// UnitType.Base: Joules
// Unit.FromBase: J => J * 0.000,000,000,163,399 = bboe
// Unit.ToBase  : bboe => bboe * 6,120,000,000   = J
type BarrelsOfOilEquivalent struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Work
}

// Name gets the name field
func (x BarrelsOfOilEquivalent) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x BarrelsOfOilEquivalent) Symbol() string {
    return x.symbol
}

// FromBase converts J to bboe
func (x BarrelsOfOilEquivalent) FromBase(J float64) float64 {
    return J * 0.000000000163399
}

// ToBase converts J to bboe
func (x BarrelsOfOilEquivalent) ToBase(bboe float64) float64 {
    return bboe * 6120000000
}

// MatchList gets the matches field
func (x BarrelsOfOilEquivalent) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x BarrelsOfOilEquivalent) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x BarrelsOfOilEquivalent) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x BarrelsOfOilEquivalent) Base() Unit {
    return JoulesUnit
}

var BarrelsOfOilEquivalentUnit = BarrelsOfOilEquivalent {
	name:     "Barrels of Oil Equivalent",
	symbol:   "bboe",
	fromBase: "J => J * 0.000,000,000,163,399",
	toBase:   "bboe => bboe * 6,120,000,000",
	matches:  []string{"bboe","barrelsofoilequivalent"},
	typeOf:   WorkUnitType,
}

// Force (UnitType)
// Contains 3 units:
//  - Newtons        N => N             = N
//  - PoundsForce    N => N * 0.224,809 = lbf
//  - KilogramsForce N => N * 0.101,972 = kgf
// Base: Newtons
type Force struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Force) Name() string {
    return x.name
}

// Base gets the base field
func (x Force) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Force) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Force) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Force) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Force) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var ForceUnitType = Force{
	name: "Force",
	base: NewtonsUnit,
	matches: []string{"force"},
	units: []Unit{NewtonsUnit,PoundsForceUnit,KilogramsForceUnit},
}

// Newtons (Unit)
// UnitType     : Force
// UnitType.Base: Newtons
// Unit.FromBase: N => N = N
// Unit.ToBase  : N => N = N
type Newtons struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Force
}

// Name gets the name field
func (x Newtons) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Newtons) Symbol() string {
    return x.symbol
}

// FromBase converts N to N
func (x Newtons) FromBase(N float64) float64 {
    return N
}

// ToBase converts N to N
func (x Newtons) ToBase(N float64) float64 {
    return N
}

// MatchList gets the matches field
func (x Newtons) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Newtons) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Newtons) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Newtons) Base() Unit {
    return NewtonsUnit
}

var NewtonsUnit = Newtons {
	name:     "Newtons",
	symbol:   "N",
	fromBase: "N => N",
	toBase:   "N => N",
	matches:  []string{"n","newton","newtons"},
	typeOf:   ForceUnitType,
}

// PoundsForce (Unit)
// UnitType     : Force
// UnitType.Base: Newtons
// Unit.FromBase: N => N * 0.224,809    = lbf
// Unit.ToBase  : lbf => lbf * 4.448,22 = N
type PoundsForce struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Force
}

// Name gets the name field
func (x PoundsForce) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x PoundsForce) Symbol() string {
    return x.symbol
}

// FromBase converts N to lbf
func (x PoundsForce) FromBase(N float64) float64 {
    return N * 0.224809
}

// ToBase converts N to lbf
func (x PoundsForce) ToBase(lbf float64) float64 {
    return lbf * 4.44822
}

// MatchList gets the matches field
func (x PoundsForce) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x PoundsForce) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x PoundsForce) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x PoundsForce) Base() Unit {
    return NewtonsUnit
}

var PoundsForceUnit = PoundsForce {
	name:     "Pounds-force",
	symbol:   "lbf",
	fromBase: "N => N * 0.224,809",
	toBase:   "lbf => lbf * 4.448,22",
	matches:  []string{"lbf","pounds-force","poundsforce","pound-force","poundforce"},
	typeOf:   ForceUnitType,
}

// KilogramsForce (Unit)
// UnitType     : Force
// UnitType.Base: Newtons
// Unit.FromBase: N => N * 0.101,972    = kgf
// Unit.ToBase  : kgf => kgf * 9.806,65 = N
type KilogramsForce struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Force
}

// Name gets the name field
func (x KilogramsForce) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x KilogramsForce) Symbol() string {
    return x.symbol
}

// FromBase converts N to kgf
func (x KilogramsForce) FromBase(N float64) float64 {
    return N * 0.101972
}

// ToBase converts N to kgf
func (x KilogramsForce) ToBase(kgf float64) float64 {
    return kgf * 9.80665
}

// MatchList gets the matches field
func (x KilogramsForce) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x KilogramsForce) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x KilogramsForce) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x KilogramsForce) Base() Unit {
    return NewtonsUnit
}

var KilogramsForceUnit = KilogramsForce {
	name:     "Kilograms-force",
	symbol:   "kgf",
	fromBase: "N => N * 0.101,972",
	toBase:   "kgf => kgf * 9.806,65",
	matches:  []string{"kgf","kilograms-force","kilogram-force"},
	typeOf:   ForceUnitType,
}

// Length (UnitType)
// Contains 3 units:
//  - Meters m => m            = m
//  - Feet   m => m * 3.280,84 = ft
//  - Inches m => m * 39.370,1 = in
// Base: Meters
type Length struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Length) Name() string {
    return x.name
}

// Base gets the base field
func (x Length) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Length) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Length) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Length) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Length) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var LengthUnitType = Length{
	name: "Length",
	base: MetersUnit,
	matches: []string{"l","length"},
	units: []Unit{MetersUnit,FeetUnit,InchesUnit},
}

// Meters (Unit)
// UnitType     : Length
// UnitType.Base: Meters
// Unit.FromBase: m => m = m
// Unit.ToBase  : m => m = m
type Meters struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Length
}

// Name gets the name field
func (x Meters) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Meters) Symbol() string {
    return x.symbol
}

// FromBase converts m to m
func (x Meters) FromBase(m float64) float64 {
    return m
}

// ToBase converts m to m
func (x Meters) ToBase(m float64) float64 {
    return m
}

// MatchList gets the matches field
func (x Meters) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Meters) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Meters) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Meters) Base() Unit {
    return MetersUnit
}

var MetersUnit = Meters {
	name:     "Meters",
	symbol:   "m",
	fromBase: "m => m",
	toBase:   "m => m",
	matches:  []string{"m","meter","meters"},
	typeOf:   LengthUnitType,
}

// Feet (Unit)
// UnitType     : Length
// UnitType.Base: Meters
// Unit.FromBase: m => m * 3.280,84    = ft
// Unit.ToBase  : ft => ft * 0.304,800 = m
type Feet struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Length
}

// Name gets the name field
func (x Feet) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Feet) Symbol() string {
    return x.symbol
}

// FromBase converts m to ft
func (x Feet) FromBase(m float64) float64 {
    return m * 3.28084
}

// ToBase converts m to ft
func (x Feet) ToBase(ft float64) float64 {
    return ft * 0.304800
}

// MatchList gets the matches field
func (x Feet) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Feet) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Feet) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Feet) Base() Unit {
    return MetersUnit
}

var FeetUnit = Feet {
	name:     "Feet",
	symbol:   "ft",
	fromBase: "m => m * 3.280,84",
	toBase:   "ft => ft * 0.304,800",
	matches:  []string{"ft","foot","feet"},
	typeOf:   LengthUnitType,
}

// Inches (Unit)
// UnitType     : Length
// UnitType.Base: Meters
// Unit.FromBase: m => m * 39.370,1     = in
// Unit.ToBase  : in => in * 0.0254,000 = m
type Inches struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Length
}

// Name gets the name field
func (x Inches) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Inches) Symbol() string {
    return x.symbol
}

// FromBase converts m to in
func (x Inches) FromBase(m float64) float64 {
    return m * 39.3701
}

// ToBase converts m to in
func (x Inches) ToBase(in float64) float64 {
    return in * 0.0254000
}

// MatchList gets the matches field
func (x Inches) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Inches) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Inches) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Inches) Base() Unit {
    return MetersUnit
}

var InchesUnit = Inches {
	name:     "Inches",
	symbol:   "in",
	fromBase: "m => m * 39.370,1",
	toBase:   "in => in * 0.0254,000",
	matches:  []string{"in","inch","inches"},
	typeOf:   LengthUnitType,
}

// StrokeRate (UnitType)
// Contains 1 units:
//  - StrokesPerSecond ss => ss = strokes/s
// Base: StrokesPerSecond
type StrokeRate struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x StrokeRate) Name() string {
    return x.name
}

// Base gets the base field
func (x StrokeRate) Base() Unit {
    return x.base
}

// Units gets the units field
func (x StrokeRate) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x StrokeRate) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x StrokeRate) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokeRate) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var StrokeRateUnitType = StrokeRate{
	name: "Stroke Rate",
	base: StrokesPerSecondUnit,
	matches: []string{"strokerate","stroke-rate"},
	units: []Unit{StrokesPerSecondUnit},
}

// StrokesPerSecond (Unit)
// UnitType     : StrokeRate
// UnitType.Base: StrokesPerSecond
// Unit.FromBase: ss => ss = strokes/s
// Unit.ToBase  : ss => ss = strokes/s
type StrokesPerSecond struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   StrokeRate
}

// Name gets the name field
func (x StrokesPerSecond) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x StrokesPerSecond) Symbol() string {
    return x.symbol
}

// FromBase converts strokes/s to strokes/s
func (x StrokesPerSecond) FromBase(ss float64) float64 {
    return ss
}

// ToBase converts strokes/s to strokes/s
func (x StrokesPerSecond) ToBase(ss float64) float64 {
    return ss
}

// MatchList gets the matches field
func (x StrokesPerSecond) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x StrokesPerSecond) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x StrokesPerSecond) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x StrokesPerSecond) Base() Unit {
    return StrokesPerSecondUnit
}

var StrokesPerSecondUnit = StrokesPerSecond {
	name:     "Strokes per Second",
	symbol:   "strokes/s",
	fromBase: "ss => ss",
	toBase:   "ss => ss",
	matches:  []string{"strokes/s","strokespersecond","s/s"},
	typeOf:   StrokeRateUnitType,
}

// Number (UnitType)
// Contains 1 units:
//  - Number n => n = 
// Base: Number
type Number struct {
	name    string
	base    Unit
	matches []string
	units   []Unit
}

// Name gets the name field
func (x Number) Name() string {
    return x.name
}

// Base gets the base field
func (x Number) Base() Unit {
    return x.base
}

// Units gets the units field
func (x Number) Units() []Unit {
    return x.units
}

// UnitList returns the list of units as strings
func (x Number) UnitList() []string {
    var list []string
    for _, u := range x.units {
    	list = append(list, u.Name())
    }
    return list
}

// MatchList gets the matches field
func (x Number) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Number) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

var NumberUnitType = Number{
	name: "Number",
	base: NumberUnit,
	matches: []string{"\*"},
	units: []Unit{NumberUnit},
}

// Number (Unit)
// UnitType     : Number
// UnitType.Base: Number
// Unit.FromBase: n => n = 
// Unit.ToBase  : n => n = 
type Number struct {
	name     string
	symbol   string
	fromBase string
	toBase   string
	matches  []string
	typeOf   Number
}

// Name gets the name field
func (x Number) Name() string {
    return x.name
}

// Symbol gets the symbol field
func (x Number) Symbol() string {
    return x.symbol
}

// FromBase converts  to 
func (x Number) FromBase(n float64) float64 {
    return n
}

// ToBase converts  to 
func (x Number) ToBase(n float64) float64 {
    return n
}

// MatchList gets the matches field
func (x Number) MatchList() []string {
    return x.matches
}

// Matches returns true if check matches our possible names.
// Helpful when a user is allowed to enter in unit types
// freehand, for example.
func (x Number) Matches(check string) bool {
    for _, m := range x.matches {
    	if m == check {
    		return true
    	}
    }
    return false
}

// TypeOf gets the typeOf field
func (x Number) TypeOf() UnitType {
    return x.typeOf
}

// Base returns the base unit
func (x Number) Base() Unit {
    return NumberUnit
}

var NumberUnit = Number {
	name:     "Number",
	symbol:   "",
	fromBase: "n => n",
	toBase:   "n => n",
	matches:  []string{"number",""},
	typeOf:   NumberUnitType,
}